"bundle";
(function() {
var define = System.amdDefine;
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory() : typeof define === 'function' && define.amd ? define("node_modules/zone.js/dist/zone.js", [], factory) : (factory());
}(this, (function() {
  'use strict';
  var Zone$1 = (function(global) {
    var performance = global['performance'];
    function mark(name) {
      performance && performance['mark'] && performance['mark'](name);
    }
    function performanceMeasure(name, label) {
      performance && performance['measure'] && performance['measure'](name, label);
    }
    mark('Zone');
    if (global['Zone']) {
      throw new Error('Zone already loaded.');
    }
    var Zone = (function() {
      function Zone(parent, zoneSpec) {
        this._properties = null;
        this._parent = parent;
        this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';
        this._properties = zoneSpec && zoneSpec.properties || {};
        this._zoneDelegate = new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
      }
      Zone.assertZonePatched = function() {
        if (global['Promise'] !== patches['ZoneAwarePromise']) {
          throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' + 'has been overwritten.\n' + 'Most likely cause is that a Promise polyfill has been loaded ' + 'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' + 'If you must load one, do so before loading zone.js.)');
        }
      };
      Object.defineProperty(Zone, "root", {
        get: function() {
          var zone = Zone.current;
          while (zone.parent) {
            zone = zone.parent;
          }
          return zone;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Zone, "current", {
        get: function() {
          return _currentZoneFrame.zone;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Zone, "currentTask", {
        get: function() {
          return _currentTask;
        },
        enumerable: true,
        configurable: true
      });
      Zone.__load_patch = function(name, fn) {
        if (patches.hasOwnProperty(name)) {
          throw Error('Already loaded patch: ' + name);
        } else if (!global['__Zone_disable_' + name]) {
          var perfName = 'Zone:' + name;
          mark(perfName);
          patches[name] = fn(global, Zone, _api);
          performanceMeasure(perfName, perfName);
        }
      };
      Object.defineProperty(Zone.prototype, "parent", {
        get: function() {
          return this._parent;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Zone.prototype, "name", {
        get: function() {
          return this._name;
        },
        enumerable: true,
        configurable: true
      });
      Zone.prototype.get = function(key) {
        var zone = this.getZoneWith(key);
        if (zone)
          return zone._properties[key];
      };
      Zone.prototype.getZoneWith = function(key) {
        var current = this;
        while (current) {
          if (current._properties.hasOwnProperty(key)) {
            return current;
          }
          current = current._parent;
        }
        return null;
      };
      Zone.prototype.fork = function(zoneSpec) {
        if (!zoneSpec)
          throw new Error('ZoneSpec required!');
        return this._zoneDelegate.fork(this, zoneSpec);
      };
      Zone.prototype.wrap = function(callback, source) {
        if (typeof callback !== 'function') {
          throw new Error('Expecting function got: ' + callback);
        }
        var _callback = this._zoneDelegate.intercept(this, callback, source);
        var zone = this;
        return function() {
          return zone.runGuarded(_callback, this, arguments, source);
        };
      };
      Zone.prototype.run = function(callback, applyThis, applyArgs, source) {
        if (applyThis === void 0) {
          applyThis = undefined;
        }
        if (applyArgs === void 0) {
          applyArgs = null;
        }
        if (source === void 0) {
          source = null;
        }
        _currentZoneFrame = {
          parent: _currentZoneFrame,
          zone: this
        };
        try {
          return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
        } finally {
          _currentZoneFrame = _currentZoneFrame.parent;
        }
      };
      Zone.prototype.runGuarded = function(callback, applyThis, applyArgs, source) {
        if (applyThis === void 0) {
          applyThis = null;
        }
        if (applyArgs === void 0) {
          applyArgs = null;
        }
        if (source === void 0) {
          source = null;
        }
        _currentZoneFrame = {
          parent: _currentZoneFrame,
          zone: this
        };
        try {
          try {
            return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
          } catch (error) {
            if (this._zoneDelegate.handleError(this, error)) {
              throw error;
            }
          }
        } finally {
          _currentZoneFrame = _currentZoneFrame.parent;
        }
      };
      Zone.prototype.runTask = function(task, applyThis, applyArgs) {
        if (task.zone != this) {
          throw new Error('A task can only be run in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
        }
        var isNotScheduled = task.state === notScheduled;
        if (isNotScheduled && task.type === eventTask) {
          return;
        }
        var reEntryGuard = task.state != running;
        reEntryGuard && task._transitionTo(running, scheduled);
        task.runCount++;
        var previousTask = _currentTask;
        _currentTask = task;
        _currentZoneFrame = {
          parent: _currentZoneFrame,
          zone: this
        };
        try {
          if (task.type == macroTask && task.data && !task.data.isPeriodic) {
            task.cancelFn = null;
          }
          try {
            return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);
          } catch (error) {
            if (this._zoneDelegate.handleError(this, error)) {
              throw error;
            }
          }
        } finally {
          if (task.state !== notScheduled && task.state !== unknown) {
            if (task.type == eventTask || (task.data && task.data.isPeriodic)) {
              reEntryGuard && task._transitionTo(scheduled, running);
            } else {
              task.runCount = 0;
              this._updateTaskCount(task, -1);
              reEntryGuard && task._transitionTo(notScheduled, running, notScheduled);
            }
          }
          _currentZoneFrame = _currentZoneFrame.parent;
          _currentTask = previousTask;
        }
      };
      Zone.prototype.scheduleTask = function(task) {
        if (task.zone && task.zone !== this) {
          var newZone = this;
          while (newZone) {
            if (newZone === task.zone) {
              throw Error("can not reschedule task to " + this.name + " which is descendants of the original zone " + task.zone.name);
            }
            newZone = newZone.parent;
          }
        }
        task._transitionTo(scheduling, notScheduled);
        var zoneDelegates = [];
        task._zoneDelegates = zoneDelegates;
        task._zone = this;
        try {
          task = this._zoneDelegate.scheduleTask(this, task);
        } catch (err) {
          task._transitionTo(unknown, scheduling, notScheduled);
          this._zoneDelegate.handleError(this, err);
          throw err;
        }
        if (task._zoneDelegates === zoneDelegates) {
          this._updateTaskCount(task, 1);
        }
        if (task.state == scheduling) {
          task._transitionTo(scheduled, scheduling);
        }
        return task;
      };
      Zone.prototype.scheduleMicroTask = function(source, callback, data, customSchedule) {
        return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, null));
      };
      Zone.prototype.scheduleMacroTask = function(source, callback, data, customSchedule, customCancel) {
        return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
      };
      Zone.prototype.scheduleEventTask = function(source, callback, data, customSchedule, customCancel) {
        return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
      };
      Zone.prototype.cancelTask = function(task) {
        if (task.zone != this)
          throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
        task._transitionTo(canceling, scheduled, running);
        try {
          this._zoneDelegate.cancelTask(this, task);
        } catch (err) {
          task._transitionTo(unknown, canceling);
          this._zoneDelegate.handleError(this, err);
          throw err;
        }
        this._updateTaskCount(task, -1);
        task._transitionTo(notScheduled, canceling);
        task.runCount = 0;
        return task;
      };
      Zone.prototype._updateTaskCount = function(task, count) {
        var zoneDelegates = task._zoneDelegates;
        if (count == -1) {
          task._zoneDelegates = null;
        }
        for (var i = 0; i < zoneDelegates.length; i++) {
          zoneDelegates[i]._updateTaskCount(task.type, count);
        }
      };
      return Zone;
    }());
    Zone.__symbol__ = __symbol__;
    var DELEGATE_ZS = {
      name: '',
      onHasTask: function(delegate, _, target, hasTaskState) {
        return delegate.hasTask(target, hasTaskState);
      },
      onScheduleTask: function(delegate, _, target, task) {
        return delegate.scheduleTask(target, task);
      },
      onInvokeTask: function(delegate, _, target, task, applyThis, applyArgs) {
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      },
      onCancelTask: function(delegate, _, target, task) {
        return delegate.cancelTask(target, task);
      }
    };
    var ZoneDelegate = (function() {
      function ZoneDelegate(zone, parentDelegate, zoneSpec) {
        this._taskCounts = {
          'microTask': 0,
          'macroTask': 0,
          'eventTask': 0
        };
        this.zone = zone;
        this._parentDelegate = parentDelegate;
        this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
        this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
        this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate.zone);
        this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
        this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
        this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);
        this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
        this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
        this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);
        this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
        this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
        this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);
        this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
        this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
        this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);
        this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
        this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
        this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);
        this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
        this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
        this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);
        this._hasTaskZS = null;
        this._hasTaskDlgt = null;
        this._hasTaskDlgtOwner = null;
        this._hasTaskCurrZone = null;
        var zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
        var parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
        if (zoneSpecHasTask || parentHasTask) {
          this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
          this._hasTaskDlgt = parentDelegate;
          this._hasTaskDlgtOwner = this;
          this._hasTaskCurrZone = zone;
          if (!zoneSpec.onScheduleTask) {
            this._scheduleTaskZS = DELEGATE_ZS;
            this._scheduleTaskDlgt = parentDelegate;
            this._scheduleTaskCurrZone = this.zone;
          }
          if (!zoneSpec.onInvokeTask) {
            this._invokeTaskZS = DELEGATE_ZS;
            this._invokeTaskDlgt = parentDelegate;
            this._invokeTaskCurrZone = this.zone;
          }
          if (!zoneSpec.onCancelTask) {
            this._cancelTaskZS = DELEGATE_ZS;
            this._cancelTaskDlgt = parentDelegate;
            this._cancelTaskCurrZone = this.zone;
          }
        }
      }
      ZoneDelegate.prototype.fork = function(targetZone, zoneSpec) {
        return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new Zone(targetZone, zoneSpec);
      };
      ZoneDelegate.prototype.intercept = function(targetZone, callback, source) {
        return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;
      };
      ZoneDelegate.prototype.invoke = function(targetZone, callback, applyThis, applyArgs, source) {
        return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);
      };
      ZoneDelegate.prototype.handleError = function(targetZone, error) {
        return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;
      };
      ZoneDelegate.prototype.scheduleTask = function(targetZone, task) {
        var returnTask = task;
        if (this._scheduleTaskZS) {
          if (this._hasTaskZS) {
            returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
          }
          returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
          if (!returnTask)
            returnTask = task;
        } else {
          if (task.scheduleFn) {
            task.scheduleFn(task);
          } else if (task.type == microTask) {
            scheduleMicroTask(task);
          } else {
            throw new Error('Task is missing scheduleFn.');
          }
        }
        return returnTask;
      };
      ZoneDelegate.prototype.invokeTask = function(targetZone, task, applyThis, applyArgs) {
        return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);
      };
      ZoneDelegate.prototype.cancelTask = function(targetZone, task) {
        var value;
        if (this._cancelTaskZS) {
          value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
        } else {
          if (!task.cancelFn) {
            throw Error('Task is not cancelable');
          }
          value = task.cancelFn(task);
        }
        return value;
      };
      ZoneDelegate.prototype.hasTask = function(targetZone, isEmpty) {
        try {
          return this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
        } catch (err) {
          this.handleError(targetZone, err);
        }
      };
      ZoneDelegate.prototype._updateTaskCount = function(type, count) {
        var counts = this._taskCounts;
        var prev = counts[type];
        var next = counts[type] = prev + count;
        if (next < 0) {
          throw new Error('More tasks executed then were scheduled.');
        }
        if (prev == 0 || next == 0) {
          var isEmpty = {
            microTask: counts.microTask > 0,
            macroTask: counts.macroTask > 0,
            eventTask: counts.eventTask > 0,
            change: type
          };
          this.hasTask(this.zone, isEmpty);
        }
      };
      return ZoneDelegate;
    }());
    var ZoneTask = (function() {
      function ZoneTask(type, source, callback, options, scheduleFn, cancelFn) {
        this._zone = null;
        this.runCount = 0;
        this._zoneDelegates = null;
        this._state = 'notScheduled';
        this.type = type;
        this.source = source;
        this.data = options;
        this.scheduleFn = scheduleFn;
        this.cancelFn = cancelFn;
        this.callback = callback;
        var self = this;
        if (type === eventTask && options && options.isUsingGlobalCallback) {
          this.invoke = ZoneTask.invokeTask;
        } else {
          this.invoke = function() {
            return ZoneTask.invokeTask.apply(global, [self, this, arguments]);
          };
        }
      }
      ZoneTask.invokeTask = function(task, target, args) {
        if (!task) {
          task = this;
        }
        _numberOfNestedTaskFrames++;
        try {
          task.runCount++;
          return task.zone.runTask(task, target, args);
        } finally {
          if (_numberOfNestedTaskFrames == 1) {
            drainMicroTaskQueue();
          }
          _numberOfNestedTaskFrames--;
        }
      };
      Object.defineProperty(ZoneTask.prototype, "zone", {
        get: function() {
          return this._zone;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ZoneTask.prototype, "state", {
        get: function() {
          return this._state;
        },
        enumerable: true,
        configurable: true
      });
      ZoneTask.prototype.cancelScheduleRequest = function() {
        this._transitionTo(notScheduled, scheduling);
      };
      ZoneTask.prototype._transitionTo = function(toState, fromState1, fromState2) {
        if (this._state === fromState1 || this._state === fromState2) {
          this._state = toState;
          if (toState == notScheduled) {
            this._zoneDelegates = null;
          }
        } else {
          throw new Error(this.type + " '" + this.source + "': can not transition to '" + toState + "', expecting state '" + fromState1 + "'" + (fromState2 ? ' or \'' + fromState2 + '\'' : '') + ", was '" + this._state + "'.");
        }
      };
      ZoneTask.prototype.toString = function() {
        if (this.data && typeof this.data.handleId !== 'undefined') {
          return this.data.handleId;
        } else {
          return Object.prototype.toString.call(this);
        }
      };
      ZoneTask.prototype.toJSON = function() {
        return {
          type: this.type,
          state: this.state,
          source: this.source,
          zone: this.zone.name,
          invoke: this.invoke,
          scheduleFn: this.scheduleFn,
          cancelFn: this.cancelFn,
          runCount: this.runCount,
          callback: this.callback
        };
      };
      return ZoneTask;
    }());
    var symbolSetTimeout = __symbol__('setTimeout');
    var symbolPromise = __symbol__('Promise');
    var symbolThen = __symbol__('then');
    var _microTaskQueue = [];
    var _isDrainingMicrotaskQueue = false;
    function scheduleMicroTask(task) {
      if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
        if (global[symbolPromise]) {
          global[symbolPromise].resolve(0)[symbolThen](drainMicroTaskQueue);
        } else {
          global[symbolSetTimeout](drainMicroTaskQueue, 0);
        }
      }
      task && _microTaskQueue.push(task);
    }
    function drainMicroTaskQueue() {
      if (!_isDrainingMicrotaskQueue) {
        _isDrainingMicrotaskQueue = true;
        while (_microTaskQueue.length) {
          var queue = _microTaskQueue;
          _microTaskQueue = [];
          for (var i = 0; i < queue.length; i++) {
            var task = queue[i];
            try {
              task.zone.runTask(task, null, null);
            } catch (error) {
              _api.onUnhandledError(error);
            }
          }
        }
        var showError = !Zone[__symbol__('ignoreConsoleErrorUncaughtError')];
        _api.microtaskDrainDone();
        _isDrainingMicrotaskQueue = false;
      }
    }
    var NO_ZONE = {name: 'NO ZONE'};
    var notScheduled = 'notScheduled',
        scheduling = 'scheduling',
        scheduled = 'scheduled',
        running = 'running',
        canceling = 'canceling',
        unknown = 'unknown';
    var microTask = 'microTask',
        macroTask = 'macroTask',
        eventTask = 'eventTask';
    var patches = {};
    var _api = {
      symbol: __symbol__,
      currentZoneFrame: function() {
        return _currentZoneFrame;
      },
      onUnhandledError: noop,
      microtaskDrainDone: noop,
      scheduleMicroTask: scheduleMicroTask,
      showUncaughtError: function() {
        return !Zone[__symbol__('ignoreConsoleErrorUncaughtError')];
      },
      patchEventTarget: function() {
        return [];
      },
      patchOnProperties: noop,
      patchMethod: function() {
        return noop;
      }
    };
    var _currentZoneFrame = {
      parent: null,
      zone: new Zone(null, null)
    };
    var _currentTask = null;
    var _numberOfNestedTaskFrames = 0;
    function noop() {}
    function __symbol__(name) {
      return '__zone_symbol__' + name;
    }
    performanceMeasure('Zone', 'Zone');
    return global['Zone'] = Zone;
  })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);
  Zone.__load_patch('ZoneAwarePromise', function(global, Zone, api) {
    var __symbol__ = api.symbol;
    var _uncaughtPromiseErrors = [];
    var symbolPromise = __symbol__('Promise');
    var symbolThen = __symbol__('then');
    api.onUnhandledError = function(e) {
      if (api.showUncaughtError()) {
        var rejection = e && e.rejection;
        if (rejection) {
          console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);
        } else {
          console.error(e);
        }
      }
    };
    api.microtaskDrainDone = function() {
      while (_uncaughtPromiseErrors.length) {
        var _loop_1 = function() {
          var uncaughtPromiseError = _uncaughtPromiseErrors.shift();
          try {
            uncaughtPromiseError.zone.runGuarded(function() {
              throw uncaughtPromiseError;
            });
          } catch (error) {
            handleUnhandledRejection(error);
          }
        };
        while (_uncaughtPromiseErrors.length) {
          _loop_1();
        }
      }
    };
    function handleUnhandledRejection(e) {
      api.onUnhandledError(e);
      try {
        var handler = Zone[__symbol__('unhandledPromiseRejectionHandler')];
        if (handler && typeof handler === 'function') {
          handler.apply(this, [e]);
        }
      } catch (err) {}
    }
    function isThenable(value) {
      return value && value.then;
    }
    function forwardResolution(value) {
      return value;
    }
    function forwardRejection(rejection) {
      return ZoneAwarePromise.reject(rejection);
    }
    var symbolState = __symbol__('state');
    var symbolValue = __symbol__('value');
    var source = 'Promise.then';
    var UNRESOLVED = null;
    var RESOLVED = true;
    var REJECTED = false;
    var REJECTED_NO_CATCH = 0;
    function makeResolver(promise, state) {
      return function(v) {
        try {
          resolvePromise(promise, state, v);
        } catch (err) {
          resolvePromise(promise, false, err);
        }
      };
    }
    var once = function() {
      var wasCalled = false;
      return function wrapper(wrappedFunction) {
        return function() {
          if (wasCalled) {
            return;
          }
          wasCalled = true;
          wrappedFunction.apply(null, arguments);
        };
      };
    };
    function resolvePromise(promise, state, value) {
      var onceWrapper = once();
      if (promise === value) {
        throw new TypeError('Promise resolved with itself');
      }
      if (promise[symbolState] === UNRESOLVED) {
        var then = null;
        try {
          if (typeof value === 'object' || typeof value === 'function') {
            then = value && value.then;
          }
        } catch (err) {
          onceWrapper(function() {
            resolvePromise(promise, false, err);
          })();
          return promise;
        }
        if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {
          clearRejectedNoCatch(value);
          resolvePromise(promise, value[symbolState], value[symbolValue]);
        } else if (state !== REJECTED && typeof then === 'function') {
          try {
            then.apply(value, [onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false))]);
          } catch (err) {
            onceWrapper(function() {
              resolvePromise(promise, false, err);
            })();
          }
        } else {
          promise[symbolState] = state;
          var queue = promise[symbolValue];
          promise[symbolValue] = value;
          if (state === REJECTED && value instanceof Error) {
            value[__symbol__('currentTask')] = Zone.currentTask;
          }
          for (var i = 0; i < queue.length; ) {
            scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
          }
          if (queue.length == 0 && state == REJECTED) {
            promise[symbolState] = REJECTED_NO_CATCH;
            try {
              throw new Error('Uncaught (in promise): ' + value + (value && value.stack ? '\n' + value.stack : ''));
            } catch (err) {
              var error_1 = err;
              error_1.rejection = value;
              error_1.promise = promise;
              error_1.zone = Zone.current;
              error_1.task = Zone.currentTask;
              _uncaughtPromiseErrors.push(error_1);
              api.scheduleMicroTask();
            }
          }
        }
      }
      return promise;
    }
    function clearRejectedNoCatch(promise) {
      if (promise[symbolState] === REJECTED_NO_CATCH) {
        try {
          var handler = Zone[__symbol__('rejectionHandledHandler')];
          if (handler && typeof handler === 'function') {
            handler.apply(this, [{
              rejection: promise[symbolValue],
              promise: promise
            }]);
          }
        } catch (err) {}
        promise[symbolState] = REJECTED;
        for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {
          if (promise === _uncaughtPromiseErrors[i].promise) {
            _uncaughtPromiseErrors.splice(i, 1);
          }
        }
      }
    }
    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
      clearRejectedNoCatch(promise);
      var delegate = promise[symbolState] ? (typeof onFulfilled === 'function') ? onFulfilled : forwardResolution : (typeof onRejected === 'function') ? onRejected : forwardRejection;
      zone.scheduleMicroTask(source, function() {
        try {
          resolvePromise(chainPromise, true, zone.run(delegate, undefined, [promise[symbolValue]]));
        } catch (error) {
          resolvePromise(chainPromise, false, error);
        }
      });
    }
    var ZoneAwarePromise = (function() {
      function ZoneAwarePromise(executor) {
        var promise = this;
        if (!(promise instanceof ZoneAwarePromise)) {
          throw new Error('Must be an instanceof Promise.');
        }
        promise[symbolState] = UNRESOLVED;
        promise[symbolValue] = [];
        try {
          executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));
        } catch (error) {
          resolvePromise(promise, false, error);
        }
      }
      ZoneAwarePromise.toString = function() {
        return 'function ZoneAwarePromise() { [native code] }';
      };
      ZoneAwarePromise.resolve = function(value) {
        return resolvePromise(new this(null), RESOLVED, value);
      };
      ZoneAwarePromise.reject = function(error) {
        return resolvePromise(new this(null), REJECTED, error);
      };
      ZoneAwarePromise.race = function(values) {
        var resolve;
        var reject;
        var promise = new this(function(res, rej) {
          _a = [res, rej], resolve = _a[0], reject = _a[1];
          var _a;
        });
        function onResolve(value) {
          promise && (promise = null || resolve(value));
        }
        function onReject(error) {
          promise && (promise = null || reject(error));
        }
        for (var _i = 0,
            values_1 = values; _i < values_1.length; _i++) {
          var value = values_1[_i];
          if (!isThenable(value)) {
            value = this.resolve(value);
          }
          value.then(onResolve, onReject);
        }
        return promise;
      };
      ZoneAwarePromise.all = function(values) {
        var resolve;
        var reject;
        var promise = new this(function(res, rej) {
          resolve = res;
          reject = rej;
        });
        var count = 0;
        var resolvedValues = [];
        for (var _i = 0,
            values_2 = values; _i < values_2.length; _i++) {
          var value = values_2[_i];
          if (!isThenable(value)) {
            value = this.resolve(value);
          }
          value.then((function(index) {
            return function(value) {
              resolvedValues[index] = value;
              count--;
              if (!count) {
                resolve(resolvedValues);
              }
            };
          })(count), reject);
          count++;
        }
        if (!count)
          resolve(resolvedValues);
        return promise;
      };
      ZoneAwarePromise.prototype.then = function(onFulfilled, onRejected) {
        var chainPromise = new this.constructor(null);
        var zone = Zone.current;
        if (this[symbolState] == UNRESOLVED) {
          this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
        } else {
          scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
        }
        return chainPromise;
      };
      ZoneAwarePromise.prototype.catch = function(onRejected) {
        return this.then(null, onRejected);
      };
      return ZoneAwarePromise;
    }());
    ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;
    ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;
    ZoneAwarePromise['race'] = ZoneAwarePromise.race;
    ZoneAwarePromise['all'] = ZoneAwarePromise.all;
    var NativePromise = global[symbolPromise] = global['Promise'];
    global['Promise'] = ZoneAwarePromise;
    var symbolThenPatched = __symbol__('thenPatched');
    function patchThen(Ctor) {
      var proto = Ctor.prototype;
      var originalThen = proto.then;
      proto[symbolThen] = originalThen;
      var prop = Object.getOwnPropertyDescriptor(Ctor.prototype, 'then');
      if (prop && prop.writable === false && prop.configurable) {
        Object.defineProperty(Ctor.prototype, 'then', {writable: true});
      }
      Ctor.prototype.then = function(onResolve, onReject) {
        var _this = this;
        var wrapped = new ZoneAwarePromise(function(resolve, reject) {
          originalThen.call(_this, resolve, reject);
        });
        return wrapped.then(onResolve, onReject);
      };
      Ctor[symbolThenPatched] = true;
    }
    function zoneify(fn) {
      return function() {
        var resultPromise = fn.apply(this, arguments);
        if (resultPromise instanceof ZoneAwarePromise) {
          return resultPromise;
        }
        var ctor = resultPromise.constructor;
        if (!ctor[symbolThenPatched]) {
          patchThen(ctor);
        }
        return resultPromise;
      };
    }
    if (NativePromise) {
      patchThen(NativePromise);
      var fetch_1 = global['fetch'];
      if (typeof fetch_1 == 'function') {
        global['fetch'] = zoneify(fetch_1);
      }
    }
    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;
    return ZoneAwarePromise;
  });
  var zoneSymbol = Zone.__symbol__;
  var _global = typeof window === 'object' && window || typeof self === 'object' && self || global;
  function bindArguments(args, source) {
    for (var i = args.length - 1; i >= 0; i--) {
      if (typeof args[i] === 'function') {
        args[i] = Zone.current.wrap(args[i], source + '_' + i);
      }
    }
    return args;
  }
  function patchPrototype(prototype, fnNames) {
    var source = prototype.constructor['name'];
    var _loop_1 = function(i) {
      var name_1 = fnNames[i];
      var delegate = prototype[name_1];
      if (delegate) {
        prototype[name_1] = (function(delegate) {
          var patched = function() {
            return delegate.apply(this, bindArguments(arguments, source + '.' + name_1));
          };
          attachOriginToPatched(patched, delegate);
          return patched;
        })(delegate);
      }
    };
    for (var i = 0; i < fnNames.length; i++) {
      _loop_1(i);
    }
  }
  var isWebWorker = (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope);
  var isNode = (!('nw' in _global) && typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]');
  var isBrowser = !isNode && !isWebWorker && !!(typeof window !== 'undefined' && window['HTMLElement']);
  var isMix = typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]' && !isWebWorker && !!(typeof window !== 'undefined' && window['HTMLElement']);
  function patchProperty(obj, prop, prototype) {
    var desc = Object.getOwnPropertyDescriptor(obj, prop);
    if (!desc && prototype) {
      var prototypeDesc = Object.getOwnPropertyDescriptor(prototype, prop);
      if (prototypeDesc) {
        desc = {
          enumerable: true,
          configurable: true
        };
      }
    }
    if (!desc || !desc.configurable) {
      return;
    }
    delete desc.writable;
    delete desc.value;
    var originalDescGet = desc.get;
    var eventName = prop.substr(2);
    var _prop = zoneSymbol('_' + prop);
    desc.set = function(newValue) {
      var target = this;
      if (!target && obj === _global) {
        target = _global;
      }
      if (!target) {
        return;
      }
      var previousValue = target[_prop];
      if (previousValue) {
        target.removeEventListener(eventName, previousValue);
      }
      if (typeof newValue === 'function') {
        var wrapFn = function(event) {
          var result = newValue.apply(this, arguments);
          if (result != undefined && !result) {
            event.preventDefault();
          }
          return result;
        };
        target[_prop] = wrapFn;
        target.addEventListener(eventName, wrapFn, false);
      } else {
        target[_prop] = null;
      }
    };
    desc.get = function() {
      var target = this;
      if (!target && obj === _global) {
        target = _global;
      }
      if (!target) {
        return null;
      }
      if (target.hasOwnProperty(_prop)) {
        return target[_prop];
      } else if (originalDescGet) {
        var value = originalDescGet && originalDescGet.apply(this);
        if (value) {
          desc.set.apply(this, [value]);
          if (typeof target['removeAttribute'] === 'function') {
            target.removeAttribute(prop);
          }
          return value;
        }
      }
      return null;
    };
    Object.defineProperty(obj, prop, desc);
  }
  function patchOnProperties(obj, properties, prototype) {
    if (properties) {
      for (var i = 0; i < properties.length; i++) {
        patchProperty(obj, 'on' + properties[i], prototype);
      }
    } else {
      var onProperties = [];
      for (var prop in obj) {
        if (prop.substr(0, 2) == 'on') {
          onProperties.push(prop);
        }
      }
      for (var j = 0; j < onProperties.length; j++) {
        patchProperty(obj, onProperties[j], prototype);
      }
    }
  }
  var originalInstanceKey = zoneSymbol('originalInstance');
  function patchClass(className) {
    var OriginalClass = _global[className];
    if (!OriginalClass)
      return;
    _global[zoneSymbol(className)] = OriginalClass;
    _global[className] = function() {
      var a = bindArguments(arguments, className);
      switch (a.length) {
        case 0:
          this[originalInstanceKey] = new OriginalClass();
          break;
        case 1:
          this[originalInstanceKey] = new OriginalClass(a[0]);
          break;
        case 2:
          this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
          break;
        case 3:
          this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
          break;
        case 4:
          this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
          break;
        default:
          throw new Error('Arg list too long.');
      }
    };
    attachOriginToPatched(_global[className], OriginalClass);
    var instance = new OriginalClass(function() {});
    var prop;
    for (prop in instance) {
      if (className === 'XMLHttpRequest' && prop === 'responseBlob')
        continue;
      (function(prop) {
        if (typeof instance[prop] === 'function') {
          _global[className].prototype[prop] = function() {
            return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);
          };
        } else {
          Object.defineProperty(_global[className].prototype, prop, {
            set: function(fn) {
              if (typeof fn === 'function') {
                this[originalInstanceKey][prop] = Zone.current.wrap(fn, className + '.' + prop);
                attachOriginToPatched(this[originalInstanceKey][prop], fn);
              } else {
                this[originalInstanceKey][prop] = fn;
              }
            },
            get: function() {
              return this[originalInstanceKey][prop];
            }
          });
        }
      }(prop));
    }
    for (prop in OriginalClass) {
      if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {
        _global[className][prop] = OriginalClass[prop];
      }
    }
  }
  function patchMethod(target, name, patchFn) {
    var proto = target;
    while (proto && !proto.hasOwnProperty(name)) {
      proto = Object.getPrototypeOf(proto);
    }
    if (!proto && target[name]) {
      proto = target;
    }
    var delegateName = zoneSymbol(name);
    var delegate;
    if (proto && !(delegate = proto[delegateName])) {
      delegate = proto[delegateName] = proto[name];
      var patchDelegate_1 = patchFn(delegate, delegateName, name);
      proto[name] = function() {
        return patchDelegate_1(this, arguments);
      };
      attachOriginToPatched(proto[name], delegate);
    }
    return delegate;
  }
  function patchMacroTask(obj, funcName, metaCreator) {
    var setNative = null;
    function scheduleTask(task) {
      var data = task.data;
      data.args[data.callbackIndex] = function() {
        task.invoke.apply(this, arguments);
      };
      setNative.apply(data.target, data.args);
      return task;
    }
    setNative = patchMethod(obj, funcName, function(delegate) {
      return function(self, args) {
        var meta = metaCreator(self, args);
        if (meta.callbackIndex >= 0 && typeof args[meta.callbackIndex] === 'function') {
          var task = Zone.current.scheduleMacroTask(meta.name, args[meta.callbackIndex], meta, scheduleTask, null);
          return task;
        } else {
          return delegate.apply(self, args);
        }
      };
    });
  }
  function attachOriginToPatched(patched, original) {
    patched[zoneSymbol('OriginalDelegate')] = original;
  }
  var isDetectedIEOrEdge = false;
  var ieOrEdge = false;
  function isIEOrEdge() {
    if (isDetectedIEOrEdge) {
      return ieOrEdge;
    }
    isDetectedIEOrEdge = true;
    try {
      var ua = window.navigator.userAgent;
      var msie = ua.indexOf('MSIE ');
      if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {
        ieOrEdge = true;
      }
      return ieOrEdge;
    } catch (error) {}
  }
  Zone.__load_patch('toString', function(global, Zone, api) {
    var originalFunctionToString = Zone['__zone_symbol__originalToString'] = Function.prototype.toString;
    Function.prototype.toString = function() {
      if (typeof this === 'function') {
        var originalDelegate = this[zoneSymbol('OriginalDelegate')];
        if (originalDelegate) {
          if (typeof originalDelegate === 'function') {
            return originalFunctionToString.apply(this[zoneSymbol('OriginalDelegate')], arguments);
          } else {
            return Object.prototype.toString.call(originalDelegate);
          }
        }
        if (this === Promise) {
          var nativePromise = global[zoneSymbol('Promise')];
          if (nativePromise) {
            return originalFunctionToString.apply(nativePromise, arguments);
          }
        }
        if (this === Error) {
          var nativeError = global[zoneSymbol('Error')];
          if (nativeError) {
            return originalFunctionToString.apply(nativeError, arguments);
          }
        }
      }
      return originalFunctionToString.apply(this, arguments);
    };
    var originalObjectToString = Object.prototype.toString;
    Object.prototype.toString = function() {
      if (this instanceof Promise) {
        return '[object Promise]';
      }
      return originalObjectToString.apply(this, arguments);
    };
  });
  var TRUE_STR = 'true';
  var FALSE_STR = 'false';
  var OPTIMIZED_ZONE_EVENT_TASK_DATA = {isUsingGlobalCallback: true};
  var zoneSymbolEventNames = {};
  var globalSources = {};
  var CONSTRUCTOR_NAME = 'name';
  var FUNCTION_TYPE = 'function';
  var OBJECT_TYPE = 'object';
  var ZONE_SYMBOL_PREFIX = '__zone_symbol__';
  var EVENT_NAME_SYMBOL_REGX = /^__zone_symbol__(\w+)(true|false)$/;
  function patchEventTarget(_global, apis, patchOptions) {
    var ADD_EVENT_LISTENER = (patchOptions && patchOptions.addEventListenerFnName) || 'addEventListener';
    var REMOVE_EVENT_LISTENER = (patchOptions && patchOptions.removeEventListenerFnName) || 'removeEventListener';
    var LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.listenersFnName) || 'eventListeners';
    var REMOVE_ALL_LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.removeAllFnName) || 'removeAllListeners';
    var zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
    var ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';
    var PREPEND_EVENT_LISTENER = 'prependListener';
    var PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';
    var invokeTask = function(task, target, event) {
      if (task.isRemoved) {
        return;
      }
      var delegate = task.callback;
      if (typeof delegate === OBJECT_TYPE && delegate.handleEvent) {
        task.callback = function(event) {
          return delegate.handleEvent(event);
        };
        task.originalDelegate = delegate;
      }
      task.invoke(task, target, [event]);
      var options = task.options;
      if (options && typeof options === 'object' && options.once) {
        var delegate_1 = task.originalDelegate ? task.originalDelegate : task.callback;
        target[REMOVE_EVENT_LISTENER].apply(target, [event.type, delegate_1, options]);
      }
    };
    var globalZoneAwareCallback = function(event) {
      var target = this || _global;
      var tasks = target[zoneSymbolEventNames[event.type][FALSE_STR]];
      if (tasks) {
        if (tasks.length === 1) {
          invokeTask(tasks[0], target, event);
        } else {
          var copyTasks = tasks.slice();
          for (var i = 0; i < copyTasks.length; i++) {
            invokeTask(copyTasks[i], target, event);
          }
        }
      }
    };
    var globalZoneAwareCaptureCallback = function(event) {
      var target = this || _global;
      var tasks = target[zoneSymbolEventNames[event.type][TRUE_STR]];
      if (tasks) {
        if (tasks.length === 1) {
          invokeTask(tasks[0], target, event);
        } else {
          var copyTasks = tasks.slice();
          for (var i = 0; i < copyTasks.length; i++) {
            invokeTask(copyTasks[i], target, event);
          }
        }
      }
    };
    function patchEventTargetMethods(obj, patchOptions) {
      if (!obj) {
        return false;
      }
      var useGlobalCallback = true;
      if (patchOptions && patchOptions.useGlobalCallback !== undefined) {
        useGlobalCallback = patchOptions.useGlobalCallback;
      }
      var validateHandler = patchOptions && patchOptions.validateHandler;
      var checkDuplicate = true;
      if (patchOptions && patchOptions.checkDuplicate !== undefined) {
        checkDuplicate = patchOptions.checkDuplicate;
      }
      var returnTarget = false;
      if (patchOptions && patchOptions.returnTarget !== undefined) {
        returnTarget = patchOptions.returnTarget;
      }
      var proto = obj;
      while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
        proto = Object.getPrototypeOf(proto);
      }
      if (!proto && obj[ADD_EVENT_LISTENER]) {
        proto = obj;
      }
      if (!proto) {
        return false;
      }
      if (proto[zoneSymbolAddEventListener]) {
        return false;
      }
      var taskData = {};
      var nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
      var nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];
      var nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];
      var nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
      var nativePrependEventListener;
      if (patchOptions && patchOptions.prependEventListenerFnName) {
        nativePrependEventListener = proto[zoneSymbol(patchOptions.prependEventListenerFnName)] = proto[patchOptions.prependEventListenerFnName];
      }
      var customScheduleGlobal = function(task) {
        if (taskData.isExisting) {
          return;
        }
        return nativeAddEventListener.apply(taskData.target, [taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options]);
      };
      var customCancelGlobal = function(task) {
        if (!task.isRemoved) {
          var symbolEventNames = zoneSymbolEventNames[task.eventName];
          var symbolEventName = void 0;
          if (symbolEventNames) {
            symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
          }
          var existingTasks = symbolEventName && task.target[symbolEventName];
          if (existingTasks) {
            for (var i = 0; i < existingTasks.length; i++) {
              var existingTask = existingTasks[i];
              if (existingTask === task) {
                existingTasks.splice(i, 1);
                task.isRemoved = true;
                if (existingTasks.length === 0) {
                  task.allRemoved = true;
                  task.target[symbolEventName] = null;
                }
                break;
              }
            }
          }
        }
        if (!task.allRemoved) {
          return;
        }
        return nativeRemoveEventListener.apply(task.target, [task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options]);
      };
      var customScheduleNonGlobal = function(task) {
        return nativeAddEventListener.apply(taskData.target, [taskData.eventName, task.invoke, taskData.options]);
      };
      var customSchedulePrepend = function(task) {
        return nativePrependEventListener.apply(taskData.target, [taskData.eventName, task.invoke, taskData.options]);
      };
      var customCancelNonGlobal = function(task) {
        return nativeRemoveEventListener.apply(task.target, [task.eventName, task.invoke, task.options]);
      };
      var customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
      var customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
      var compareTaskCallbackVsDelegate = function(task, delegate) {
        var typeOfDelegate = typeof delegate;
        if ((typeOfDelegate === FUNCTION_TYPE && task.callback === delegate) || (typeOfDelegate === OBJECT_TYPE && task.originalDelegate === delegate)) {
          return true;
        }
        return false;
      };
      var compare = (patchOptions && patchOptions.compareTaskCallbackVsDelegate) ? patchOptions.compareTaskCallbackVsDelegate : compareTaskCallbackVsDelegate;
      var makeAddListener = function(nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget, prepend) {
        if (returnTarget === void 0) {
          returnTarget = false;
        }
        if (prepend === void 0) {
          prepend = false;
        }
        return function() {
          var target = this || _global;
          var targetZone = Zone.current;
          var delegate = arguments[1];
          if (!delegate) {
            return nativeListener.apply(this, arguments);
          }
          var isHandleEvent = false;
          if (typeof delegate !== FUNCTION_TYPE) {
            if (!delegate.handleEvent) {
              return nativeListener.apply(this, arguments);
            }
            isHandleEvent = true;
          }
          if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
            return;
          }
          var eventName = arguments[0];
          var options = arguments[2];
          var capture;
          var once = false;
          if (options === undefined) {
            capture = false;
          } else if (options === true) {
            capture = true;
          } else if (options === false) {
            capture = false;
          } else {
            capture = options ? !!options.capture : false;
            once = options ? !!options.once : false;
          }
          var zone = Zone.current;
          var symbolEventNames = zoneSymbolEventNames[eventName];
          var symbolEventName;
          if (!symbolEventNames) {
            var falseEventName = eventName + FALSE_STR;
            var trueEventName = eventName + TRUE_STR;
            var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
            var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
            zoneSymbolEventNames[eventName] = {};
            zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
            zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
            symbolEventName = capture ? symbolCapture : symbol;
          } else {
            symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
          }
          var existingTasks = target[symbolEventName];
          var isExisting = false;
          if (existingTasks) {
            isExisting = true;
            if (checkDuplicate) {
              for (var i = 0; i < existingTasks.length; i++) {
                if (compare(existingTasks[i], delegate)) {
                  return;
                }
              }
            }
          } else {
            existingTasks = target[symbolEventName] = [];
          }
          var source;
          var constructorName = target.constructor[CONSTRUCTOR_NAME];
          var targetSource = globalSources[constructorName];
          if (targetSource) {
            source = targetSource[eventName];
          }
          if (!source) {
            source = constructorName + addSource + eventName;
          }
          taskData.options = options;
          if (once) {
            taskData.options.once = false;
          }
          taskData.target = target;
          taskData.capture = capture;
          taskData.eventName = eventName;
          taskData.isExisting = isExisting;
          var data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : null;
          var task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
          if (once) {
            options.once = true;
          }
          task.options = options;
          task.target = target;
          task.capture = capture;
          task.eventName = eventName;
          if (isHandleEvent) {
            task.originalDelegate = delegate;
          }
          if (!prepend) {
            existingTasks.push(task);
          } else {
            existingTasks.unshift(task);
          }
          if (returnTarget) {
            return target;
          }
        };
      };
      proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
      if (nativePrependEventListener) {
        proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
      }
      proto[REMOVE_EVENT_LISTENER] = function() {
        var target = this || _global;
        var eventName = arguments[0];
        var options = arguments[2];
        var capture;
        if (options === undefined) {
          capture = false;
        } else if (options === true) {
          capture = true;
        } else if (options === false) {
          capture = false;
        } else {
          capture = options ? !!options.capture : false;
        }
        var delegate = arguments[1];
        if (!delegate) {
          return nativeRemoveEventListener.apply(this, arguments);
        }
        if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
          return;
        }
        var symbolEventNames = zoneSymbolEventNames[eventName];
        var symbolEventName;
        if (symbolEventNames) {
          symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
        }
        var existingTasks = symbolEventName && target[symbolEventName];
        if (existingTasks) {
          for (var i = 0; i < existingTasks.length; i++) {
            var existingTask = existingTasks[i];
            var typeOfDelegate = typeof delegate;
            if (compare(existingTask, delegate)) {
              existingTasks.splice(i, 1);
              existingTask.isRemoved = true;
              if (existingTasks.length === 0) {
                existingTask.allRemoved = true;
                target[symbolEventName] = null;
              }
              existingTask.zone.cancelTask(existingTask);
              return;
            }
          }
        }
      };
      proto[LISTENERS_EVENT_LISTENER] = function() {
        var target = this || _global;
        var eventName = arguments[0];
        var listeners = [];
        var tasks = findEventTasks(target, eventName);
        for (var i = 0; i < tasks.length; i++) {
          var task = tasks[i];
          var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
          listeners.push(delegate);
        }
        return listeners;
      };
      proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function() {
        var target = this || _global;
        var eventName = arguments[0];
        if (!eventName) {
          var keys = Object.keys(target);
          for (var i = 0; i < keys.length; i++) {
            var prop = keys[i];
            var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
            var evtName = match && match[1];
            if (evtName && evtName !== 'removeListener') {
              this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].apply(this, [evtName]);
            }
          }
          this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].apply(this, ['removeListener']);
        } else {
          var symbolEventNames = zoneSymbolEventNames[eventName];
          if (symbolEventNames) {
            var symbolEventName = symbolEventNames[FALSE_STR];
            var symbolCaptureEventName = symbolEventNames[TRUE_STR];
            var tasks = target[symbolEventName];
            var captureTasks = target[symbolCaptureEventName];
            if (tasks) {
              var removeTasks = tasks.slice();
              for (var i = 0; i < removeTasks.length; i++) {
                var task = removeTasks[i];
                var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                this[REMOVE_EVENT_LISTENER].apply(this, [eventName, delegate, task.options]);
              }
            }
            if (captureTasks) {
              var removeTasks = captureTasks.slice();
              for (var i = 0; i < removeTasks.length; i++) {
                var task = removeTasks[i];
                var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                this[REMOVE_EVENT_LISTENER].apply(this, [eventName, delegate, task.options]);
              }
            }
          }
        }
      };
      attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
      attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
      if (nativeRemoveAllListeners) {
        attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
      }
      if (nativeListeners) {
        attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
      }
      return true;
    }
    var results = [];
    for (var i = 0; i < apis.length; i++) {
      results[i] = patchEventTargetMethods(apis[i], patchOptions);
    }
    return results;
  }
  function findEventTasks(target, eventName) {
    var foundTasks = [];
    for (var prop in target) {
      var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
      var evtName = match && match[1];
      if (evtName && (!eventName || evtName === eventName)) {
        var tasks = target[prop];
        if (tasks) {
          for (var i = 0; i < tasks.length; i++) {
            foundTasks.push(tasks[i]);
          }
        }
      }
    }
    return foundTasks;
  }
  function patchTimer(window, setName, cancelName, nameSuffix) {
    var setNative = null;
    var clearNative = null;
    setName += nameSuffix;
    cancelName += nameSuffix;
    var tasksByHandleId = {};
    function scheduleTask(task) {
      var data = task.data;
      function timer() {
        try {
          task.invoke.apply(this, arguments);
        } finally {
          if (typeof data.handleId === 'number') {
            delete tasksByHandleId[data.handleId];
          }
        }
      }
      data.args[0] = timer;
      data.handleId = setNative.apply(window, data.args);
      if (typeof data.handleId === 'number') {
        tasksByHandleId[data.handleId] = task;
      }
      return task;
    }
    function clearTask(task) {
      if (typeof task.data.handleId === 'number') {
        delete tasksByHandleId[task.data.handleId];
      }
      return clearNative(task.data.handleId);
    }
    setNative = patchMethod(window, setName, function(delegate) {
      return function(self, args) {
        if (typeof args[0] === 'function') {
          var zone = Zone.current;
          var options = {
            handleId: null,
            isPeriodic: nameSuffix === 'Interval',
            delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 : null,
            args: args
          };
          var task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);
          if (!task) {
            return task;
          }
          var handle = task.data.handleId;
          if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' && typeof handle.unref === 'function') {
            task.ref = handle.ref.bind(handle);
            task.unref = handle.unref.bind(handle);
          }
          return task;
        } else {
          return delegate.apply(window, args);
        }
      };
    });
    clearNative = patchMethod(window, cancelName, function(delegate) {
      return function(self, args) {
        var task = typeof args[0] === 'number' ? tasksByHandleId[args[0]] : args[0];
        if (task && typeof task.type === 'string') {
          if (task.state !== 'notScheduled' && (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {
            task.zone.cancelTask(task);
          }
        } else {
          delegate.apply(window, args);
        }
      };
    });
  }
  var _defineProperty = Object[zoneSymbol('defineProperty')] = Object.defineProperty;
  var _getOwnPropertyDescriptor = Object[zoneSymbol('getOwnPropertyDescriptor')] = Object.getOwnPropertyDescriptor;
  var _create = Object.create;
  var unconfigurablesKey = zoneSymbol('unconfigurables');
  function propertyPatch() {
    Object.defineProperty = function(obj, prop, desc) {
      if (isUnconfigurable(obj, prop)) {
        throw new TypeError('Cannot assign to read only property \'' + prop + '\' of ' + obj);
      }
      var originalConfigurableFlag = desc.configurable;
      if (prop !== 'prototype') {
        desc = rewriteDescriptor(obj, prop, desc);
      }
      return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
    };
    Object.defineProperties = function(obj, props) {
      Object.keys(props).forEach(function(prop) {
        Object.defineProperty(obj, prop, props[prop]);
      });
      return obj;
    };
    Object.create = function(obj, proto) {
      if (typeof proto === 'object' && !Object.isFrozen(proto)) {
        Object.keys(proto).forEach(function(prop) {
          proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);
        });
      }
      return _create(obj, proto);
    };
    Object.getOwnPropertyDescriptor = function(obj, prop) {
      var desc = _getOwnPropertyDescriptor(obj, prop);
      if (isUnconfigurable(obj, prop)) {
        desc.configurable = false;
      }
      return desc;
    };
  }
  function _redefineProperty(obj, prop, desc) {
    var originalConfigurableFlag = desc.configurable;
    desc = rewriteDescriptor(obj, prop, desc);
    return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
  }
  function isUnconfigurable(obj, prop) {
    return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];
  }
  function rewriteDescriptor(obj, prop, desc) {
    desc.configurable = true;
    if (!desc.configurable) {
      if (!obj[unconfigurablesKey]) {
        _defineProperty(obj, unconfigurablesKey, {
          writable: true,
          value: {}
        });
      }
      obj[unconfigurablesKey][prop] = true;
    }
    return desc;
  }
  function _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {
    try {
      return _defineProperty(obj, prop, desc);
    } catch (error) {
      if (desc.configurable) {
        if (typeof originalConfigurableFlag == 'undefined') {
          delete desc.configurable;
        } else {
          desc.configurable = originalConfigurableFlag;
        }
        try {
          return _defineProperty(obj, prop, desc);
        } catch (error) {
          var descJson = null;
          try {
            descJson = JSON.stringify(desc);
          } catch (error) {
            descJson = descJson.toString();
          }
          console.log("Attempting to configure '" + prop + "' with descriptor '" + descJson + "' on object '" + obj + "' and got error, giving up: " + error);
        }
      } else {
        throw error;
      }
    }
  }
  function apply(api, _global) {
    var WS = _global.WebSocket;
    if (!_global.EventTarget) {
      patchEventTarget(api, _global, [WS.prototype]);
    }
    _global.WebSocket = function(a, b) {
      var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);
      var proxySocket;
      var proxySocketProto;
      var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');
      if (onmessageDesc && onmessageDesc.configurable === false) {
        proxySocket = Object.create(socket);
        proxySocketProto = socket;
        ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function(propName) {
          proxySocket[propName] = function() {
            return socket[propName].apply(socket, arguments);
          };
        });
      } else {
        proxySocket = socket;
      }
      patchOnProperties(proxySocket, ['close', 'error', 'message', 'open'], proxySocketProto);
      return proxySocket;
    };
    for (var prop in WS) {
      _global['WebSocket'][prop] = WS[prop];
    }
  }
  var globalEventHandlersEventNames = ['abort', 'animationcancel', 'animationend', 'animationiteration', 'auxclick', 'beforeinput', 'blur', 'cancel', 'canplay', 'canplaythrough', 'change', 'compositionstart', 'compositionupdate', 'compositionend', 'cuechange', 'click', 'close', 'contextmenu', 'curechange', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragexit', 'dragleave', 'dragover', 'drop', 'durationchange', 'emptied', 'ended', 'error', 'focus', 'focusin', 'focusout', 'gotpointercapture', 'input', 'invalid', 'keydown', 'keypress', 'keyup', 'load', 'loadstart', 'loadeddata', 'loadedmetadata', 'lostpointercapture', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'mousewheel', 'pause', 'play', 'playing', 'pointercancel', 'pointerdown', 'pointerenter', 'pointerleave', 'pointerlockchange', 'mozpointerlockchange', 'webkitpointerlockerchange', 'pointerlockerror', 'mozpointerlockerror', 'webkitpointerlockerror', 'pointermove', 'pointout', 'pointerover', 'pointerup', 'progress', 'ratechange', 'reset', 'resize', 'scroll', 'seeked', 'seeking', 'select', 'selectionchange', 'selectstart', 'show', 'sort', 'stalled', 'submit', 'suspend', 'timeupdate', 'volumechange', 'touchcancel', 'touchmove', 'touchstart', 'transitioncancel', 'transitionend', 'waiting', 'wheel'];
  var documentEventNames = ['afterscriptexecute', 'beforescriptexecute', 'DOMContentLoaded', 'fullscreenchange', 'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange', 'fullscreenerror', 'mozfullscreenerror', 'webkitfullscreenerror', 'msfullscreenerror', 'readystatechange'];
  var windowEventNames = ['absolutedeviceorientation', 'afterinput', 'afterprint', 'appinstalled', 'beforeinstallprompt', 'beforeprint', 'beforeunload', 'devicelight', 'devicemotion', 'deviceorientation', 'deviceorientationabsolute', 'deviceproximity', 'hashchange', 'languagechange', 'message', 'mozbeforepaint', 'offline', 'online', 'paint', 'pageshow', 'pagehide', 'popstate', 'rejectionhandled', 'storage', 'unhandledrejection', 'unload', 'userproximity', 'vrdisplyconnected', 'vrdisplaydisconnected', 'vrdisplaypresentchange'];
  var htmlElementEventNames = ['beforecopy', 'beforecut', 'beforepaste', 'copy', 'cut', 'paste', 'dragstart', 'loadend', 'animationstart', 'search', 'transitionrun', 'transitionstart', 'webkitanimationend', 'webkitanimationiteration', 'webkitanimationstart', 'webkittransitionend'];
  var mediaElementEventNames = ['encrypted', 'waitingforkey', 'msneedkey', 'mozinterruptbegin', 'mozinterruptend'];
  var ieElementEventNames = ['activate', 'afterupdate', 'ariarequest', 'beforeactivate', 'beforedeactivate', 'beforeeditfocus', 'beforeupdate', 'cellchange', 'controlselect', 'dataavailable', 'datasetchanged', 'datasetcomplete', 'errorupdate', 'filterchange', 'layoutcomplete', 'losecapture', 'move', 'moveend', 'movestart', 'propertychange', 'resizeend', 'resizestart', 'rowenter', 'rowexit', 'rowsdelete', 'rowsinserted', 'command', 'compassneedscalibration', 'deactivate', 'help', 'mscontentzoom', 'msmanipulationstatechanged', 'msgesturechange', 'msgesturedoubletap', 'msgestureend', 'msgesturehold', 'msgesturestart', 'msgesturetap', 'msgotpointercapture', 'msinertiastart', 'mslostpointercapture', 'mspointercancel', 'mspointerdown', 'mspointerenter', 'mspointerhover', 'mspointerleave', 'mspointermove', 'mspointerout', 'mspointerover', 'mspointerup', 'pointerout', 'mssitemodejumplistitemremoved', 'msthumbnailclick', 'stop', 'storagecommit'];
  var webglEventNames = ['webglcontextrestored', 'webglcontextlost', 'webglcontextcreationerror'];
  var formEventNames = ['autocomplete', 'autocompleteerror'];
  var detailEventNames = ['toggle'];
  var frameEventNames = ['load'];
  var frameSetEventNames = ['blur', 'error', 'focus', 'load', 'resize', 'scroll'];
  var marqueeEventNames = ['bounce', 'finish', 'start'];
  var XMLHttpRequestEventNames = ['loadstart', 'progress', 'abort', 'error', 'load', 'progress', 'timeout', 'loadend', 'readystatechange'];
  var IDBIndexEventNames = ['upgradeneeded', 'complete', 'abort', 'success', 'error', 'blocked', 'versionchange', 'close'];
  var websocketEventNames = ['close', 'error', 'open', 'message'];
  var eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);
  function propertyDescriptorPatch(api, _global) {
    if (isNode && !isMix) {
      return;
    }
    var supportsWebSocket = typeof WebSocket !== 'undefined';
    if (canPatchViaPropertyDescriptor()) {
      if (isBrowser) {
        patchOnProperties(window, eventNames, Object.getPrototypeOf(window));
        patchOnProperties(Document.prototype, eventNames);
        if (typeof window['SVGElement'] !== 'undefined') {
          patchOnProperties(window['SVGElement'].prototype, eventNames);
        }
        patchOnProperties(Element.prototype, eventNames);
        patchOnProperties(HTMLElement.prototype, eventNames);
        patchOnProperties(HTMLMediaElement.prototype, mediaElementEventNames);
        patchOnProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames));
        patchOnProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames));
        patchOnProperties(HTMLFrameElement.prototype, frameEventNames);
        patchOnProperties(HTMLIFrameElement.prototype, frameEventNames);
        var HTMLMarqueeElement_1 = window['HTMLMarqueeElement'];
        if (HTMLMarqueeElement_1) {
          patchOnProperties(HTMLMarqueeElement_1.prototype, marqueeEventNames);
        }
      }
      patchOnProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames);
      var XMLHttpRequestEventTarget = _global['XMLHttpRequestEventTarget'];
      if (XMLHttpRequestEventTarget) {
        patchOnProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames);
      }
      if (typeof IDBIndex !== 'undefined') {
        patchOnProperties(IDBIndex.prototype, IDBIndexEventNames);
        patchOnProperties(IDBRequest.prototype, IDBIndexEventNames);
        patchOnProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames);
        patchOnProperties(IDBDatabase.prototype, IDBIndexEventNames);
        patchOnProperties(IDBTransaction.prototype, IDBIndexEventNames);
        patchOnProperties(IDBCursor.prototype, IDBIndexEventNames);
      }
      if (supportsWebSocket) {
        patchOnProperties(WebSocket.prototype, websocketEventNames);
      }
    } else {
      patchViaCapturingAllTheEvents();
      patchClass('XMLHttpRequest');
      if (supportsWebSocket) {
        apply(api, _global);
      }
    }
  }
  function canPatchViaPropertyDescriptor() {
    if ((isBrowser || isMix) && !Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') && typeof Element !== 'undefined') {
      var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');
      if (desc && !desc.configurable)
        return false;
    }
    var xhrDesc = Object.getOwnPropertyDescriptor(XMLHttpRequest.prototype, 'onreadystatechange');
    if (xhrDesc) {
      Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {
        enumerable: true,
        configurable: true,
        get: function() {
          return true;
        }
      });
      var req = new XMLHttpRequest();
      var result = !!req.onreadystatechange;
      Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', xhrDesc || {});
      return result;
    } else {
      Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {
        enumerable: true,
        configurable: true,
        get: function() {
          return this[zoneSymbol('fakeonreadystatechange')];
        },
        set: function(value) {
          this[zoneSymbol('fakeonreadystatechange')] = value;
        }
      });
      var req = new XMLHttpRequest();
      var detectFunc = function() {};
      req.onreadystatechange = detectFunc;
      var result = req[zoneSymbol('fakeonreadystatechange')] === detectFunc;
      req.onreadystatechange = null;
      return result;
    }
  }
  var unboundKey = zoneSymbol('unbound');
  function patchViaCapturingAllTheEvents() {
    var _loop_1 = function(i) {
      var property = eventNames[i];
      var onproperty = 'on' + property;
      self.addEventListener(property, function(event) {
        var elt = event.target,
            bound,
            source;
        if (elt) {
          source = elt.constructor['name'] + '.' + onproperty;
        } else {
          source = 'unknown.' + onproperty;
        }
        while (elt) {
          if (elt[onproperty] && !elt[onproperty][unboundKey]) {
            bound = Zone.current.wrap(elt[onproperty], source);
            bound[unboundKey] = elt[onproperty];
            elt[onproperty] = bound;
          }
          elt = elt.parentElement;
        }
      }, true);
    };
    for (var i = 0; i < eventNames.length; i++) {
      _loop_1(i);
    }
  }
  function eventTargetPatch(_global, api) {
    var WTF_ISSUE_555 = 'Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video';
    var NO_EVENT_TARGET = 'ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket'.split(',');
    var EVENT_TARGET = 'EventTarget';
    var apis = [];
    var isWtf = _global['wtf'];
    var WTF_ISSUE_555_ARRAY = WTF_ISSUE_555.split(',');
    if (isWtf) {
      apis = WTF_ISSUE_555_ARRAY.map(function(v) {
        return 'HTML' + v + 'Element';
      }).concat(NO_EVENT_TARGET);
    } else if (_global[EVENT_TARGET]) {
      apis.push(EVENT_TARGET);
    } else {
      apis = NO_EVENT_TARGET;
    }
    var isDisableIECheck = _global['__Zone_disable_IE_check'] || false;
    var isEnableCrossContextCheck = _global['__Zone_enable_cross_context_check'] || false;
    var ieOrEdge = isIEOrEdge();
    var ADD_EVENT_LISTENER_SOURCE = '.addEventListener:';
    var FUNCTION_WRAPPER = '[object FunctionWrapper]';
    var BROWSER_TOOLS = 'function __BROWSERTOOLS_CONSOLE_SAFEFUNC() { [native code] }';
    for (var i = 0; i < eventNames.length; i++) {
      var eventName = eventNames[i];
      var falseEventName = eventName + FALSE_STR;
      var trueEventName = eventName + TRUE_STR;
      var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
      var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
      zoneSymbolEventNames[eventName] = {};
      zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
      zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
    }
    for (var i = 0; i < WTF_ISSUE_555.length; i++) {
      var target = WTF_ISSUE_555_ARRAY[i];
      var targets = globalSources[target] = {};
      for (var j = 0; j < eventNames.length; j++) {
        var eventName = eventNames[j];
        targets[eventName] = target + ADD_EVENT_LISTENER_SOURCE + eventName;
      }
    }
    var checkIEAndCrossContext = function(nativeDelegate, delegate, target, args) {
      if (!isDisableIECheck && ieOrEdge) {
        if (isEnableCrossContextCheck) {
          try {
            var testString = delegate.toString();
            if ((testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS)) {
              nativeDelegate.apply(target, args);
              return false;
            }
          } catch (error) {
            nativeDelegate.apply(target, args);
            return false;
          }
        } else {
          var testString = delegate.toString();
          if ((testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS)) {
            nativeDelegate.apply(target, args);
            return false;
          }
        }
      } else if (isEnableCrossContextCheck) {
        try {
          delegate.toString();
        } catch (error) {
          nativeDelegate.apply(target, args);
          return false;
        }
      }
      return true;
    };
    var apiTypes = [];
    for (var i = 0; i < apis.length; i++) {
      var type = _global[apis[i]];
      apiTypes.push(type && type.prototype);
    }
    patchEventTarget(_global, apiTypes, {validateHandler: checkIEAndCrossContext});
    api.patchEventTarget = patchEventTarget;
    return true;
  }
  function registerElementPatch(_global) {
    if ((!isBrowser && !isMix) || !('registerElement' in _global.document)) {
      return;
    }
    var _registerElement = document.registerElement;
    var callbacks = ['createdCallback', 'attachedCallback', 'detachedCallback', 'attributeChangedCallback'];
    document.registerElement = function(name, opts) {
      if (opts && opts.prototype) {
        callbacks.forEach(function(callback) {
          var source = 'Document.registerElement::' + callback;
          if (opts.prototype.hasOwnProperty(callback)) {
            var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);
            if (descriptor && descriptor.value) {
              descriptor.value = Zone.current.wrap(descriptor.value, source);
              _redefineProperty(opts.prototype, callback, descriptor);
            } else {
              opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);
            }
          } else if (opts.prototype[callback]) {
            opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);
          }
        });
      }
      return _registerElement.apply(document, [name, opts]);
    };
    attachOriginToPatched(document.registerElement, _registerElement);
  }
  Zone.__load_patch('timers', function(global, Zone, api) {
    var set = 'set';
    var clear = 'clear';
    patchTimer(global, set, clear, 'Timeout');
    patchTimer(global, set, clear, 'Interval');
    patchTimer(global, set, clear, 'Immediate');
    patchTimer(global, 'request', 'cancel', 'AnimationFrame');
    patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');
    patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');
  });
  Zone.__load_patch('blocking', function(global, Zone, api) {
    var blockingMethods = ['alert', 'prompt', 'confirm'];
    for (var i = 0; i < blockingMethods.length; i++) {
      var name_1 = blockingMethods[i];
      patchMethod(global, name_1, function(delegate, symbol, name) {
        return function(s, args) {
          return Zone.current.run(delegate, global, args, name);
        };
      });
    }
  });
  Zone.__load_patch('EventTarget', function(global, Zone, api) {
    eventTargetPatch(global, api);
    var XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];
    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
      api.patchEventTarget(global, [XMLHttpRequestEventTarget.prototype]);
    }
    patchClass('MutationObserver');
    patchClass('WebKitMutationObserver');
    patchClass('FileReader');
  });
  Zone.__load_patch('on_property', function(global, Zone, api) {
    propertyDescriptorPatch(api, global);
    propertyPatch();
    registerElementPatch(global);
  });
  Zone.__load_patch('canvas', function(global, Zone, api) {
    var HTMLCanvasElement = global['HTMLCanvasElement'];
    if (typeof HTMLCanvasElement !== 'undefined' && HTMLCanvasElement.prototype && HTMLCanvasElement.prototype.toBlob) {
      patchMacroTask(HTMLCanvasElement.prototype, 'toBlob', function(self, args) {
        return {
          name: 'HTMLCanvasElement.toBlob',
          target: self,
          callbackIndex: 0,
          args: args
        };
      });
    }
  });
  Zone.__load_patch('XHR', function(global, Zone, api) {
    patchXHR(global);
    var XHR_TASK = zoneSymbol('xhrTask');
    var XHR_SYNC = zoneSymbol('xhrSync');
    var XHR_LISTENER = zoneSymbol('xhrListener');
    var XHR_SCHEDULED = zoneSymbol('xhrScheduled');
    function patchXHR(window) {
      function findPendingTask(target) {
        var pendingTask = target[XHR_TASK];
        return pendingTask;
      }
      function scheduleTask(task) {
        XMLHttpRequest[XHR_SCHEDULED] = false;
        var data = task.data;
        var listener = data.target[XHR_LISTENER];
        var oriAddListener = data.target[zoneSymbol('addEventListener')];
        var oriRemoveListener = data.target[zoneSymbol('removeEventListener')];
        if (listener) {
          oriRemoveListener.apply(data.target, ['readystatechange', listener]);
        }
        var newListener = data.target[XHR_LISTENER] = function() {
          if (data.target.readyState === data.target.DONE) {
            if (!data.aborted && XMLHttpRequest[XHR_SCHEDULED] && task.state === 'scheduled') {
              task.invoke();
            }
          }
        };
        oriAddListener.apply(data.target, ['readystatechange', newListener]);
        var storedTask = data.target[XHR_TASK];
        if (!storedTask) {
          data.target[XHR_TASK] = task;
        }
        sendNative.apply(data.target, data.args);
        XMLHttpRequest[XHR_SCHEDULED] = true;
        return task;
      }
      function placeholderCallback() {}
      function clearTask(task) {
        var data = task.data;
        data.aborted = true;
        return abortNative.apply(data.target, data.args);
      }
      var openNative = patchMethod(window.XMLHttpRequest.prototype, 'open', function() {
        return function(self, args) {
          self[XHR_SYNC] = args[2] == false;
          return openNative.apply(self, args);
        };
      });
      var sendNative = patchMethod(window.XMLHttpRequest.prototype, 'send', function() {
        return function(self, args) {
          var zone = Zone.current;
          if (self[XHR_SYNC]) {
            return sendNative.apply(self, args);
          } else {
            var options = {
              target: self,
              isPeriodic: false,
              delay: null,
              args: args,
              aborted: false
            };
            return zone.scheduleMacroTask('XMLHttpRequest.send', placeholderCallback, options, scheduleTask, clearTask);
          }
        };
      });
      var abortNative = patchMethod(window.XMLHttpRequest.prototype, 'abort', function(delegate) {
        return function(self, args) {
          var task = findPendingTask(self);
          if (task && typeof task.type == 'string') {
            if (task.cancelFn == null || (task.data && task.data.aborted)) {
              return;
            }
            task.zone.cancelTask(task);
          }
        };
      });
    }
  });
  Zone.__load_patch('geolocation', function(global, Zone, api) {
    if (global['navigator'] && global['navigator'].geolocation) {
      patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);
    }
  });
  Zone.__load_patch('PromiseRejectionEvent', function(global, Zone, api) {
    function findPromiseRejectionHandler(evtName) {
      return function(e) {
        var eventTasks = findEventTasks(global, evtName);
        eventTasks.forEach(function(eventTask) {
          var PromiseRejectionEvent = global['PromiseRejectionEvent'];
          if (PromiseRejectionEvent) {
            var evt = new PromiseRejectionEvent(evtName, {
              promise: e.promise,
              reason: e.rejection
            });
            eventTask.invoke(evt);
          }
        });
      };
    }
    if (global['PromiseRejectionEvent']) {
      Zone[zoneSymbol('unhandledPromiseRejectionHandler')] = findPromiseRejectionHandler('unhandledrejection');
      Zone[zoneSymbol('rejectionHandledHandler')] = findPromiseRejectionHandler('rejectionhandled');
    }
  });
  Zone.__load_patch('util', function(global, Zone, api) {
    api.patchOnProperties = patchOnProperties;
    api.patchMethod = patchMethod;
  });
})));

})();
System.registerDynamic("node_modules/reflect-metadata/Reflect.js", [], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        var Reflect = $__global["Reflect"];
        /*! *****************************************************************************
        Copyright (C) Microsoft. All rights reserved.
        Licensed under the Apache License, Version 2.0 (the "License"); you may not use
        this file except in compliance with the License. You may obtain a copy of the
        License at http://www.apache.org/licenses/LICENSE-2.0
        
        THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
        WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
        MERCHANTABLITY OR NON-INFRINGEMENT.
        
        See the Apache Version 2.0 License for specific language governing permissions
        and limitations under the License.
        ***************************************************************************** */
        var Reflect;
        (function (Reflect) {
            "use strict";

            var hasOwn = Object.prototype.hasOwnProperty;
            // feature test for Symbol support
            var supportsSymbol = typeof Symbol === "function";
            var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
            var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
            var HashMap;
            (function (HashMap) {
                var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
                var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
                var downLevel = !supportsCreate && !supportsProto;
                // create an object in dictionary mode (a.k.a. "slow" mode in v8)
                HashMap.create = supportsCreate ? function () {
                    return MakeDictionary(Object.create(null));
                } : supportsProto ? function () {
                    return MakeDictionary({ __proto__: null });
                } : function () {
                    return MakeDictionary({});
                };
                HashMap.has = downLevel ? function (map, key) {
                    return hasOwn.call(map, key);
                } : function (map, key) {
                    return key in map;
                };
                HashMap.get = downLevel ? function (map, key) {
                    return hasOwn.call(map, key) ? map[key] : undefined;
                } : function (map, key) {
                    return map[key];
                };
            })(HashMap || (HashMap = {}));
            // Load global or shim versions of Map, Set, and WeakMap
            var functionPrototype = Object.getPrototypeOf(Function);
            var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
            var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
            var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
            var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
            // [[Metadata]] internal slot
            // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
            var Metadata = new _WeakMap();
            /**
              * Applies a set of decorators to a property of a target object.
              * @param decorators An array of decorators.
              * @param target The target object.
              * @param propertyKey (Optional) The property key to decorate.
              * @param attributes (Optional) The property descriptor for the target key.
              * @remarks Decorators are applied in reverse order.
              * @example
              *
              *     class Example {
              *         // property declarations are not part of ES6, though they are valid in TypeScript:
              *         // static staticProperty;
              *         // property;
              *
              *         constructor(p) { }
              *         static staticMethod(p) { }
              *         method(p) { }
              *     }
              *
              *     // constructor
              *     Example = Reflect.decorate(decoratorsArray, Example);
              *
              *     // property (on constructor)
              *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
              *
              *     // property (on prototype)
              *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
              *
              *     // method (on constructor)
              *     Object.defineProperty(Example, "staticMethod",
              *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
              *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
              *
              *     // method (on prototype)
              *     Object.defineProperty(Example.prototype, "method",
              *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
              *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
              *
              */
            function decorate(decorators, target, propertyKey, attributes) {
                if (!IsUndefined(propertyKey)) {
                    if (!IsArray(decorators)) throw new TypeError();
                    if (!IsObject(target)) throw new TypeError();
                    if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes)) throw new TypeError();
                    if (IsNull(attributes)) attributes = undefined;
                    propertyKey = ToPropertyKey(propertyKey);
                    return DecorateProperty(decorators, target, propertyKey, attributes);
                } else {
                    if (!IsArray(decorators)) throw new TypeError();
                    if (!IsConstructor(target)) throw new TypeError();
                    return DecorateConstructor(decorators, target);
                }
            }
            Reflect.decorate = decorate;
            // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
            // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
            /**
              * A default metadata decorator factory that can be used on a class, class member, or parameter.
              * @param metadataKey The key for the metadata entry.
              * @param metadataValue The value for the metadata entry.
              * @returns A decorator function.
              * @remarks
              * If `metadataKey` is already defined for the target and target key, the
              * metadataValue for that key will be overwritten.
              * @example
              *
              *     // constructor
              *     @Reflect.metadata(key, value)
              *     class Example {
              *     }
              *
              *     // property (on constructor, TypeScript only)
              *     class Example {
              *         @Reflect.metadata(key, value)
              *         static staticProperty;
              *     }
              *
              *     // property (on prototype, TypeScript only)
              *     class Example {
              *         @Reflect.metadata(key, value)
              *         property;
              *     }
              *
              *     // method (on constructor)
              *     class Example {
              *         @Reflect.metadata(key, value)
              *         static staticMethod() { }
              *     }
              *
              *     // method (on prototype)
              *     class Example {
              *         @Reflect.metadata(key, value)
              *         method() { }
              *     }
              *
              */
            function metadata(metadataKey, metadataValue) {
                function decorator(target, propertyKey) {
                    if (!IsObject(target)) throw new TypeError();
                    if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) throw new TypeError();
                    OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
                }
                return decorator;
            }
            Reflect.metadata = metadata;
            /**
              * Define a unique metadata entry on the target.
              * @param metadataKey A key used to store and retrieve metadata.
              * @param metadataValue A value that contains attached metadata.
              * @param target The target object on which to define metadata.
              * @param propertyKey (Optional) The property key for the target.
              * @example
              *
              *     class Example {
              *         // property declarations are not part of ES6, though they are valid in TypeScript:
              *         // static staticProperty;
              *         // property;
              *
              *         constructor(p) { }
              *         static staticMethod(p) { }
              *         method(p) { }
              *     }
              *
              *     // constructor
              *     Reflect.defineMetadata("custom:annotation", options, Example);
              *
              *     // property (on constructor)
              *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
              *
              *     // property (on prototype)
              *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
              *
              *     // method (on constructor)
              *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
              *
              *     // method (on prototype)
              *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
              *
              *     // decorator factory as metadata-producing annotation.
              *     function MyAnnotation(options): Decorator {
              *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
              *     }
              *
              */
            function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            Reflect.defineMetadata = defineMetadata;
            /**
              * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
              * @param metadataKey A key used to store and retrieve metadata.
              * @param target The target object on which the metadata is defined.
              * @param propertyKey (Optional) The property key for the target.
              * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
              * @example
              *
              *     class Example {
              *         // property declarations are not part of ES6, though they are valid in TypeScript:
              *         // static staticProperty;
              *         // property;
              *
              *         constructor(p) { }
              *         static staticMethod(p) { }
              *         method(p) { }
              *     }
              *
              *     // constructor
              *     result = Reflect.hasMetadata("custom:annotation", Example);
              *
              *     // property (on constructor)
              *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
              *
              *     // property (on prototype)
              *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
              *
              *     // method (on constructor)
              *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
              *
              *     // method (on prototype)
              *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
              *
              */
            function hasMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryHasMetadata(metadataKey, target, propertyKey);
            }
            Reflect.hasMetadata = hasMetadata;
            /**
              * Gets a value indicating whether the target object has the provided metadata key defined.
              * @param metadataKey A key used to store and retrieve metadata.
              * @param target The target object on which the metadata is defined.
              * @param propertyKey (Optional) The property key for the target.
              * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
              * @example
              *
              *     class Example {
              *         // property declarations are not part of ES6, though they are valid in TypeScript:
              *         // static staticProperty;
              *         // property;
              *
              *         constructor(p) { }
              *         static staticMethod(p) { }
              *         method(p) { }
              *     }
              *
              *     // constructor
              *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
              *
              *     // property (on constructor)
              *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
              *
              *     // property (on prototype)
              *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
              *
              *     // method (on constructor)
              *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
              *
              *     // method (on prototype)
              *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
              *
              */
            function hasOwnMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
            }
            Reflect.hasOwnMetadata = hasOwnMetadata;
            /**
              * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
              * @param metadataKey A key used to store and retrieve metadata.
              * @param target The target object on which the metadata is defined.
              * @param propertyKey (Optional) The property key for the target.
              * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
              * @example
              *
              *     class Example {
              *         // property declarations are not part of ES6, though they are valid in TypeScript:
              *         // static staticProperty;
              *         // property;
              *
              *         constructor(p) { }
              *         static staticMethod(p) { }
              *         method(p) { }
              *     }
              *
              *     // constructor
              *     result = Reflect.getMetadata("custom:annotation", Example);
              *
              *     // property (on constructor)
              *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
              *
              *     // property (on prototype)
              *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
              *
              *     // method (on constructor)
              *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
              *
              *     // method (on prototype)
              *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
              *
              */
            function getMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryGetMetadata(metadataKey, target, propertyKey);
            }
            Reflect.getMetadata = getMetadata;
            /**
              * Gets the metadata value for the provided metadata key on the target object.
              * @param metadataKey A key used to store and retrieve metadata.
              * @param target The target object on which the metadata is defined.
              * @param propertyKey (Optional) The property key for the target.
              * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
              * @example
              *
              *     class Example {
              *         // property declarations are not part of ES6, though they are valid in TypeScript:
              *         // static staticProperty;
              *         // property;
              *
              *         constructor(p) { }
              *         static staticMethod(p) { }
              *         method(p) { }
              *     }
              *
              *     // constructor
              *     result = Reflect.getOwnMetadata("custom:annotation", Example);
              *
              *     // property (on constructor)
              *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
              *
              *     // property (on prototype)
              *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
              *
              *     // method (on constructor)
              *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
              *
              *     // method (on prototype)
              *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
              *
              */
            function getOwnMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
            }
            Reflect.getOwnMetadata = getOwnMetadata;
            /**
              * Gets the metadata keys defined on the target object or its prototype chain.
              * @param target The target object on which the metadata is defined.
              * @param propertyKey (Optional) The property key for the target.
              * @returns An array of unique metadata keys.
              * @example
              *
              *     class Example {
              *         // property declarations are not part of ES6, though they are valid in TypeScript:
              *         // static staticProperty;
              *         // property;
              *
              *         constructor(p) { }
              *         static staticMethod(p) { }
              *         method(p) { }
              *     }
              *
              *     // constructor
              *     result = Reflect.getMetadataKeys(Example);
              *
              *     // property (on constructor)
              *     result = Reflect.getMetadataKeys(Example, "staticProperty");
              *
              *     // property (on prototype)
              *     result = Reflect.getMetadataKeys(Example.prototype, "property");
              *
              *     // method (on constructor)
              *     result = Reflect.getMetadataKeys(Example, "staticMethod");
              *
              *     // method (on prototype)
              *     result = Reflect.getMetadataKeys(Example.prototype, "method");
              *
              */
            function getMetadataKeys(target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryMetadataKeys(target, propertyKey);
            }
            Reflect.getMetadataKeys = getMetadataKeys;
            /**
              * Gets the unique metadata keys defined on the target object.
              * @param target The target object on which the metadata is defined.
              * @param propertyKey (Optional) The property key for the target.
              * @returns An array of unique metadata keys.
              * @example
              *
              *     class Example {
              *         // property declarations are not part of ES6, though they are valid in TypeScript:
              *         // static staticProperty;
              *         // property;
              *
              *         constructor(p) { }
              *         static staticMethod(p) { }
              *         method(p) { }
              *     }
              *
              *     // constructor
              *     result = Reflect.getOwnMetadataKeys(Example);
              *
              *     // property (on constructor)
              *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
              *
              *     // property (on prototype)
              *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
              *
              *     // method (on constructor)
              *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
              *
              *     // method (on prototype)
              *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
              *
              */
            function getOwnMetadataKeys(target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryOwnMetadataKeys(target, propertyKey);
            }
            Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
            /**
              * Deletes the metadata entry from the target object with the provided key.
              * @param metadataKey A key used to store and retrieve metadata.
              * @param target The target object on which the metadata is defined.
              * @param propertyKey (Optional) The property key for the target.
              * @returns `true` if the metadata entry was found and deleted; otherwise, false.
              * @example
              *
              *     class Example {
              *         // property declarations are not part of ES6, though they are valid in TypeScript:
              *         // static staticProperty;
              *         // property;
              *
              *         constructor(p) { }
              *         static staticMethod(p) { }
              *         method(p) { }
              *     }
              *
              *     // constructor
              *     result = Reflect.deleteMetadata("custom:annotation", Example);
              *
              *     // property (on constructor)
              *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
              *
              *     // property (on prototype)
              *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
              *
              *     // method (on constructor)
              *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
              *
              *     // method (on prototype)
              *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
              *
              */
            function deleteMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
                var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/false);
                if (IsUndefined(metadataMap)) return false;
                if (!metadataMap.delete(metadataKey)) return false;
                if (metadataMap.size > 0) return true;
                var targetMetadata = Metadata.get(target);
                targetMetadata.delete(propertyKey);
                if (targetMetadata.size > 0) return true;
                Metadata.delete(target);
                return true;
            }
            Reflect.deleteMetadata = deleteMetadata;
            function DecorateConstructor(decorators, target) {
                for (var i = decorators.length - 1; i >= 0; --i) {
                    var decorator = decorators[i];
                    var decorated = decorator(target);
                    if (!IsUndefined(decorated) && !IsNull(decorated)) {
                        if (!IsConstructor(decorated)) throw new TypeError();
                        target = decorated;
                    }
                }
                return target;
            }
            function DecorateProperty(decorators, target, propertyKey, descriptor) {
                for (var i = decorators.length - 1; i >= 0; --i) {
                    var decorator = decorators[i];
                    var decorated = decorator(target, propertyKey, descriptor);
                    if (!IsUndefined(decorated) && !IsNull(decorated)) {
                        if (!IsObject(decorated)) throw new TypeError();
                        descriptor = decorated;
                    }
                }
                return descriptor;
            }
            function GetOrCreateMetadataMap(O, P, Create) {
                var targetMetadata = Metadata.get(O);
                if (IsUndefined(targetMetadata)) {
                    if (!Create) return undefined;
                    targetMetadata = new _Map();
                    Metadata.set(O, targetMetadata);
                }
                var metadataMap = targetMetadata.get(P);
                if (IsUndefined(metadataMap)) {
                    if (!Create) return undefined;
                    metadataMap = new _Map();
                    targetMetadata.set(P, metadataMap);
                }
                return metadataMap;
            }
            // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
            function OrdinaryHasMetadata(MetadataKey, O, P) {
                var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
                if (hasOwn) return true;
                var parent = OrdinaryGetPrototypeOf(O);
                if (!IsNull(parent)) return OrdinaryHasMetadata(MetadataKey, parent, P);
                return false;
            }
            // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
            function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
                if (IsUndefined(metadataMap)) return false;
                return ToBoolean(metadataMap.has(MetadataKey));
            }
            // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
            function OrdinaryGetMetadata(MetadataKey, O, P) {
                var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
                if (hasOwn) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
                var parent = OrdinaryGetPrototypeOf(O);
                if (!IsNull(parent)) return OrdinaryGetMetadata(MetadataKey, parent, P);
                return undefined;
            }
            // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
            function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
                if (IsUndefined(metadataMap)) return undefined;
                return metadataMap.get(MetadataKey);
            }
            // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
            function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/true);
                metadataMap.set(MetadataKey, MetadataValue);
            }
            // 3.1.6.1 OrdinaryMetadataKeys(O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
            function OrdinaryMetadataKeys(O, P) {
                var ownKeys = OrdinaryOwnMetadataKeys(O, P);
                var parent = OrdinaryGetPrototypeOf(O);
                if (parent === null) return ownKeys;
                var parentKeys = OrdinaryMetadataKeys(parent, P);
                if (parentKeys.length <= 0) return ownKeys;
                if (ownKeys.length <= 0) return parentKeys;
                var set = new _Set();
                var keys = [];
                for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                    var key = ownKeys_1[_i];
                    var hasKey = set.has(key);
                    if (!hasKey) {
                        set.add(key);
                        keys.push(key);
                    }
                }
                for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                    var key = parentKeys_1[_a];
                    var hasKey = set.has(key);
                    if (!hasKey) {
                        set.add(key);
                        keys.push(key);
                    }
                }
                return keys;
            }
            // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
            function OrdinaryOwnMetadataKeys(O, P) {
                var keys = [];
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
                if (IsUndefined(metadataMap)) return keys;
                var keysObj = metadataMap.keys();
                var iterator = GetIterator(keysObj);
                var k = 0;
                while (true) {
                    var next = IteratorStep(iterator);
                    if (!next) {
                        keys.length = k;
                        return keys;
                    }
                    var nextValue = IteratorValue(next);
                    try {
                        keys[k] = nextValue;
                    } catch (e) {
                        try {
                            IteratorClose(iterator);
                        } finally {
                            throw e;
                        }
                    }
                    k++;
                }
            }
            // 6 ECMAScript Data Typ0es and Values
            // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
            function Type(x) {
                if (x === null) return 1 /* Null */;
                switch (typeof x) {
                    case "undefined":
                        return 0 /* Undefined */;
                    case "boolean":
                        return 2 /* Boolean */;
                    case "string":
                        return 3 /* String */;
                    case "symbol":
                        return 4 /* Symbol */;
                    case "number":
                        return 5 /* Number */;
                    case "object":
                        return x === null ? 1 /* Null */ : 6 /* Object */;
                    default:
                        return 6 /* Object */;
                }
            }
            // 6.1.1 The Undefined Type
            // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
            function IsUndefined(x) {
                return x === undefined;
            }
            // 6.1.2 The Null Type
            // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
            function IsNull(x) {
                return x === null;
            }
            // 6.1.5 The Symbol Type
            // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
            function IsSymbol(x) {
                return typeof x === "symbol";
            }
            // 6.1.7 The Object Type
            // https://tc39.github.io/ecma262/#sec-object-type
            function IsObject(x) {
                return typeof x === "object" ? x !== null : typeof x === "function";
            }
            // 7.1 Type Conversion
            // https://tc39.github.io/ecma262/#sec-type-conversion
            // 7.1.1 ToPrimitive(input [, PreferredType])
            // https://tc39.github.io/ecma262/#sec-toprimitive
            function ToPrimitive(input, PreferredType) {
                switch (Type(input)) {
                    case 0 /* Undefined */:
                        return input;
                    case 1 /* Null */:
                        return input;
                    case 2 /* Boolean */:
                        return input;
                    case 3 /* String */:
                        return input;
                    case 4 /* Symbol */:
                        return input;
                    case 5 /* Number */:
                        return input;
                }
                var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
                var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
                if (exoticToPrim !== undefined) {
                    var result = exoticToPrim.call(input, hint);
                    if (IsObject(result)) throw new TypeError();
                    return result;
                }
                return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
            }
            // 7.1.1.1 OrdinaryToPrimitive(O, hint)
            // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
            function OrdinaryToPrimitive(O, hint) {
                if (hint === "string") {
                    var toString_1 = O.toString;
                    if (IsCallable(toString_1)) {
                        var result = toString_1.call(O);
                        if (!IsObject(result)) return result;
                    }
                    var valueOf = O.valueOf;
                    if (IsCallable(valueOf)) {
                        var result = valueOf.call(O);
                        if (!IsObject(result)) return result;
                    }
                } else {
                    var valueOf = O.valueOf;
                    if (IsCallable(valueOf)) {
                        var result = valueOf.call(O);
                        if (!IsObject(result)) return result;
                    }
                    var toString_2 = O.toString;
                    if (IsCallable(toString_2)) {
                        var result = toString_2.call(O);
                        if (!IsObject(result)) return result;
                    }
                }
                throw new TypeError();
            }
            // 7.1.2 ToBoolean(argument)
            // https://tc39.github.io/ecma262/2016/#sec-toboolean
            function ToBoolean(argument) {
                return !!argument;
            }
            // 7.1.12 ToString(argument)
            // https://tc39.github.io/ecma262/#sec-tostring
            function ToString(argument) {
                return "" + argument;
            }
            // 7.1.14 ToPropertyKey(argument)
            // https://tc39.github.io/ecma262/#sec-topropertykey
            function ToPropertyKey(argument) {
                var key = ToPrimitive(argument, 3 /* String */);
                if (IsSymbol(key)) return key;
                return ToString(key);
            }
            // 7.2 Testing and Comparison Operations
            // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
            // 7.2.2 IsArray(argument)
            // https://tc39.github.io/ecma262/#sec-isarray
            function IsArray(argument) {
                return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
            }
            // 7.2.3 IsCallable(argument)
            // https://tc39.github.io/ecma262/#sec-iscallable
            function IsCallable(argument) {
                // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
                return typeof argument === "function";
            }
            // 7.2.4 IsConstructor(argument)
            // https://tc39.github.io/ecma262/#sec-isconstructor
            function IsConstructor(argument) {
                // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
                return typeof argument === "function";
            }
            // 7.2.7 IsPropertyKey(argument)
            // https://tc39.github.io/ecma262/#sec-ispropertykey
            function IsPropertyKey(argument) {
                switch (Type(argument)) {
                    case 3 /* String */:
                        return true;
                    case 4 /* Symbol */:
                        return true;
                    default:
                        return false;
                }
            }
            // 7.3 Operations on Objects
            // https://tc39.github.io/ecma262/#sec-operations-on-objects
            // 7.3.9 GetMethod(V, P)
            // https://tc39.github.io/ecma262/#sec-getmethod
            function GetMethod(V, P) {
                var func = V[P];
                if (func === undefined || func === null) return undefined;
                if (!IsCallable(func)) throw new TypeError();
                return func;
            }
            // 7.4 Operations on Iterator Objects
            // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
            function GetIterator(obj) {
                var method = GetMethod(obj, iteratorSymbol);
                if (!IsCallable(method)) throw new TypeError(); // from Call
                var iterator = method.call(obj);
                if (!IsObject(iterator)) throw new TypeError();
                return iterator;
            }
            // 7.4.4 IteratorValue(iterResult)
            // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
            function IteratorValue(iterResult) {
                return iterResult.value;
            }
            // 7.4.5 IteratorStep(iterator)
            // https://tc39.github.io/ecma262/#sec-iteratorstep
            function IteratorStep(iterator) {
                var result = iterator.next();
                return result.done ? false : result;
            }
            // 7.4.6 IteratorClose(iterator, completion)
            // https://tc39.github.io/ecma262/#sec-iteratorclose
            function IteratorClose(iterator) {
                var f = iterator["return"];
                if (f) f.call(iterator);
            }
            // 9.1 Ordinary Object Internal Methods and Internal Slots
            // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
            // 9.1.1.1 OrdinaryGetPrototypeOf(O)
            // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
            function OrdinaryGetPrototypeOf(O) {
                var proto = Object.getPrototypeOf(O);
                if (typeof O !== "function" || O === functionPrototype) return proto;
                // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
                // Try to determine the superclass constructor. Compatible implementations
                // must either set __proto__ on a subclass constructor to the superclass constructor,
                // or ensure each class has a valid `constructor` property on its prototype that
                // points back to the constructor.
                // If this is not the same as Function.[[Prototype]], then this is definately inherited.
                // This is the case when in ES6 or when using __proto__ in a compatible browser.
                if (proto !== functionPrototype) return proto;
                // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
                var prototype = O.prototype;
                var prototypeProto = prototype && Object.getPrototypeOf(prototype);
                if (prototypeProto == null || prototypeProto === Object.prototype) return proto;
                // If the constructor was not a function, then we cannot determine the heritage.
                var constructor = prototypeProto.constructor;
                if (typeof constructor !== "function") return proto;
                // If we have some kind of self-reference, then we cannot determine the heritage.
                if (constructor === O) return proto;
                // we have a pretty good guess at the heritage.
                return constructor;
            }
            // naive Map shim
            function CreateMapPolyfill() {
                var cacheSentinel = {};
                var arraySentinel = [];
                var MapIterator = function () {
                    function MapIterator(keys, values, selector) {
                        this._index = 0;
                        this._keys = keys;
                        this._values = values;
                        this._selector = selector;
                    }
                    MapIterator.prototype["@@iterator"] = function () {
                        return this;
                    };
                    MapIterator.prototype[iteratorSymbol] = function () {
                        return this;
                    };
                    MapIterator.prototype.next = function () {
                        var index = this._index;
                        if (index >= 0 && index < this._keys.length) {
                            var result = this._selector(this._keys[index], this._values[index]);
                            if (index + 1 >= this._keys.length) {
                                this._index = -1;
                                this._keys = arraySentinel;
                                this._values = arraySentinel;
                            } else {
                                this._index++;
                            }
                            return { value: result, done: false };
                        }
                        return { value: undefined, done: true };
                    };
                    MapIterator.prototype.throw = function (error) {
                        if (this._index >= 0) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        throw error;
                    };
                    MapIterator.prototype.return = function (value) {
                        if (this._index >= 0) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        return { value: value, done: true };
                    };
                    return MapIterator;
                }();
                return function () {
                    function Map() {
                        this._keys = [];
                        this._values = [];
                        this._cacheKey = cacheSentinel;
                        this._cacheIndex = -2;
                    }
                    Object.defineProperty(Map.prototype, "size", {
                        get: function () {
                            return this._keys.length;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Map.prototype.has = function (key) {
                        return this._find(key, /*insert*/false) >= 0;
                    };
                    Map.prototype.get = function (key) {
                        var index = this._find(key, /*insert*/false);
                        return index >= 0 ? this._values[index] : undefined;
                    };
                    Map.prototype.set = function (key, value) {
                        var index = this._find(key, /*insert*/true);
                        this._values[index] = value;
                        return this;
                    };
                    Map.prototype.delete = function (key) {
                        var index = this._find(key, /*insert*/false);
                        if (index >= 0) {
                            var size = this._keys.length;
                            for (var i = index + 1; i < size; i++) {
                                this._keys[i - 1] = this._keys[i];
                                this._values[i - 1] = this._values[i];
                            }
                            this._keys.length--;
                            this._values.length--;
                            if (key === this._cacheKey) {
                                this._cacheKey = cacheSentinel;
                                this._cacheIndex = -2;
                            }
                            return true;
                        }
                        return false;
                    };
                    Map.prototype.clear = function () {
                        this._keys.length = 0;
                        this._values.length = 0;
                        this._cacheKey = cacheSentinel;
                        this._cacheIndex = -2;
                    };
                    Map.prototype.keys = function () {
                        return new MapIterator(this._keys, this._values, getKey);
                    };
                    Map.prototype.values = function () {
                        return new MapIterator(this._keys, this._values, getValue);
                    };
                    Map.prototype.entries = function () {
                        return new MapIterator(this._keys, this._values, getEntry);
                    };
                    Map.prototype["@@iterator"] = function () {
                        return this.entries();
                    };
                    Map.prototype[iteratorSymbol] = function () {
                        return this.entries();
                    };
                    Map.prototype._find = function (key, insert) {
                        if (this._cacheKey !== key) {
                            this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                        }
                        if (this._cacheIndex < 0 && insert) {
                            this._cacheIndex = this._keys.length;
                            this._keys.push(key);
                            this._values.push(undefined);
                        }
                        return this._cacheIndex;
                    };
                    return Map;
                }();
                function getKey(key, _) {
                    return key;
                }
                function getValue(_, value) {
                    return value;
                }
                function getEntry(key, value) {
                    return [key, value];
                }
            }
            // naive Set shim
            function CreateSetPolyfill() {
                return function () {
                    function Set() {
                        this._map = new _Map();
                    }
                    Object.defineProperty(Set.prototype, "size", {
                        get: function () {
                            return this._map.size;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Set.prototype.has = function (value) {
                        return this._map.has(value);
                    };
                    Set.prototype.add = function (value) {
                        return this._map.set(value, value), this;
                    };
                    Set.prototype.delete = function (value) {
                        return this._map.delete(value);
                    };
                    Set.prototype.clear = function () {
                        this._map.clear();
                    };
                    Set.prototype.keys = function () {
                        return this._map.keys();
                    };
                    Set.prototype.values = function () {
                        return this._map.values();
                    };
                    Set.prototype.entries = function () {
                        return this._map.entries();
                    };
                    Set.prototype["@@iterator"] = function () {
                        return this.keys();
                    };
                    Set.prototype[iteratorSymbol] = function () {
                        return this.keys();
                    };
                    return Set;
                }();
            }
            // naive WeakMap shim
            function CreateWeakMapPolyfill() {
                var UUID_SIZE = 16;
                var keys = HashMap.create();
                var rootKey = CreateUniqueKey();
                return function () {
                    function WeakMap() {
                        this._key = CreateUniqueKey();
                    }
                    WeakMap.prototype.has = function (target) {
                        var table = GetOrCreateWeakMapTable(target, /*create*/false);
                        return table !== undefined ? HashMap.has(table, this._key) : false;
                    };
                    WeakMap.prototype.get = function (target) {
                        var table = GetOrCreateWeakMapTable(target, /*create*/false);
                        return table !== undefined ? HashMap.get(table, this._key) : undefined;
                    };
                    WeakMap.prototype.set = function (target, value) {
                        var table = GetOrCreateWeakMapTable(target, /*create*/true);
                        table[this._key] = value;
                        return this;
                    };
                    WeakMap.prototype.delete = function (target) {
                        var table = GetOrCreateWeakMapTable(target, /*create*/false);
                        return table !== undefined ? delete table[this._key] : false;
                    };
                    WeakMap.prototype.clear = function () {
                        // NOTE: not a real clear, just makes the previous data unreachable
                        this._key = CreateUniqueKey();
                    };
                    return WeakMap;
                }();
                function CreateUniqueKey() {
                    var key;
                    do key = "@@WeakMap@@" + CreateUUID(); while (HashMap.has(keys, key));
                    keys[key] = true;
                    return key;
                }
                function GetOrCreateWeakMapTable(target, create) {
                    if (!hasOwn.call(target, rootKey)) {
                        if (!create) return undefined;
                        Object.defineProperty(target, rootKey, { value: HashMap.create() });
                    }
                    return target[rootKey];
                }
                function FillRandomBytes(buffer, size) {
                    for (var i = 0; i < size; ++i) buffer[i] = Math.random() * 0xff | 0;
                    return buffer;
                }
                function GenRandomBytes(size) {
                    if (typeof Uint8Array === "function") {
                        if (typeof crypto !== "undefined") return crypto.getRandomValues(new Uint8Array(size));
                        if (typeof msCrypto !== "undefined") return msCrypto.getRandomValues(new Uint8Array(size));
                        return FillRandomBytes(new Uint8Array(size), size);
                    }
                    return FillRandomBytes(new Array(size), size);
                }
                function CreateUUID() {
                    var data = GenRandomBytes(UUID_SIZE);
                    // mark as random - RFC 4122 § 4.4
                    data[6] = data[6] & 0x4f | 0x40;
                    data[8] = data[8] & 0xbf | 0x80;
                    var result = "";
                    for (var offset = 0; offset < UUID_SIZE; ++offset) {
                        var byte = data[offset];
                        if (offset === 4 || offset === 6 || offset === 8) result += "-";
                        if (byte < 16) result += "0";
                        result += byte.toString(16).toLowerCase();
                    }
                    return result;
                }
            }
            // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
            function MakeDictionary(obj) {
                obj.__ = undefined;
                delete obj.__;
                return obj;
            }
            // patch global Reflect
            (function (__global) {
                if (typeof __global.Reflect !== "undefined") {
                    if (__global.Reflect !== Reflect) {
                        for (var p in Reflect) {
                            if (hasOwn.call(Reflect, p)) {
                                __global.Reflect[p] = Reflect[p];
                            }
                        }
                    }
                } else {
                    __global.Reflect = Reflect;
                }
            })(typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : Function("return this;")());
        })(Reflect || (Reflect = {}));
        

        $__global["Reflect"] = Reflect;
    })(this);

    return _retrieveGlobal();
});
(function() {
var define = System.amdDefine;
!function(t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("node_modules/single-spa/lib/single-spa.js", [], e) && define("singleSpa", ["node_modules/single-spa/lib/single-spa.js"], function(m) {
    return m;
  }) : "object" == typeof exports ? exports.singleSpa = e() : t.singleSpa = e();
}(this, function() {
  return function(t) {
    function e(r) {
      if (n[r])
        return n[r].exports;
      var o = n[r] = {
        i: r,
        l: !1,
        exports: {}
      };
      return t[r].call(o.exports, o, o.exports, e), o.l = !0, o.exports;
    }
    var n = {};
    return e.m = t, e.c = n, e.i = function(t) {
      return t;
    }, e.d = function(t, n, r) {
      e.o(t, n) || Object.defineProperty(t, n, {
        configurable: !1,
        enumerable: !0,
        get: r
      });
    }, e.n = function(t) {
      var n = t && t.__esModule ? function() {
        return t.default;
      } : function() {
        return t;
      };
      return e.d(n, "a", n), n;
    }, e.o = function(t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }, e.p = "", e(e.s = 111);
  }([function(t, e, n) {
    var r = n(36)("wks"),
        o = n(26),
        i = n(1).Symbol,
        u = "function" == typeof i;
    (t.exports = function(t) {
      return r[t] || (r[t] = u && i[t] || (u ? i : o)("Symbol." + t));
    }).store = r;
  }, function(t, e) {
    var n = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    "number" == typeof __g && (__g = n);
  }, function(t, e, n) {
    "use strict";
    function r(t) {
      return t.status === m;
    }
    function o(t) {
      return !r(t);
    }
    function i(t) {
      return t.status !== d && t.status !== h;
    }
    function u(t) {
      return !i(t);
    }
    function a(t) {
      try {
        return t.activeWhen(window.location);
      } catch (e) {
        (0, p.handleChildAppError)(e, t), t.status = y;
      }
    }
    function c(t) {
      try {
        return !t.activeWhen(window.location);
      } catch (e) {
        (0, p.handleChildAppError)(e, t), t.status = y;
      }
    }
    function s(t) {
      return t.status !== v;
    }
    function f(t) {
      return t !== y && (!t || t.status !== y);
    }
    function l(t) {
      return t.name;
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.SKIP_BECAUSE_BROKEN = e.UNLOADING = e.UNMOUNTING = e.MOUNTED = e.MOUNTING = e.NOT_MOUNTED = e.BOOTSTRAPPING = e.NOT_BOOTSTRAPPED = e.LOADING_SOURCE_CODE = e.NOT_LOADED = void 0, e.isActive = r, e.isntActive = o, e.isLoaded = i, e.isntLoaded = u, e.shouldBeActive = a, e.shouldntBeActive = c, e.notBootstrapped = s, e.notSkipped = f, e.toName = l;
    var p = n(10),
        d = e.NOT_LOADED = "NOT_LOADED",
        h = e.LOADING_SOURCE_CODE = "LOADING_SOURCE_CODE",
        v = e.NOT_BOOTSTRAPPED = "NOT_BOOTSTRAPPED",
        m = (e.BOOTSTRAPPING = "BOOTSTRAPPING", e.NOT_MOUNTED = "NOT_MOUNTED", e.MOUNTING = "MOUNTING", e.MOUNTED = "MOUNTED"),
        y = (e.UNMOUNTING = "UNMOUNTING", e.UNLOADING = "UNLOADING", e.SKIP_BECAUSE_BROKEN = "SKIP_BECAUSE_BROKEN");
  }, function(t, e) {
    var n = t.exports = {version: "2.4.0"};
    "number" == typeof __e && (__e = n);
  }, function(t, e, n) {
    var r = n(16);
    t.exports = function(t) {
      if (!r(t))
        throw TypeError(t + " is not an object!");
      return t;
    };
  }, function(t, e, n) {
    t.exports = !n(15)(function() {
      return 7 != Object.defineProperty({}, "a", {get: function() {
          return 7;
        }}).a;
    });
  }, function(t, e) {
    var n = {}.hasOwnProperty;
    t.exports = function(t, e) {
      return n.call(t, e);
    };
  }, function(t, e, n) {
    var r = n(8),
        o = n(24);
    t.exports = n(5) ? function(t, e, n) {
      return r.f(t, e, o(1, n));
    } : function(t, e, n) {
      return t[e] = n, t;
    };
  }, function(t, e, n) {
    var r = n(4),
        o = n(50),
        i = n(38),
        u = Object.defineProperty;
    e.f = n(5) ? Object.defineProperty : function(t, e, n) {
      if (r(t), e = i(e, !0), r(n), o)
        try {
          return u(t, e, n);
        } catch (t) {}
      if ("get" in n || "set" in n)
        throw TypeError("Accessors not supported!");
      return "value" in n && (t[e] = n.value), t;
    };
  }, function(t, e, n) {
    var r = n(51),
        o = n(31);
    t.exports = function(t) {
      return r(o(t));
    };
  }, function(t, e, n) {
    "use strict";
    function r(t, e) {
      var n = o(t, e);
      window.dispatchEvent(new u.default("single-spa:application-broken", {detail: {
          appName: e.name,
          err: n
        }})), window.SINGLE_SPA_TESTING ? console.error(n) : setTimeout(function() {
        throw n;
      });
    }
    function o(t, e) {
      var n = "'" + e.name + "' died in status " + e.status + ": ",
          r = void 0;
      if (t instanceof Error) {
        try {
          t.message = n + t.message;
        } catch (t) {}
        r = t;
      } else {
        console.warn("While " + e.status + ", '" + e.name + "' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.");
        try {
          r = new Error(n + JSON.stringify(t));
        } catch (e) {
          r = t;
        }
      }
      return r;
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.handleChildAppError = r;
    var i = n(41),
        u = function(t) {
          return t && t.__esModule ? t : {default: t};
        }(i);
  }, function(t, e, n) {
    "use strict";
    function r(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      if ("number" != typeof t || t <= 0)
        throw new Error("bootstrap max time must be a positive integer number of milliseconds");
      l.bootstrap = {
        millis: t,
        dieOnTimeout: e
      };
    }
    function o(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      if ("number" != typeof t || t <= 0)
        throw new Error("mount max time must be a positive integer number of milliseconds");
      l.mount = {
        millis: t,
        dieOnTimeout: e
      };
    }
    function i(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      if ("number" != typeof t || t <= 0)
        throw new Error("unmount max time must be a positive integer number of milliseconds");
      l.unmount = {
        millis: t,
        dieOnTimeout: e
      };
    }
    function u(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      if ("number" != typeof t || t <= 0)
        throw new Error("unload max time must be a positive integer number of milliseconds");
      l.unload = {
        millis: t,
        dieOnTimeout: e
      };
    }
    function a(t, e, n, r) {
      var o = 1e3;
      return new Promise(function(r, i) {
        function u(t) {
          if (!a)
            if (!0 === t)
              c = !0, n.dieOnTimeout ? i(e + " did not resolve or reject for " + n.millis + " milliseconds") : console.error(e + " did not resolve or reject for " + n.millis + " milliseconds -- we're no longer going to warn you about it.");
            else if (!c) {
              var r = t,
                  s = r * o;
              console.warn(e + " did not resolve or reject within " + s + " milliseconds"), s + o < n.millis && setTimeout(function() {
                return u(r + 1);
              }, o);
            }
        }
        var a = !1,
            c = !1;
        t.then(function(t) {
          a = !0, r(t);
        }).catch(function(t) {
          a = !0, i(t);
        }), setTimeout(function() {
          return u(1);
        }, o), setTimeout(function() {
          return u(!0);
        }, n.millis);
      });
    }
    function c() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return (0, f.default)({}, l, t);
    }
    Object.defineProperty(e, "__esModule", {value: !0});
    var s = n(71),
        f = function(t) {
          return t && t.__esModule ? t : {default: t};
        }(s);
    e.setBootstrapMaxTime = r, e.setMountMaxTime = o, e.setUnmountMaxTime = i, e.setUnloadMaxTime = u, e.reasonableTime = a, e.ensureValidAppTimeouts = c;
    var l = {
      bootstrap: {
        millis: 4e3,
        dieOnTimeout: !1
      },
      mount: {
        millis: 3e3,
        dieOnTimeout: !1
      },
      unmount: {
        millis: 3e3,
        dieOnTimeout: !1
      },
      unload: {
        millis: 3e3,
        dieOnTimeout: !1
      }
    };
  }, function(t, e, n) {
    "use strict";
    e.__esModule = !0;
    var r = n(68),
        o = function(t) {
          return t && t.__esModule ? t : {default: t};
        }(r);
    e.default = function(t) {
      return function() {
        var e = t.apply(this, arguments);
        return new o.default(function(t, n) {
          function r(i, u) {
            try {
              var a = e[i](u),
                  c = a.value;
            } catch (t) {
              return void n(t);
            }
            if (!a.done)
              return o.default.resolve(c).then(function(t) {
                r("next", t);
              }, function(t) {
                r("throw", t);
              });
            t(c);
          }
          return r("next");
        });
      };
    };
  }, function(t, e, n) {
    t.exports = n(109);
  }, function(t, e) {
    var n = {}.toString;
    t.exports = function(t) {
      return n.call(t).slice(8, -1);
    };
  }, function(t, e) {
    t.exports = function(t) {
      try {
        return !!t();
      } catch (t) {
        return !0;
      }
    };
  }, function(t, e) {
    t.exports = function(t) {
      return "object" == typeof t ? null !== t : "function" == typeof t;
    };
  }, function(t, e) {
    t.exports = {};
  }, function(t, e, n) {
    var r = n(55),
        o = n(33);
    t.exports = Object.keys || function(t) {
      return r(t, o);
    };
  }, function(t, e, n) {
    "use strict";
    function r(t) {
      return t && t.__esModule ? t : {default: t};
    }
    function o() {
      function t() {
        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
            r = (0, m.getMountedApps)();
        t && e(), n.forEach(function(t) {
          return t.resolve(r);
        });
        try {
          var i = s ? "single-spa:no-app-change" : "single-spa:app-change";
          window.dispatchEvent(new f.default(i)), window.dispatchEvent(new f.default("single-spa:routing-event"));
        } catch (t) {
          setTimeout(function() {
            throw t;
          });
        }
        if (b = !1, w.length > 0) {
          var u = w;
          w = [], o(u);
        }
        return r;
      }
      function e() {
        n.forEach(function(t) {
          (0, y.callCapturedEventListeners)(t.eventArguments);
        }), (0, y.callCapturedEventListeners)(a);
      }
      var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
          r = function() {
            var n = (0, c.default)(u.default.mark(function n() {
              var r;
              return u.default.wrap(function(n) {
                for (; ; )
                  switch (n.prev = n.next) {
                    case 0:
                      return r = (0, m.getAppsToLoad)().map(p.toLoadPromise), r.length > 0 && (s = !1), n.prev = 2, n.next = 5, Promise.all(r);
                    case 5:
                      n.next = 11;
                      break;
                    case 7:
                      throw n.prev = 7, n.t0 = n.catch(2), e(), n.t0;
                    case 11:
                      return n.abrupt("return", t());
                    case 12:
                    case "end":
                      return n.stop();
                  }
              }, n, this, [[2, 7]]);
            }));
            return function() {
              return n.apply(this, arguments);
            };
          }(),
          i = function() {
            var r = (0, c.default)(u.default.mark(function r() {
              var o,
                  i,
                  a,
                  f,
                  l,
                  y,
                  b;
              return u.default.wrap(function(r) {
                for (; ; )
                  switch (r.prev = r.next) {
                    case 0:
                      return o = (0, g.getAppsToUnload)().map(g.toUnloadPromise), i = (0, m.getAppsToUnmount)().map(v.toUnmountPromise).map(function(t) {
                        return t.then(g.toUnloadPromise);
                      }), a = i.concat(o), a.length > 0 && (s = !1), f = Promise.all(a), l = (0, m.getAppsToLoad)(), y = l.map(function(t) {
                        return (0, p.toLoadPromise)(t).then(d.toBootstrapPromise).then(function() {
                          var t = (0, c.default)(u.default.mark(function t(e) {
                            return u.default.wrap(function(t) {
                              for (; ; )
                                switch (t.prev = t.next) {
                                  case 0:
                                    return t.next = 2, f;
                                  case 2:
                                    return t.abrupt("return", (0, h.toMountPromise)(e));
                                  case 3:
                                  case "end":
                                    return t.stop();
                                }
                            }, t, this);
                          }));
                          return function(e) {
                            return t.apply(this, arguments);
                          };
                        }());
                      }), y.length > 0 && (s = !1), b = (0, m.getAppsToMount)().filter(function(t) {
                        return l.indexOf(t) < 0;
                      }).map(function() {
                        var t = (0, c.default)(u.default.mark(function t(e) {
                          return u.default.wrap(function(t) {
                            for (; ; )
                              switch (t.prev = t.next) {
                                case 0:
                                  return t.next = 2, (0, d.toBootstrapPromise)(e);
                                case 2:
                                  return t.next = 4, f;
                                case 4:
                                  return t.abrupt("return", (0, h.toMountPromise)(e));
                                case 5:
                                case "end":
                                  return t.stop();
                              }
                          }, t, this);
                        }));
                        return function(e) {
                          return t.apply(this, arguments);
                        };
                      }()), b.length > 0 && (s = !1), r.prev = 10, r.next = 13, f;
                    case 13:
                      r.next = 19;
                      break;
                    case 15:
                      throw r.prev = 15, r.t0 = r.catch(10), e(), r.t0;
                    case 19:
                      return e(), r.prev = 20, r.next = 23, Promise.all(y.concat(b));
                    case 23:
                      r.next = 29;
                      break;
                    case 25:
                      throw r.prev = 25, r.t1 = r.catch(20), n.forEach(function(t) {
                        return t.reject(r.t1);
                      }), r.t1;
                    case 29:
                      return r.abrupt("return", t(!1));
                    case 30:
                    case "end":
                      return r.stop();
                  }
              }, r, this, [[10, 15], [20, 25]]);
            }));
            return function() {
              return r.apply(this, arguments);
            };
          }(),
          a = arguments[1];
      if (b)
        return new Promise(function(t, e) {
          w.push({
            resolve: t,
            reject: e,
            eventArguments: a
          });
        });
      b = !0;
      var s = !0;
      return (0, l.isStarted)() ? i() : r();
    }
    Object.defineProperty(e, "__esModule", {value: !0});
    var i = n(13),
        u = r(i),
        a = n(12),
        c = r(a);
    e.reroute = o;
    var s = n(41),
        f = r(s),
        l = n(47),
        p = n(65),
        d = n(64),
        h = n(66),
        v = n(45),
        m = n(43),
        y = (n(2), n(28)),
        g = n(44),
        b = !1,
        w = [];
  }, function(t, e, n) {
    var r = n(30);
    t.exports = function(t, e, n) {
      if (r(t), void 0 === e)
        return t;
      switch (n) {
        case 1:
          return function(n) {
            return t.call(e, n);
          };
        case 2:
          return function(n, r) {
            return t.call(e, n, r);
          };
        case 3:
          return function(n, r, o) {
            return t.call(e, n, r, o);
          };
      }
      return function() {
        return t.apply(e, arguments);
      };
    };
  }, function(t, e, n) {
    var r = n(1),
        o = n(3),
        i = n(20),
        u = n(7),
        a = function(t, e, n) {
          var c,
              s,
              f,
              l = t & a.F,
              p = t & a.G,
              d = t & a.S,
              h = t & a.P,
              v = t & a.B,
              m = t & a.W,
              y = p ? o : o[e] || (o[e] = {}),
              g = y.prototype,
              b = p ? r : d ? r[e] : (r[e] || {}).prototype;
          p && (n = e);
          for (c in n)
            (s = !l && b && void 0 !== b[c]) && c in y || (f = s ? b[c] : n[c], y[c] = p && "function" != typeof b[c] ? n[c] : v && s ? i(f, r) : m && b[c] == f ? function(t) {
              var e = function(e, n, r) {
                if (this instanceof t) {
                  switch (arguments.length) {
                    case 0:
                      return new t;
                    case 1:
                      return new t(e);
                    case 2:
                      return new t(e, n);
                  }
                  return new t(e, n, r);
                }
                return t.apply(this, arguments);
              };
              return e.prototype = t.prototype, e;
            }(f) : h && "function" == typeof f ? i(Function.call, f) : f, h && ((y.virtual || (y.virtual = {}))[c] = f, t & a.R && g && !g[c] && u(g, c, f)));
        };
    a.F = 1, a.G = 2, a.S = 4, a.P = 8, a.B = 16, a.W = 32, a.U = 64, a.R = 128, t.exports = a;
  }, function(t, e) {
    t.exports = !0;
  }, function(t, e) {
    e.f = {}.propertyIsEnumerable;
  }, function(t, e) {
    t.exports = function(t, e) {
      return {
        enumerable: !(1 & t),
        configurable: !(2 & t),
        writable: !(4 & t),
        value: e
      };
    };
  }, function(t, e, n) {
    var r = n(8).f,
        o = n(6),
        i = n(0)("toStringTag");
    t.exports = function(t, e, n) {
      t && !o(t = n ? t : t.prototype, i) && r(t, i, {
        configurable: !0,
        value: e
      });
    };
  }, function(t, e) {
    var n = 0,
        r = Math.random();
    t.exports = function(t) {
      return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++n + r).toString(36));
    };
  }, function(t, e, n) {
    "use strict";
    function r(t) {
      if (!t || "function" != typeof t.import)
        throw new Error("'loader' is not a real loader. Must have an import function that returns a Promise");
      e.Loader = o = t, console.error("Warning: singleSpa.setLoader is deprecated. Please declare apps with a loading function instead. See https://github.com/CanopyTax/single-spa/blob/master/docs/root-application.md#loading-function");
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.setLoader = r;
    var o = e.Loader = null;
  }, function(t, e, n) {
    "use strict";
    function r(t) {
      var e = void 0;
      if ("string" == typeof t)
        e = t;
      else if (this && this.href)
        e = this.href;
      else {
        if (!(t && t.currentTarget && t.currentTarget.href && t.preventDefault))
          throw new Error("singleSpaNavigate must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag");
        e = t.currentTarget.href, t.preventDefault();
      }
      var n = u(window.location.href),
          r = u(e);
      0 === e.indexOf("#") ? window.location.hash = "#" + r.anchor : !function(t, e) {
        return e === t || e === "/" + t;
      }(r.path, n.path) || n.host !== r.host && r.host ? window.history.pushState(null, null, e) : window.location.hash = "#" + r.anchor;
    }
    function o(t) {
      var e = this;
      if (t) {
        var n = t[0].type;
        f.indexOf(n) >= 0 && s[n].forEach(function(n) {
          n.apply(e, t);
        });
      }
    }
    function i() {
      (0, a.reroute)([], arguments);
    }
    function u(t) {
      for (var e = {
        strictMode: !0,
        key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
        q: {
          name: "queryKey",
          parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
          strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
          loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
      },
          n = e,
          r = n.parser[n.strictMode ? "strict" : "loose"].exec(t),
          o = {},
          i = 14; i--; )
        o[n.key[i]] = r[i] || "";
      return o[n.q.name] = {}, o[n.key[12]].replace(n.q.parser, function(t, e, r) {
        e && (o[n.q.name][e] = r);
      }), o;
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.routingEventsListeningTo = void 0, e.navigateToUrl = r, e.callCapturedEventListeners = o;
    var a = n(19),
        c = n(29),
        s = {
          hashchange: [],
          popstate: []
        },
        f = e.routingEventsListeningTo = ["hashchange", "popstate"];
    window.addEventListener("hashchange", i), window.addEventListener("popstate", i);
    var l = window.addEventListener,
        p = window.removeEventListener;
    window.addEventListener = function(t, e) {
      return "function" == typeof e && f.indexOf(t) >= 0 && !(0, c.find)(s[t], function(t) {
        return t === e;
      }) ? void s[t].push(e) : l.apply(this, arguments);
    }, window.removeEventListener = function(t, e) {
      return "function" == typeof e && f.indexOf(t) >= 0 ? void(s[t] = s[t].filter(function(t) {
        return t !== e;
      })) : p.apply(this, arguments);
    };
    var d = window.history.pushState;
    window.history.pushState = function(t) {
      var e = d.apply(this, arguments);
      return (0, a.reroute)(), e;
    };
    var h = window.history.replaceState;
    window.history.replaceState = function() {
      var t = h.apply(this, arguments);
      return (0, a.reroute)(), t;
    }, window.singleSpaNavigate = r;
  }, function(t, e, n) {
    "use strict";
    function r(t, e) {
      for (var n = 0; n < t.length; n++)
        if (e(t[n]))
          return t[n];
      return null;
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.find = r;
  }, function(t, e) {
    t.exports = function(t) {
      if ("function" != typeof t)
        throw TypeError(t + " is not a function!");
      return t;
    };
  }, function(t, e) {
    t.exports = function(t) {
      if (void 0 == t)
        throw TypeError("Can't call method on  " + t);
      return t;
    };
  }, function(t, e, n) {
    var r = n(16),
        o = n(1).document,
        i = r(o) && r(o.createElement);
    t.exports = function(t) {
      return i ? o.createElement(t) : {};
    };
  }, function(t, e) {
    t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  }, function(t, e) {
    e.f = Object.getOwnPropertySymbols;
  }, function(t, e, n) {
    var r = n(36)("keys"),
        o = n(26);
    t.exports = function(t) {
      return r[t] || (r[t] = o(t));
    };
  }, function(t, e, n) {
    var r = n(1),
        o = r["__core-js_shared__"] || (r["__core-js_shared__"] = {});
    t.exports = function(t) {
      return o[t] || (o[t] = {});
    };
  }, function(t, e) {
    var n = Math.ceil,
        r = Math.floor;
    t.exports = function(t) {
      return isNaN(t = +t) ? 0 : (t > 0 ? r : n)(t);
    };
  }, function(t, e, n) {
    var r = n(16);
    t.exports = function(t, e) {
      if (!r(t))
        return t;
      var n,
          o;
      if (e && "function" == typeof(n = t.toString) && !r(o = n.call(t)))
        return o;
      if ("function" == typeof(n = t.valueOf) && !r(o = n.call(t)))
        return o;
      if (!e && "function" == typeof(n = t.toString) && !r(o = n.call(t)))
        return o;
      throw TypeError("Can't convert object to primitive value");
    };
  }, function(t, e, n) {
    var r = n(1),
        o = n(3),
        i = n(22),
        u = n(40),
        a = n(8).f;
    t.exports = function(t) {
      var e = o.Symbol || (o.Symbol = i ? {} : r.Symbol || {});
      "_" == t.charAt(0) || t in e || a(e, t, {value: u.f(t)});
    };
  }, function(t, e, n) {
    e.f = n(0);
  }, function(t, e, n) {
    (function(e) {
      var n = e.CustomEvent;
      t.exports = function() {
        try {
          var t = new n("cat", {detail: {foo: "bar"}});
          return "cat" === t.type && "bar" === t.detail.foo;
        } catch (t) {}
        return !1;
      }() ? n : "undefined" != typeof document && "function" == typeof document.createEvent ? function(t, e) {
        var n = document.createEvent("CustomEvent");
        return e ? n.initCustomEvent(t, e.bubbles, e.cancelable, e.detail) : n.initCustomEvent(t, !1, !1, void 0), n;
      } : function(t, e) {
        var n = document.createEventObject();
        return n.type = t, e ? (n.bubbles = Boolean(e.bubbles), n.cancelable = Boolean(e.cancelable), n.detail = e.detail) : (n.bubbles = !1, n.cancelable = !1, n.detail = void 0), n;
      };
    }).call(e, n(42));
  }, function(t, e) {
    var n;
    n = function() {
      return this;
    }();
    try {
      n = n || Function("return this")() || (0, eval)("this");
    } catch (t) {
      "object" == typeof window && (n = window);
    }
    t.exports = n;
  }, function(t, e, n) {
    "use strict";
    function r() {
      return g.filter(d.isActive).map(d.toName);
    }
    function o(t) {
      var e = (0, v.find)(g, function(e) {
        return e.name === t;
      });
      return e ? e.status : null;
    }
    function i(t, e, n) {
      if ("string" != typeof t || 0 === t.length)
        throw new Error("The first argument must be a non-empty string 'appName'");
      if (g[t])
        throw new Error("There is already an app declared with name " + t);
      var r = void 0,
          o = void 0;
      if (n)
        r = e, o = n;
      else {
        if (!l.Loader)
          throw new Error("You cannot declare a single-spa child application without either providing a way to load the application or a Loader. See https://github.com/CanopyTax/single-spa/blob/master/docs/single-spa-api.md#declarechildapplication");
        r = function() {
          return l.Loader.import(t);
        }, o = e;
      }
      if ("function" != typeof o)
        throw new Error("The activeWhen argument must be a function");
      g.push({
        name: t,
        loadImpl: r,
        activeWhen: o,
        status: d.NOT_LOADED
      }), (0, p.ensureJQuerySupport)(), (0, h.reroute)();
    }
    function u() {
      return g.filter(d.shouldBeActive).filter(d.notSkipped).filter(d.isntLoaded);
    }
    function a() {
      return g.filter(d.shouldntBeActive).filter(d.notSkipped).filter(d.isActive);
    }
    function c() {
      return g.filter(d.shouldBeActive).filter(d.notSkipped).filter(d.isntActive).filter(d.isLoaded);
    }
    function s(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {waitForUnmount: !1};
      if ("string" != typeof t)
        throw new Error("unloadChildApplication requires a string 'appName'");
      var n = (0, v.find)(g, function(e) {
        return e.name === t;
      });
      if (!n)
        throw new Error("Could not unload child application '" + t + "' because no such application has been declared");
      var r = (0, y.getAppUnloadInfo)(n.name);
      if (e && e.waitForUnmount) {
        if (r)
          return r.promise;
        var o = new Promise(function(t, e) {
          (0, y.addAppToUnload)(n, function() {
            return o;
          }, t, e);
        });
        return o;
      }
      var i = void 0;
      return r ? (i = r.promise, f(n, r.resolve, r.reject)) : i = new Promise(function(t, e) {
        (0, y.addAppToUnload)(n, function() {
          return i;
        }, t, e), f(n, t, e);
      }), i;
    }
    function f(t, e, n) {
      (0, m.toUnmountPromise)(t).then(y.toUnloadPromise).then(function() {
        e(), setTimeout(function() {
          (0, h.reroute)();
        });
      }).catch(n);
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.getMountedApps = r, e.getAppStatus = o, e.declareChildApplication = i, e.getAppsToLoad = u, e.getAppsToUnmount = a, e.getAppsToMount = c, e.unloadChildApplication = s;
    var l = n(27),
        p = n(46),
        d = n(2),
        h = n(19),
        v = n(29),
        m = n(45),
        y = n(44),
        g = [];
  }, function(t, e, n) {
    "use strict";
    function r(t) {
      return t && t.__esModule ? t : {default: t};
    }
    function o(t, e) {
      delete m[t.name], delete t.bootstrap, delete t.mount, delete t.unmount, delete t.unload, t.status = d.NOT_LOADED, e.resolve();
    }
    function i(t, e, n) {
      delete m[t.name], delete t.bootstrap, delete t.mount, delete t.unmount, delete t.unload, (0, h.handleChildAppError)(n, t), t.status = d.SKIP_BECAUSE_BROKEN, e.reject(n);
    }
    function u(t, e, n, r) {
      m[t.name] = {
        app: t,
        resolve: n,
        reject: r
      }, Object.defineProperty(m[t.name], "promise", {get: e});
    }
    function a(t) {
      return m[t];
    }
    function c() {
      return Object.keys(m).map(function(t) {
        return m[t].app;
      }).filter(d.isntActive);
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.toUnloadPromise = void 0;
    var s = n(13),
        f = r(s),
        l = n(12),
        p = r(l);
    e.toUnloadPromise = function() {
      var t = (0, p.default)(f.default.mark(function t(e) {
        var n;
        return f.default.wrap(function(t) {
          for (; ; )
            switch (t.prev = t.next) {
              case 0:
                if (n = m[e.name], e.status !== d.NOT_LOADED) {
                  t.next = 4;
                  break;
                }
                return o(e, n), t.abrupt("return", e);
              case 4:
                if (e.status !== d.UNLOADING) {
                  t.next = 8;
                  break;
                }
                return t.next = 7, n.promise;
              case 7:
                return t.abrupt("return", e);
              case 8:
                if (e.status === d.NOT_MOUNTED) {
                  t.next = 10;
                  break;
                }
                return t.abrupt("return", e);
              case 10:
                if (n) {
                  t.next = 12;
                  break;
                }
                return t.abrupt("return", e);
              case 12:
                return t.prev = 12, e.status = d.UNLOADING, t.next = 16, (0, v.reasonableTime)(e.unload({childAppName: e.name}), "Unloading application '" + e.name + "'", e.timeouts.unload);
              case 16:
                t.next = 22;
                break;
              case 18:
                return t.prev = 18, t.t0 = t.catch(12), i(e, n, t.t0), t.abrupt("return", e);
              case 22:
                return o(e, n), t.abrupt("return", e);
              case 24:
              case "end":
                return t.stop();
            }
        }, t, this, [[12, 18]]);
      }));
      return function(e) {
        return t.apply(this, arguments);
      };
    }();
    e.addAppToUnload = u, e.getAppUnloadInfo = a, e.getAppsToUnload = c;
    var d = n(2),
        h = n(10),
        v = n(11),
        m = {};
  }, function(t, e, n) {
    "use strict";
    function r(t) {
      return t && t.__esModule ? t : {default: t};
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.toUnmountPromise = void 0;
    var o = n(13),
        i = r(o),
        u = n(12),
        a = r(u),
        c = (e.toUnmountPromise = function() {
          var t = (0, a.default)(i.default.mark(function t(e) {
            return i.default.wrap(function(t) {
              for (; ; )
                switch (t.prev = t.next) {
                  case 0:
                    if (e.status === c.MOUNTED) {
                      t.next = 2;
                      break;
                    }
                    return t.abrupt("return", e);
                  case 2:
                    return e.status = c.UNMOUNTING, t.prev = 3, t.next = 6, (0, f.reasonableTime)(e.unmount({childAppName: e.name}), "Unmounting application " + e.name + "'", e.timeouts.unmount);
                  case 6:
                    e.status = c.NOT_MOUNTED, t.next = 13;
                    break;
                  case 9:
                    t.prev = 9, t.t0 = t.catch(3), (0, s.handleChildAppError)(t.t0, e), e.status = c.SKIP_BECAUSE_BROKEN;
                  case 13:
                    return t.abrupt("return", e);
                  case 14:
                  case "end":
                    return t.stop();
                }
            }, t, this, [[3, 9]]);
          }));
          return function(e) {
            return t.apply(this, arguments);
          };
        }(), n(2)),
        s = n(10),
        f = n(11);
  }, function(t, e, n) {
    "use strict";
    function r() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.jQuery;
      if (t || window.$ && window.$.fn && window.$.fn.jquery && (t = window.$), t && !u) {
        var e = t.fn.on,
            n = t.fn.off;
        t.fn.on = function(t, n) {
          return o.call(this, e, window.addEventListener, t, n, arguments);
        }, t.fn.off = function(t, e) {
          return o.call(this, n, window.removeEventListener, t, e, arguments);
        }, u = !0;
      }
    }
    function o(t, e, n, r, o) {
      return "string" != typeof n ? t.apply(this, o) : (n.split(/\s+/).forEach(function(t) {
        i.routingEventsListeningTo.indexOf(t) >= 0 && (e(t, r), n = n.replace(t, ""));
      }), "" === n.trim() ? this : t.apply(this, o));
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.ensureJQuerySupport = r;
    var i = n(28),
        u = !1;
  }, function(t, e, n) {
    "use strict";
    function r() {
      e.started = u = !0, (0, i.reroute)();
    }
    function o() {
      return u;
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.started = void 0, e.start = r, e.isStarted = o;
    var i = n(19),
        u = (n(27), e.started = !1);
    setTimeout(function() {
      u || console.warn("singleSpa.start() has not been called, 5000ms after single-spa was loaded. Before start() is called, child apps can be declared and loaded, but not bootstrapped or mounted. See https://github.com/CanopyTax/single-spa/blob/master/docs/single-spa-api.md#start");
    }, 5e3);
  }, function(t, e, n) {
    var r = n(14),
        o = n(0)("toStringTag"),
        i = "Arguments" == r(function() {
          return arguments;
        }()),
        u = function(t, e) {
          try {
            return t[e];
          } catch (t) {}
        };
    t.exports = function(t) {
      var e,
          n,
          a;
      return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof(n = u(e = Object(t), o)) ? n : i ? r(e) : "Object" == (a = r(e)) && "function" == typeof e.callee ? "Arguments" : a;
    };
  }, function(t, e, n) {
    t.exports = n(1).document && document.documentElement;
  }, function(t, e, n) {
    t.exports = !n(5) && !n(15)(function() {
      return 7 != Object.defineProperty(n(32)("div"), "a", {get: function() {
          return 7;
        }}).a;
    });
  }, function(t, e, n) {
    var r = n(14);
    t.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t) {
      return "String" == r(t) ? t.split("") : Object(t);
    };
  }, function(t, e, n) {
    "use strict";
    var r = n(22),
        o = n(21),
        i = n(56),
        u = n(7),
        a = n(6),
        c = n(17),
        s = n(86),
        f = n(25),
        l = n(96),
        p = n(0)("iterator"),
        d = !([].keys && "next" in [].keys()),
        h = function() {
          return this;
        };
    t.exports = function(t, e, n, v, m, y, g) {
      s(n, e, v);
      var b,
          w,
          O,
          _ = function(t) {
            if (!d && t in P)
              return P[t];
            switch (t) {
              case "keys":
              case "values":
                return function() {
                  return new n(this, t);
                };
            }
            return function() {
              return new n(this, t);
            };
          },
          x = e + " Iterator",
          E = "values" == m,
          T = !1,
          P = t.prototype,
          N = P[p] || P["@@iterator"] || m && P[m],
          j = N || _(m),
          A = m ? E ? _("entries") : j : void 0,
          S = "Array" == e ? P.entries || N : N;
      if (S && (O = l(S.call(new t))) !== Object.prototype && (f(O, x, !0), r || a(O, p) || u(O, p, h)), E && N && "values" !== N.name && (T = !0, j = function() {
        return N.call(this);
      }), r && !g || !d && !T && P[p] || u(P, p, j), c[e] = j, c[x] = h, m)
        if (b = {
          values: E ? j : _("values"),
          keys: y ? j : _("keys"),
          entries: A
        }, g)
          for (w in b)
            w in P || i(P, w, b[w]);
        else
          o(o.P + o.F * (d || T), e, b);
      return b;
    };
  }, function(t, e, n) {
    var r = n(4),
        o = n(93),
        i = n(33),
        u = n(35)("IE_PROTO"),
        a = function() {},
        c = function() {
          var t,
              e = n(32)("iframe"),
              r = i.length;
          for (e.style.display = "none", n(49).appendChild(e), e.src = "javascript:", t = e.contentWindow.document, t.open(), t.write("<script>document.F=Object<\/script>"), t.close(), c = t.F; r--; )
            delete c.prototype[i[r]];
          return c();
        };
    t.exports = Object.create || function(t, e) {
      var n;
      return null !== t ? (a.prototype = r(t), n = new a, a.prototype = null, n[u] = t) : n = c(), void 0 === e ? n : o(n, e);
    };
  }, function(t, e, n) {
    var r = n(55),
        o = n(33).concat("length", "prototype");
    e.f = Object.getOwnPropertyNames || function(t) {
      return r(t, o);
    };
  }, function(t, e, n) {
    var r = n(6),
        o = n(9),
        i = n(79)(!1),
        u = n(35)("IE_PROTO");
    t.exports = function(t, e) {
      var n,
          a = o(t),
          c = 0,
          s = [];
      for (n in a)
        n != u && r(a, n) && s.push(n);
      for (; e.length > c; )
        r(a, n = e[c++]) && (~i(s, n) || s.push(n));
      return s;
    };
  }, function(t, e, n) {
    t.exports = n(7);
  }, function(t, e, n) {
    var r,
        o,
        i,
        u = n(20),
        a = n(82),
        c = n(49),
        s = n(32),
        f = n(1),
        l = f.process,
        p = f.setImmediate,
        d = f.clearImmediate,
        h = f.MessageChannel,
        v = 0,
        m = {},
        y = function() {
          var t = +this;
          if (m.hasOwnProperty(t)) {
            var e = m[t];
            delete m[t], e();
          }
        },
        g = function(t) {
          y.call(t.data);
        };
    p && d || (p = function(t) {
      for (var e = [],
          n = 1; arguments.length > n; )
        e.push(arguments[n++]);
      return m[++v] = function() {
        a("function" == typeof t ? t : Function(t), e);
      }, r(v), v;
    }, d = function(t) {
      delete m[t];
    }, "process" == n(14)(l) ? r = function(t) {
      l.nextTick(u(y, t, 1));
    } : h ? (o = new h, i = o.port2, o.port1.onmessage = g, r = u(i.postMessage, i, 1)) : f.addEventListener && "function" == typeof postMessage && !f.importScripts ? (r = function(t) {
      f.postMessage(t + "", "*");
    }, f.addEventListener("message", g, !1)) : r = "onreadystatechange" in s("script") ? function(t) {
      c.appendChild(s("script")).onreadystatechange = function() {
        c.removeChild(this), y.call(t);
      };
    } : function(t) {
      setTimeout(u(y, t, 1), 0);
    }), t.exports = {
      set: p,
      clear: d
    };
  }, function(t, e, n) {
    var r = n(37),
        o = Math.min;
    t.exports = function(t) {
      return t > 0 ? o(r(t), 9007199254740991) : 0;
    };
  }, function(t, e, n) {
    var r = n(31);
    t.exports = function(t) {
      return Object(r(t));
    };
  }, function(t, e) {}, function(t, e, n) {
    "use strict";
    var r = n(100)(!0);
    n(52)(String, "String", function(t) {
      this._t = String(t), this._i = 0;
    }, function() {
      var t,
          e = this._t,
          n = this._i;
      return n >= e.length ? {
        value: void 0,
        done: !0
      } : (t = r(e, n), this._i += t.length, {
        value: t,
        done: !1
      });
    });
  }, function(t, e, n) {
    n(103);
    for (var r = n(1),
        o = n(7),
        i = n(17),
        u = n(0)("toStringTag"),
        a = ["NodeList", "DOMTokenList", "MediaList", "StyleSheetList", "CSSRuleList"],
        c = 0; c < 5; c++) {
      var s = a[c],
          f = r[s],
          l = f && f.prototype;
      l && !l[u] && o(l, u, s), i[s] = i.Array;
    }
  }, function(t, e, n) {
    "use strict";
    Object.defineProperty(e, "__esModule", {value: !0});
    var r = n(47);
    Object.defineProperty(e, "start", {
      enumerable: !0,
      get: function() {
        return r.start;
      }
    });
    var o = n(46);
    Object.defineProperty(e, "ensureJQuerySupport", {
      enumerable: !0,
      get: function() {
        return o.ensureJQuerySupport;
      }
    });
    var i = n(11);
    Object.defineProperty(e, "setBootstrapMaxTime", {
      enumerable: !0,
      get: function() {
        return i.setBootstrapMaxTime;
      }
    }), Object.defineProperty(e, "setMountMaxTime", {
      enumerable: !0,
      get: function() {
        return i.setMountMaxTime;
      }
    }), Object.defineProperty(e, "setUnmountMaxTime", {
      enumerable: !0,
      get: function() {
        return i.setUnmountMaxTime;
      }
    }), Object.defineProperty(e, "setUnloadMaxTime", {
      enumerable: !0,
      get: function() {
        return i.setUnloadMaxTime;
      }
    });
    var u = n(43);
    Object.defineProperty(e, "declareChildApplication", {
      enumerable: !0,
      get: function() {
        return u.declareChildApplication;
      }
    }), Object.defineProperty(e, "getMountedApps", {
      enumerable: !0,
      get: function() {
        return u.getMountedApps;
      }
    }), Object.defineProperty(e, "getAppStatus", {
      enumerable: !0,
      get: function() {
        return u.getAppStatus;
      }
    }), Object.defineProperty(e, "unloadChildApplication", {
      enumerable: !0,
      get: function() {
        return u.unloadChildApplication;
      }
    });
    var a = n(28);
    Object.defineProperty(e, "navigateToUrl", {
      enumerable: !0,
      get: function() {
        return a.navigateToUrl;
      }
    });
    var c = n(19);
    Object.defineProperty(e, "triggerAppChange", {
      enumerable: !0,
      get: function() {
        return c.reroute;
      }
    });
    var s = n(27);
    Object.defineProperty(e, "setLoader", {
      enumerable: !0,
      get: function() {
        return s.setLoader;
      }
    });
    var f = n(2);
    Object.defineProperty(e, "NOT_LOADED", {
      enumerable: !0,
      get: function() {
        return f.NOT_LOADED;
      }
    }), Object.defineProperty(e, "LOADING_SOURCE_CODE", {
      enumerable: !0,
      get: function() {
        return f.LOADING_SOURCE_CODE;
      }
    }), Object.defineProperty(e, "NOT_BOOTSTRAPPED", {
      enumerable: !0,
      get: function() {
        return f.NOT_BOOTSTRAPPED;
      }
    }), Object.defineProperty(e, "BOOTSTRAPPING", {
      enumerable: !0,
      get: function() {
        return f.BOOTSTRAPPING;
      }
    }), Object.defineProperty(e, "NOT_MOUNTED", {
      enumerable: !0,
      get: function() {
        return f.NOT_MOUNTED;
      }
    }), Object.defineProperty(e, "MOUNTING", {
      enumerable: !0,
      get: function() {
        return f.MOUNTING;
      }
    }), Object.defineProperty(e, "MOUNTED", {
      enumerable: !0,
      get: function() {
        return f.MOUNTED;
      }
    }), Object.defineProperty(e, "UNMOUNTING", {
      enumerable: !0,
      get: function() {
        return f.UNMOUNTING;
      }
    }), Object.defineProperty(e, "SKIP_BECAUSE_BROKEN", {
      enumerable: !0,
      get: function() {
        return f.SKIP_BECAUSE_BROKEN;
      }
    });
  }, function(t, e, n) {
    "use strict";
    function r(t) {
      return t && t.__esModule ? t : {default: t};
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.toBootstrapPromise = void 0;
    var o = n(13),
        i = r(o),
        u = n(12),
        a = r(u),
        c = (e.toBootstrapPromise = function() {
          var t = (0, a.default)(i.default.mark(function t(e) {
            return i.default.wrap(function(t) {
              for (; ; )
                switch (t.prev = t.next) {
                  case 0:
                    if (e.status === c.NOT_BOOTSTRAPPED) {
                      t.next = 2;
                      break;
                    }
                    return t.abrupt("return", e);
                  case 2:
                    return e.status = c.BOOTSTRAPPING, t.prev = 3, t.next = 6, (0, s.reasonableTime)(e.bootstrap({childAppName: e.name}), "Bootstrapping app '" + e.name + "'", e.timeouts.bootstrap);
                  case 6:
                    e.status = c.NOT_MOUNTED, t.next = 13;
                    break;
                  case 9:
                    t.prev = 9, t.t0 = t.catch(3), e.status = c.SKIP_BECAUSE_BROKEN, (0, f.handleChildAppError)(t.t0, e);
                  case 13:
                    return t.abrupt("return", e);
                  case 14:
                  case "end":
                    return t.stop();
                }
            }, t, this, [[3, 9]]);
          }));
          return function(e) {
            return t.apply(this, arguments);
          };
        }(), n(2)),
        s = n(11),
        f = n(10);
  }, function(t, e, n) {
    "use strict";
    function r(t) {
      return t && t.__esModule ? t : {default: t};
    }
    function o(t) {
      return t && ("function" == typeof t || function(t) {
        return Array.isArray(t) && !(0, m.find)(t, function(t) {
          return "function" != typeof t;
        });
      }(t));
    }
    function i(t, e) {
      return t = Array.isArray(t) ? t : [t], 0 === t.length && (t = [function() {
        return Promise.resolve();
      }]), function(n) {
        return new Promise(function(r, o) {
          function i(a) {
            var c = t[a](n);
            u(c) ? c.then(function() {
              a === t.length - 1 ? r() : i(a + 1);
            }).catch(o) : o(e + " at index " + a + " did not return a promise");
          }
          i(0);
        });
      };
    }
    function u(t) {
      return t && "function" == typeof t.then && "function" == typeof t.catch;
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.toLoadPromise = void 0;
    var a = n(13),
        c = r(a),
        s = n(72),
        f = r(s),
        l = n(12),
        p = r(l),
        d = (e.toLoadPromise = function() {
          var t = (0, p.default)(c.default.mark(function t(e) {
            var n,
                r,
                a;
            return c.default.wrap(function(t) {
              for (; ; )
                switch (t.prev = t.next) {
                  case 0:
                    if (e.status === d.NOT_LOADED) {
                      t.next = 2;
                      break;
                    }
                    return t.abrupt("return", e);
                  case 2:
                    if (e.status = d.LOADING_SOURCE_CODE, n = void 0, t.prev = 4, r = e.loadImpl({childAppName: e.name}), u(r)) {
                      t.next = 8;
                      break;
                    }
                    throw new Error("single-spa loading function did not return a promise. Check the second argument to declareChildApplication('" + e.name + "', loadingFunction, activityFunction)");
                  case 8:
                    return t.next = 10, r;
                  case 10:
                    n = t.sent, t.next = 18;
                    break;
                  case 13:
                    return t.prev = 13, t.t0 = t.catch(4), (0, v.handleChildAppError)(t.t0, e), e.status = d.SKIP_BECAUSE_BROKEN, t.abrupt("return", e);
                  case 18:
                    if (a = void 0, "object" !== (void 0 === n ? "undefined" : (0, f.default)(n)) && (a = "does not export anything"), o(n.bootstrap) || (a = "does not export a bootstrap function or array of functions"), o(n.mount) || (a = "does not export a mount function or array of functions"), o(n.unmount) || (a = "does not export an unmount function or array of functions"), !a) {
                      t.next = 27;
                      break;
                    }
                    return (0, v.handleChildAppError)(a, e), e.status = d.SKIP_BECAUSE_BROKEN, t.abrupt("return", e);
                  case 27:
                    return e.status = d.NOT_BOOTSTRAPPED, e.bootstrap = i(n.bootstrap, "App '" + e.name + "' bootstrap function"), e.mount = i(n.mount, "App '" + e.name + "' mount function"), e.unmount = i(n.unmount, "App '" + e.name + "' unmount function"), e.unload = i(n.unload || [], "App '" + e.name + "' unload function"), e.timeouts = (0, h.ensureValidAppTimeouts)(n.timeouts), t.abrupt("return", e);
                  case 34:
                  case "end":
                    return t.stop();
                }
            }, t, this, [[4, 13]]);
          }));
          return function(e) {
            return t.apply(this, arguments);
          };
        }(), n(2)),
        h = n(11),
        v = n(10),
        m = n(29);
  }, function(t, e, n) {
    "use strict";
    function r(t) {
      return t && t.__esModule ? t : {default: t};
    }
    Object.defineProperty(e, "__esModule", {value: !0}), e.toMountPromise = void 0;
    var o = n(13),
        i = r(o),
        u = n(12),
        a = r(u),
        c = (e.toMountPromise = function() {
          var t = (0, a.default)(i.default.mark(function t(e) {
            return i.default.wrap(function(t) {
              for (; ; )
                switch (t.prev = t.next) {
                  case 0:
                    if (e.status === c.NOT_MOUNTED) {
                      t.next = 2;
                      break;
                    }
                    return t.abrupt("return", e);
                  case 2:
                    return d || (window.dispatchEvent(new p.default("single-spa:before-first-mount")), d = !0), t.prev = 3, t.next = 6, (0, f.reasonableTime)(e.mount({childAppName: e.name}), "Mounting application '" + e.name + "'", e.timeouts.mount);
                  case 6:
                    e.status = c.MOUNTED, t.next = 13;
                    break;
                  case 9:
                    t.prev = 9, t.t0 = t.catch(3), (0, s.handleChildAppError)(t.t0, e), e.status = c.SKIP_BECAUSE_BROKEN;
                  case 13:
                    return h || (window.dispatchEvent(new p.default("single-spa:first-mount")), h = !0), t.abrupt("return", e);
                  case 15:
                  case "end":
                    return t.stop();
                }
            }, t, this, [[3, 9]]);
          }));
          return function(e) {
            return t.apply(this, arguments);
          };
        }(), n(2)),
        s = n(10),
        f = n(11),
        l = n(41),
        p = r(l),
        d = !1,
        h = !1;
  }, function(t, e, n) {
    t.exports = {
      default: n(73),
      __esModule: !0
    };
  }, function(t, e, n) {
    t.exports = {
      default: n(74),
      __esModule: !0
    };
  }, function(t, e, n) {
    t.exports = {
      default: n(75),
      __esModule: !0
    };
  }, function(t, e, n) {
    t.exports = {
      default: n(76),
      __esModule: !0
    };
  }, function(t, e, n) {
    "use strict";
    e.__esModule = !0;
    var r = n(67),
        o = function(t) {
          return t && t.__esModule ? t : {default: t};
        }(r);
    e.default = o.default || function(t) {
      for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e];
        for (var r in n)
          Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
      }
      return t;
    };
  }, function(t, e, n) {
    "use strict";
    function r(t) {
      return t && t.__esModule ? t : {default: t};
    }
    e.__esModule = !0;
    var o = n(70),
        i = r(o),
        u = n(69),
        a = r(u),
        c = "function" == typeof a.default && "symbol" == typeof i.default ? function(t) {
          return typeof t;
        } : function(t) {
          return t && "function" == typeof a.default && t.constructor === a.default && t !== a.default.prototype ? "symbol" : typeof t;
        };
    e.default = "function" == typeof a.default && "symbol" === c(i.default) ? function(t) {
      return void 0 === t ? "undefined" : c(t);
    } : function(t) {
      return t && "function" == typeof a.default && t.constructor === a.default && t !== a.default.prototype ? "symbol" : void 0 === t ? "undefined" : c(t);
    };
  }, function(t, e, n) {
    n(104), t.exports = n(3).Object.assign;
  }, function(t, e, n) {
    n(60), n(61), n(62), n(105), t.exports = n(3).Promise;
  }, function(t, e, n) {
    n(106), n(60), n(107), n(108), t.exports = n(3).Symbol;
  }, function(t, e, n) {
    n(61), n(62), t.exports = n(40).f("iterator");
  }, function(t, e) {
    t.exports = function() {};
  }, function(t, e) {
    t.exports = function(t, e, n, r) {
      if (!(t instanceof e) || void 0 !== r && r in t)
        throw TypeError(n + ": incorrect invocation!");
      return t;
    };
  }, function(t, e, n) {
    var r = n(9),
        o = n(58),
        i = n(101);
    t.exports = function(t) {
      return function(e, n, u) {
        var a,
            c = r(e),
            s = o(c.length),
            f = i(u, s);
        if (t && n != n) {
          for (; s > f; )
            if ((a = c[f++]) != a)
              return !0;
        } else
          for (; s > f; f++)
            if ((t || f in c) && c[f] === n)
              return t || f || 0;
        return !t && -1;
      };
    };
  }, function(t, e, n) {
    var r = n(18),
        o = n(34),
        i = n(23);
    t.exports = function(t) {
      var e = r(t),
          n = o.f;
      if (n)
        for (var u,
            a = n(t),
            c = i.f,
            s = 0; a.length > s; )
          c.call(t, u = a[s++]) && e.push(u);
      return e;
    };
  }, function(t, e, n) {
    var r = n(20),
        o = n(85),
        i = n(83),
        u = n(4),
        a = n(58),
        c = n(102),
        s = {},
        f = {},
        e = t.exports = function(t, e, n, l, p) {
          var d,
              h,
              v,
              m,
              y = p ? function() {
                return t;
              } : c(t),
              g = r(n, l, e ? 2 : 1),
              b = 0;
          if ("function" != typeof y)
            throw TypeError(t + " is not iterable!");
          if (i(y)) {
            for (d = a(t.length); d > b; b++)
              if ((m = e ? g(u(h = t[b])[0], h[1]) : g(t[b])) === s || m === f)
                return m;
          } else
            for (v = y.call(t); !(h = v.next()).done; )
              if ((m = o(v, g, h.value, e)) === s || m === f)
                return m;
        };
    e.BREAK = s, e.RETURN = f;
  }, function(t, e) {
    t.exports = function(t, e, n) {
      var r = void 0 === n;
      switch (e.length) {
        case 0:
          return r ? t() : t.call(n);
        case 1:
          return r ? t(e[0]) : t.call(n, e[0]);
        case 2:
          return r ? t(e[0], e[1]) : t.call(n, e[0], e[1]);
        case 3:
          return r ? t(e[0], e[1], e[2]) : t.call(n, e[0], e[1], e[2]);
        case 4:
          return r ? t(e[0], e[1], e[2], e[3]) : t.call(n, e[0], e[1], e[2], e[3]);
      }
      return t.apply(n, e);
    };
  }, function(t, e, n) {
    var r = n(17),
        o = n(0)("iterator"),
        i = Array.prototype;
    t.exports = function(t) {
      return void 0 !== t && (r.Array === t || i[o] === t);
    };
  }, function(t, e, n) {
    var r = n(14);
    t.exports = Array.isArray || function(t) {
      return "Array" == r(t);
    };
  }, function(t, e, n) {
    var r = n(4);
    t.exports = function(t, e, n, o) {
      try {
        return o ? e(r(n)[0], n[1]) : e(n);
      } catch (e) {
        var i = t.return;
        throw void 0 !== i && r(i.call(t)), e;
      }
    };
  }, function(t, e, n) {
    "use strict";
    var r = n(53),
        o = n(24),
        i = n(25),
        u = {};
    n(7)(u, n(0)("iterator"), function() {
      return this;
    }), t.exports = function(t, e, n) {
      t.prototype = r(u, {next: o(1, n)}), i(t, e + " Iterator");
    };
  }, function(t, e, n) {
    var r = n(0)("iterator"),
        o = !1;
    try {
      var i = [7][r]();
      i.return = function() {
        o = !0;
      }, Array.from(i, function() {
        throw 2;
      });
    } catch (t) {}
    t.exports = function(t, e) {
      if (!e && !o)
        return !1;
      var n = !1;
      try {
        var i = [7],
            u = i[r]();
        u.next = function() {
          return {done: n = !0};
        }, i[r] = function() {
          return u;
        }, t(i);
      } catch (t) {}
      return n;
    };
  }, function(t, e) {
    t.exports = function(t, e) {
      return {
        value: e,
        done: !!t
      };
    };
  }, function(t, e, n) {
    var r = n(18),
        o = n(9);
    t.exports = function(t, e) {
      for (var n,
          i = o(t),
          u = r(i),
          a = u.length,
          c = 0; a > c; )
        if (i[n = u[c++]] === e)
          return n;
    };
  }, function(t, e, n) {
    var r = n(26)("meta"),
        o = n(16),
        i = n(6),
        u = n(8).f,
        a = 0,
        c = Object.isExtensible || function() {
          return !0;
        },
        s = !n(15)(function() {
          return c(Object.preventExtensions({}));
        }),
        f = function(t) {
          u(t, r, {value: {
              i: "O" + ++a,
              w: {}
            }});
        },
        l = function(t, e) {
          if (!o(t))
            return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
          if (!i(t, r)) {
            if (!c(t))
              return "F";
            if (!e)
              return "E";
            f(t);
          }
          return t[r].i;
        },
        p = function(t, e) {
          if (!i(t, r)) {
            if (!c(t))
              return !0;
            if (!e)
              return !1;
            f(t);
          }
          return t[r].w;
        },
        d = function(t) {
          return s && h.NEED && c(t) && !i(t, r) && f(t), t;
        },
        h = t.exports = {
          KEY: r,
          NEED: !1,
          fastKey: l,
          getWeak: p,
          onFreeze: d
        };
  }, function(t, e, n) {
    var r = n(1),
        o = n(57).set,
        i = r.MutationObserver || r.WebKitMutationObserver,
        u = r.process,
        a = r.Promise,
        c = "process" == n(14)(u);
    t.exports = function() {
      var t,
          e,
          n,
          s = function() {
            var r,
                o;
            for (c && (r = u.domain) && r.exit(); t; ) {
              o = t.fn, t = t.next;
              try {
                o();
              } catch (r) {
                throw t ? n() : e = void 0, r;
              }
            }
            e = void 0, r && r.enter();
          };
      if (c)
        n = function() {
          u.nextTick(s);
        };
      else if (i) {
        var f = !0,
            l = document.createTextNode("");
        new i(s).observe(l, {characterData: !0}), n = function() {
          l.data = f = !f;
        };
      } else if (a && a.resolve) {
        var p = a.resolve();
        n = function() {
          p.then(s);
        };
      } else
        n = function() {
          o.call(r, s);
        };
      return function(r) {
        var o = {
          fn: r,
          next: void 0
        };
        e && (e.next = o), t || (t = o, n()), e = o;
      };
    };
  }, function(t, e, n) {
    "use strict";
    var r = n(18),
        o = n(34),
        i = n(23),
        u = n(59),
        a = n(51),
        c = Object.assign;
    t.exports = !c || n(15)(function() {
      var t = {},
          e = {},
          n = Symbol(),
          r = "abcdefghijklmnopqrst";
      return t[n] = 7, r.split("").forEach(function(t) {
        e[t] = t;
      }), 7 != c({}, t)[n] || Object.keys(c({}, e)).join("") != r;
    }) ? function(t, e) {
      for (var n = u(t),
          c = arguments.length,
          s = 1,
          f = o.f,
          l = i.f; c > s; )
        for (var p,
            d = a(arguments[s++]),
            h = f ? r(d).concat(f(d)) : r(d),
            v = h.length,
            m = 0; v > m; )
          l.call(d, p = h[m++]) && (n[p] = d[p]);
      return n;
    } : c;
  }, function(t, e, n) {
    var r = n(8),
        o = n(4),
        i = n(18);
    t.exports = n(5) ? Object.defineProperties : function(t, e) {
      o(t);
      for (var n,
          u = i(e),
          a = u.length,
          c = 0; a > c; )
        r.f(t, n = u[c++], e[n]);
      return t;
    };
  }, function(t, e, n) {
    var r = n(23),
        o = n(24),
        i = n(9),
        u = n(38),
        a = n(6),
        c = n(50),
        s = Object.getOwnPropertyDescriptor;
    e.f = n(5) ? s : function(t, e) {
      if (t = i(t), e = u(e, !0), c)
        try {
          return s(t, e);
        } catch (t) {}
      if (a(t, e))
        return o(!r.f.call(t, e), t[e]);
    };
  }, function(t, e, n) {
    var r = n(9),
        o = n(54).f,
        i = {}.toString,
        u = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
        a = function(t) {
          try {
            return o(t);
          } catch (t) {
            return u.slice();
          }
        };
    t.exports.f = function(t) {
      return u && "[object Window]" == i.call(t) ? a(t) : o(r(t));
    };
  }, function(t, e, n) {
    var r = n(6),
        o = n(59),
        i = n(35)("IE_PROTO"),
        u = Object.prototype;
    t.exports = Object.getPrototypeOf || function(t) {
      return t = o(t), r(t, i) ? t[i] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? u : null;
    };
  }, function(t, e, n) {
    var r = n(7);
    t.exports = function(t, e, n) {
      for (var o in e)
        n && t[o] ? t[o] = e[o] : r(t, o, e[o]);
      return t;
    };
  }, function(t, e, n) {
    "use strict";
    var r = n(1),
        o = n(3),
        i = n(8),
        u = n(5),
        a = n(0)("species");
    t.exports = function(t) {
      var e = "function" == typeof o[t] ? o[t] : r[t];
      u && e && !e[a] && i.f(e, a, {
        configurable: !0,
        get: function() {
          return this;
        }
      });
    };
  }, function(t, e, n) {
    var r = n(4),
        o = n(30),
        i = n(0)("species");
    t.exports = function(t, e) {
      var n,
          u = r(t).constructor;
      return void 0 === u || void 0 == (n = r(u)[i]) ? e : o(n);
    };
  }, function(t, e, n) {
    var r = n(37),
        o = n(31);
    t.exports = function(t) {
      return function(e, n) {
        var i,
            u,
            a = String(o(e)),
            c = r(n),
            s = a.length;
        return c < 0 || c >= s ? t ? "" : void 0 : (i = a.charCodeAt(c), i < 55296 || i > 56319 || c + 1 === s || (u = a.charCodeAt(c + 1)) < 56320 || u > 57343 ? t ? a.charAt(c) : i : t ? a.slice(c, c + 2) : u - 56320 + (i - 55296 << 10) + 65536);
      };
    };
  }, function(t, e, n) {
    var r = n(37),
        o = Math.max,
        i = Math.min;
    t.exports = function(t, e) {
      return t = r(t), t < 0 ? o(t + e, 0) : i(t, e);
    };
  }, function(t, e, n) {
    var r = n(48),
        o = n(0)("iterator"),
        i = n(17);
    t.exports = n(3).getIteratorMethod = function(t) {
      if (void 0 != t)
        return t[o] || t["@@iterator"] || i[r(t)];
    };
  }, function(t, e, n) {
    "use strict";
    var r = n(77),
        o = n(88),
        i = n(17),
        u = n(9);
    t.exports = n(52)(Array, "Array", function(t, e) {
      this._t = u(t), this._i = 0, this._k = e;
    }, function() {
      var t = this._t,
          e = this._k,
          n = this._i++;
      return !t || n >= t.length ? (this._t = void 0, o(1)) : "keys" == e ? o(0, n) : "values" == e ? o(0, t[n]) : o(0, [n, t[n]]);
    }, "values"), i.Arguments = i.Array, r("keys"), r("values"), r("entries");
  }, function(t, e, n) {
    var r = n(21);
    r(r.S + r.F, "Object", {assign: n(92)});
  }, function(t, e, n) {
    "use strict";
    var r,
        o,
        i,
        u = n(22),
        a = n(1),
        c = n(20),
        s = n(48),
        f = n(21),
        l = n(16),
        p = n(30),
        d = n(78),
        h = n(81),
        v = n(99),
        m = n(57).set,
        y = n(91)(),
        g = a.TypeError,
        b = a.process,
        w = a.Promise,
        b = a.process,
        O = "process" == s(b),
        _ = function() {},
        x = !!function() {
          try {
            var t = w.resolve(1),
                e = (t.constructor = {})[n(0)("species")] = function(t) {
                  t(_, _);
                };
            return (O || "function" == typeof PromiseRejectionEvent) && t.then(_) instanceof e;
          } catch (t) {}
        }(),
        E = function(t, e) {
          return t === e || t === w && e === i;
        },
        T = function(t) {
          var e;
          return !(!l(t) || "function" != typeof(e = t.then)) && e;
        },
        P = function(t) {
          return E(w, t) ? new N(t) : new o(t);
        },
        N = o = function(t) {
          var e,
              n;
          this.promise = new t(function(t, r) {
            if (void 0 !== e || void 0 !== n)
              throw g("Bad Promise constructor");
            e = t, n = r;
          }), this.resolve = p(e), this.reject = p(n);
        },
        j = function(t) {
          try {
            t();
          } catch (t) {
            return {error: t};
          }
        },
        A = function(t, e) {
          if (!t._n) {
            t._n = !0;
            var n = t._c;
            y(function() {
              for (var r = t._v,
                  o = 1 == t._s,
                  i = 0; n.length > i; )
                !function(e) {
                  var n,
                      i,
                      u = o ? e.ok : e.fail,
                      a = e.resolve,
                      c = e.reject,
                      s = e.domain;
                  try {
                    u ? (o || (2 == t._h && L(t), t._h = 1), !0 === u ? n = r : (s && s.enter(), n = u(r), s && s.exit()), n === e.promise ? c(g("Promise-chain cycle")) : (i = T(n)) ? i.call(n, a, c) : a(n)) : c(r);
                  } catch (t) {
                    c(t);
                  }
                }(n[i++]);
              t._c = [], t._n = !1, e && !t._h && S(t);
            });
          }
        },
        S = function(t) {
          m.call(a, function() {
            var e,
                n,
                r,
                o = t._v;
            if (M(t) && (e = j(function() {
              O ? b.emit("unhandledRejection", o, t) : (n = a.onunhandledrejection) ? n({
                promise: t,
                reason: o
              }) : (r = a.console) && r.error && r.error("Unhandled promise rejection", o);
            }), t._h = O || M(t) ? 2 : 1), t._a = void 0, e)
              throw e.error;
          });
        },
        M = function(t) {
          if (1 == t._h)
            return !1;
          for (var e,
              n = t._a || t._c,
              r = 0; n.length > r; )
            if (e = n[r++], e.fail || !M(e.promise))
              return !1;
          return !0;
        },
        L = function(t) {
          m.call(a, function() {
            var e;
            O ? b.emit("rejectionHandled", t) : (e = a.onrejectionhandled) && e({
              promise: t,
              reason: t._v
            });
          });
        },
        U = function(t) {
          var e = this;
          e._d || (e._d = !0, e = e._w || e, e._v = t, e._s = 2, e._a || (e._a = e._c.slice()), A(e, !0));
        },
        k = function(t) {
          var e,
              n = this;
          if (!n._d) {
            n._d = !0, n = n._w || n;
            try {
              if (n === t)
                throw g("Promise can't be resolved itself");
              (e = T(t)) ? y(function() {
                var r = {
                  _w: n,
                  _d: !1
                };
                try {
                  e.call(t, c(k, r, 1), c(U, r, 1));
                } catch (t) {
                  U.call(r, t);
                }
              }) : (n._v = t, n._s = 1, A(n, !1));
            } catch (t) {
              U.call({
                _w: n,
                _d: !1
              }, t);
            }
          }
        };
    x || (w = function(t) {
      d(this, w, "Promise", "_h"), p(t), r.call(this);
      try {
        t(c(k, this, 1), c(U, this, 1));
      } catch (t) {
        U.call(this, t);
      }
    }, r = function(t) {
      this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1;
    }, r.prototype = n(97)(w.prototype, {
      then: function(t, e) {
        var n = P(v(this, w));
        return n.ok = "function" != typeof t || t, n.fail = "function" == typeof e && e, n.domain = O ? b.domain : void 0, this._c.push(n), this._a && this._a.push(n), this._s && A(this, !1), n.promise;
      },
      catch: function(t) {
        return this.then(void 0, t);
      }
    }), N = function() {
      var t = new r;
      this.promise = t, this.resolve = c(k, t, 1), this.reject = c(U, t, 1);
    }), f(f.G + f.W + f.F * !x, {Promise: w}), n(25)(w, "Promise"), n(98)("Promise"), i = n(3).Promise, f(f.S + f.F * !x, "Promise", {reject: function(t) {
        var e = P(this);
        return (0, e.reject)(t), e.promise;
      }}), f(f.S + f.F * (u || !x), "Promise", {resolve: function(t) {
        if (t instanceof w && E(t.constructor, this))
          return t;
        var e = P(this);
        return (0, e.resolve)(t), e.promise;
      }}), f(f.S + f.F * !(x && n(87)(function(t) {
      w.all(t).catch(_);
    })), "Promise", {
      all: function(t) {
        var e = this,
            n = P(e),
            r = n.resolve,
            o = n.reject,
            i = j(function() {
              var n = [],
                  i = 0,
                  u = 1;
              h(t, !1, function(t) {
                var a = i++,
                    c = !1;
                n.push(void 0), u++, e.resolve(t).then(function(t) {
                  c || (c = !0, n[a] = t, --u || r(n));
                }, o);
              }), --u || r(n);
            });
        return i && o(i.error), n.promise;
      },
      race: function(t) {
        var e = this,
            n = P(e),
            r = n.reject,
            o = j(function() {
              h(t, !1, function(t) {
                e.resolve(t).then(n.resolve, r);
              });
            });
        return o && r(o.error), n.promise;
      }
    });
  }, function(t, e, n) {
    "use strict";
    var r = n(1),
        o = n(6),
        i = n(5),
        u = n(21),
        a = n(56),
        c = n(90).KEY,
        s = n(15),
        f = n(36),
        l = n(25),
        p = n(26),
        d = n(0),
        h = n(40),
        v = n(39),
        m = n(89),
        y = n(80),
        g = n(84),
        b = n(4),
        w = n(9),
        O = n(38),
        _ = n(24),
        x = n(53),
        E = n(95),
        T = n(94),
        P = n(8),
        N = n(18),
        j = T.f,
        A = P.f,
        S = E.f,
        M = r.Symbol,
        L = r.JSON,
        U = L && L.stringify,
        k = d("_hidden"),
        D = d("toPrimitive"),
        C = {}.propertyIsEnumerable,
        I = f("symbol-registry"),
        B = f("symbols"),
        R = f("op-symbols"),
        G = Object.prototype,
        F = "function" == typeof M,
        K = r.QObject,
        W = !K || !K.prototype || !K.prototype.findChild,
        q = i && s(function() {
          return 7 != x(A({}, "a", {get: function() {
              return A(this, "a", {value: 7}).a;
            }})).a;
        }) ? function(t, e, n) {
          var r = j(G, e);
          r && delete G[e], A(t, e, n), r && t !== G && A(G, e, r);
        } : A,
        J = function(t) {
          var e = B[t] = x(M.prototype);
          return e._k = t, e;
        },
        Q = F && "symbol" == typeof M.iterator ? function(t) {
          return "symbol" == typeof t;
        } : function(t) {
          return t instanceof M;
        },
        Y = function(t, e, n) {
          return t === G && Y(R, e, n), b(t), e = O(e, !0), b(n), o(B, e) ? (n.enumerable ? (o(t, k) && t[k][e] && (t[k][e] = !1), n = x(n, {enumerable: _(0, !1)})) : (o(t, k) || A(t, k, _(1, {})), t[k][e] = !0), q(t, e, n)) : A(t, e, n);
        },
        $ = function(t, e) {
          b(t);
          for (var n,
              r = y(e = w(e)),
              o = 0,
              i = r.length; i > o; )
            Y(t, n = r[o++], e[n]);
          return t;
        },
        z = function(t, e) {
          return void 0 === e ? x(t) : $(x(t), e);
        },
        V = function(t) {
          var e = C.call(this, t = O(t, !0));
          return !(this === G && o(B, t) && !o(R, t)) && (!(e || !o(this, t) || !o(B, t) || o(this, k) && this[k][t]) || e);
        },
        H = function(t, e) {
          if (t = w(t), e = O(e, !0), t !== G || !o(B, e) || o(R, e)) {
            var n = j(t, e);
            return !n || !o(B, e) || o(t, k) && t[k][e] || (n.enumerable = !0), n;
          }
        },
        X = function(t) {
          for (var e,
              n = S(w(t)),
              r = [],
              i = 0; n.length > i; )
            o(B, e = n[i++]) || e == k || e == c || r.push(e);
          return r;
        },
        Z = function(t) {
          for (var e,
              n = t === G,
              r = S(n ? R : w(t)),
              i = [],
              u = 0; r.length > u; )
            !o(B, e = r[u++]) || n && !o(G, e) || i.push(B[e]);
          return i;
        };
    F || (M = function() {
      if (this instanceof M)
        throw TypeError("Symbol is not a constructor!");
      var t = p(arguments.length > 0 ? arguments[0] : void 0),
          e = function(n) {
            this === G && e.call(R, n), o(this, k) && o(this[k], t) && (this[k][t] = !1), q(this, t, _(1, n));
          };
      return i && W && q(G, t, {
        configurable: !0,
        set: e
      }), J(t);
    }, a(M.prototype, "toString", function() {
      return this._k;
    }), T.f = H, P.f = Y, n(54).f = E.f = X, n(23).f = V, n(34).f = Z, i && !n(22) && a(G, "propertyIsEnumerable", V, !0), h.f = function(t) {
      return J(d(t));
    }), u(u.G + u.W + u.F * !F, {Symbol: M});
    for (var tt = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),
        et = 0; tt.length > et; )
      d(tt[et++]);
    for (var tt = N(d.store),
        et = 0; tt.length > et; )
      v(tt[et++]);
    u(u.S + u.F * !F, "Symbol", {
      for: function(t) {
        return o(I, t += "") ? I[t] : I[t] = M(t);
      },
      keyFor: function(t) {
        if (Q(t))
          return m(I, t);
        throw TypeError(t + " is not a symbol!");
      },
      useSetter: function() {
        W = !0;
      },
      useSimple: function() {
        W = !1;
      }
    }), u(u.S + u.F * !F, "Object", {
      create: z,
      defineProperty: Y,
      defineProperties: $,
      getOwnPropertyDescriptor: H,
      getOwnPropertyNames: X,
      getOwnPropertySymbols: Z
    }), L && u(u.S + u.F * (!F || s(function() {
      var t = M();
      return "[null]" != U([t]) || "{}" != U({a: t}) || "{}" != U(Object(t));
    })), "JSON", {stringify: function(t) {
        if (void 0 !== t && !Q(t)) {
          for (var e,
              n,
              r = [t],
              o = 1; arguments.length > o; )
            r.push(arguments[o++]);
          return e = r[1], "function" == typeof e && (n = e), !n && g(e) || (e = function(t, e) {
            if (n && (e = n.call(this, t, e)), !Q(e))
              return e;
          }), r[1] = e, U.apply(L, r);
        }
      }}), M.prototype[D] || n(7)(M.prototype, D, M.prototype.valueOf), l(M, "Symbol"), l(Math, "Math", !0), l(r.JSON, "JSON", !0);
  }, function(t, e, n) {
    n(39)("asyncIterator");
  }, function(t, e, n) {
    n(39)("observable");
  }, function(t, e, n) {
    (function(e) {
      var r = "object" == typeof e ? e : "object" == typeof window ? window : "object" == typeof self ? self : this,
          o = r.regeneratorRuntime && Object.getOwnPropertyNames(r).indexOf("regeneratorRuntime") >= 0,
          i = o && r.regeneratorRuntime;
      if (r.regeneratorRuntime = void 0, t.exports = n(110), o)
        r.regeneratorRuntime = i;
      else
        try {
          delete r.regeneratorRuntime;
        } catch (t) {
          r.regeneratorRuntime = void 0;
        }
    }).call(e, n(42));
  }, function(t, e, n) {
    (function(e) {
      !function(e) {
        "use strict";
        function n(t, e, n, r) {
          var i = e && e.prototype instanceof o ? e : o,
              u = Object.create(i.prototype),
              a = new d(r || []);
          return u._invoke = s(t, n, a), u;
        }
        function r(t, e, n) {
          try {
            return {
              type: "normal",
              arg: t.call(e, n)
            };
          } catch (t) {
            return {
              type: "throw",
              arg: t
            };
          }
        }
        function o() {}
        function i() {}
        function u() {}
        function a(t) {
          ["next", "throw", "return"].forEach(function(e) {
            t[e] = function(t) {
              return this._invoke(e, t);
            };
          });
        }
        function c(t) {
          function n(e, o, i, u) {
            var a = r(t[e], t, o);
            if ("throw" !== a.type) {
              var c = a.arg,
                  s = c.value;
              return s && "object" == typeof s && g.call(s, "__await") ? Promise.resolve(s.__await).then(function(t) {
                n("next", t, i, u);
              }, function(t) {
                n("throw", t, i, u);
              }) : Promise.resolve(s).then(function(t) {
                c.value = t, i(c);
              }, u);
            }
            u(a.arg);
          }
          function o(t, e) {
            function r() {
              return new Promise(function(r, o) {
                n(t, e, r, o);
              });
            }
            return i = i ? i.then(r, r) : r();
          }
          "object" == typeof e.process && e.process.domain && (n = e.process.domain.bind(n));
          var i;
          this._invoke = o;
        }
        function s(t, e, n) {
          var o = T;
          return function(i, u) {
            if (o === N)
              throw new Error("Generator is already running");
            if (o === j) {
              if ("throw" === i)
                throw u;
              return v();
            }
            for (n.method = i, n.arg = u; ; ) {
              var a = n.delegate;
              if (a) {
                var c = f(a, n);
                if (c) {
                  if (c === A)
                    continue;
                  return c;
                }
              }
              if ("next" === n.method)
                n.sent = n._sent = n.arg;
              else if ("throw" === n.method) {
                if (o === T)
                  throw o = j, n.arg;
                n.dispatchException(n.arg);
              } else
                "return" === n.method && n.abrupt("return", n.arg);
              o = N;
              var s = r(t, e, n);
              if ("normal" === s.type) {
                if (o = n.done ? j : P, s.arg === A)
                  continue;
                return {
                  value: s.arg,
                  done: n.done
                };
              }
              "throw" === s.type && (o = j, n.method = "throw", n.arg = s.arg);
            }
          };
        }
        function f(t, e) {
          var n = t.iterator[e.method];
          if (n === m) {
            if (e.delegate = null, "throw" === e.method) {
              if (t.iterator.return && (e.method = "return", e.arg = m, f(t, e), "throw" === e.method))
                return A;
              e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return A;
          }
          var o = r(n, t.iterator, e.arg);
          if ("throw" === o.type)
            return e.method = "throw", e.arg = o.arg, e.delegate = null, A;
          var i = o.arg;
          return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = m), e.delegate = null, A) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, A);
        }
        function l(t) {
          var e = {tryLoc: t[0]};
          1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
        }
        function p(t) {
          var e = t.completion || {};
          e.type = "normal", delete e.arg, t.completion = e;
        }
        function d(t) {
          this.tryEntries = [{tryLoc: "root"}], t.forEach(l, this), this.reset(!0);
        }
        function h(t) {
          if (t) {
            var e = t[w];
            if (e)
              return e.call(t);
            if ("function" == typeof t.next)
              return t;
            if (!isNaN(t.length)) {
              var n = -1,
                  r = function e() {
                    for (; ++n < t.length; )
                      if (g.call(t, n))
                        return e.value = t[n], e.done = !1, e;
                    return e.value = m, e.done = !0, e;
                  };
              return r.next = r;
            }
          }
          return {next: v};
        }
        function v() {
          return {
            value: m,
            done: !0
          };
        }
        var m,
            y = Object.prototype,
            g = y.hasOwnProperty,
            b = "function" == typeof Symbol ? Symbol : {},
            w = b.iterator || "@@iterator",
            O = b.asyncIterator || "@@asyncIterator",
            _ = b.toStringTag || "@@toStringTag",
            x = "object" == typeof t,
            E = e.regeneratorRuntime;
        if (E)
          return void(x && (t.exports = E));
        E = e.regeneratorRuntime = x ? t.exports : {}, E.wrap = n;
        var T = "suspendedStart",
            P = "suspendedYield",
            N = "executing",
            j = "completed",
            A = {},
            S = {};
        S[w] = function() {
          return this;
        };
        var M = Object.getPrototypeOf,
            L = M && M(M(h([])));
        L && L !== y && g.call(L, w) && (S = L);
        var U = u.prototype = o.prototype = Object.create(S);
        i.prototype = U.constructor = u, u.constructor = i, u[_] = i.displayName = "GeneratorFunction", E.isGeneratorFunction = function(t) {
          var e = "function" == typeof t && t.constructor;
          return !!e && (e === i || "GeneratorFunction" === (e.displayName || e.name));
        }, E.mark = function(t) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t, u) : (t.__proto__ = u, _ in t || (t[_] = "GeneratorFunction")), t.prototype = Object.create(U), t;
        }, E.awrap = function(t) {
          return {__await: t};
        }, a(c.prototype), c.prototype[O] = function() {
          return this;
        }, E.AsyncIterator = c, E.async = function(t, e, r, o) {
          var i = new c(n(t, e, r, o));
          return E.isGeneratorFunction(e) ? i : i.next().then(function(t) {
            return t.done ? t.value : i.next();
          });
        }, a(U), U[_] = "Generator", U[w] = function() {
          return this;
        }, U.toString = function() {
          return "[object Generator]";
        }, E.keys = function(t) {
          var e = [];
          for (var n in t)
            e.push(n);
          return e.reverse(), function n() {
            for (; e.length; ) {
              var r = e.pop();
              if (r in t)
                return n.value = r, n.done = !1, n;
            }
            return n.done = !0, n;
          };
        }, E.values = h, d.prototype = {
          constructor: d,
          reset: function(t) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = m, this.done = !1, this.delegate = null, this.method = "next", this.arg = m, this.tryEntries.forEach(p), !t)
              for (var e in this)
                "t" === e.charAt(0) && g.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = m);
          },
          stop: function() {
            this.done = !0;
            var t = this.tryEntries[0],
                e = t.completion;
            if ("throw" === e.type)
              throw e.arg;
            return this.rval;
          },
          dispatchException: function(t) {
            function e(e, r) {
              return i.type = "throw", i.arg = t, n.next = e, r && (n.method = "next", n.arg = m), !!r;
            }
            if (this.done)
              throw t;
            for (var n = this,
                r = this.tryEntries.length - 1; r >= 0; --r) {
              var o = this.tryEntries[r],
                  i = o.completion;
              if ("root" === o.tryLoc)
                return e("end");
              if (o.tryLoc <= this.prev) {
                var u = g.call(o, "catchLoc"),
                    a = g.call(o, "finallyLoc");
                if (u && a) {
                  if (this.prev < o.catchLoc)
                    return e(o.catchLoc, !0);
                  if (this.prev < o.finallyLoc)
                    return e(o.finallyLoc);
                } else if (u) {
                  if (this.prev < o.catchLoc)
                    return e(o.catchLoc, !0);
                } else {
                  if (!a)
                    throw new Error("try statement without catch or finally");
                  if (this.prev < o.finallyLoc)
                    return e(o.finallyLoc);
                }
              }
            }
          },
          abrupt: function(t, e) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r.tryLoc <= this.prev && g.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                var o = r;
                break;
              }
            }
            o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null);
            var i = o ? o.completion : {};
            return i.type = t, i.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, A) : this.complete(i);
          },
          complete: function(t, e) {
            if ("throw" === t.type)
              throw t.arg;
            return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), A;
          },
          finish: function(t) {
            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
              var n = this.tryEntries[e];
              if (n.finallyLoc === t)
                return this.complete(n.completion, n.afterLoc), p(n), A;
            }
          },
          catch: function(t) {
            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
              var n = this.tryEntries[e];
              if (n.tryLoc === t) {
                var r = n.completion;
                if ("throw" === r.type) {
                  var o = r.arg;
                  p(n);
                }
                return o;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function(t, e, n) {
            return this.delegate = {
              iterator: h(t),
              resultName: e,
              nextLoc: n
            }, "next" === this.method && (this.arg = m), A;
          }
        };
      }("object" == typeof e ? e : "object" == typeof window ? window : "object" == typeof self ? self : this);
    }).call(e, n(42));
  }, function(t, e, n) {
    t.exports = n(63);
  }]);
});

})();
(function() {
var define = System.amdDefine;
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) : typeof define === 'function' && define.amd ? define("node_modules/@angular/compiler/bundles/compiler.umd.js", ["exports", "node_modules/@angular/core/bundles/core.umd.js"], factory) : (factory((global.ng = global.ng || {}, global.ng.compiler = global.ng.compiler || {}), global.ng.core));
}(this, (function(exports, _angular_core) {
  'use strict';
  var extendStatics = Object.setPrototypeOf || ({__proto__: []} instanceof Array && function(d, b) {
    d.__proto__ = b;
  }) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
  };
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var VERSION = new _angular_core.Version('4.3.4');
  var TextAst = (function() {
    function TextAst(value, ngContentIndex, sourceSpan) {
      this.value = value;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    TextAst.prototype.visit = function(visitor, context) {
      return visitor.visitText(this, context);
    };
    return TextAst;
  }());
  var BoundTextAst = (function() {
    function BoundTextAst(value, ngContentIndex, sourceSpan) {
      this.value = value;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    BoundTextAst.prototype.visit = function(visitor, context) {
      return visitor.visitBoundText(this, context);
    };
    return BoundTextAst;
  }());
  var AttrAst = (function() {
    function AttrAst(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    AttrAst.prototype.visit = function(visitor, context) {
      return visitor.visitAttr(this, context);
    };
    return AttrAst;
  }());
  var BoundElementPropertyAst = (function() {
    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {
      this.name = name;
      this.type = type;
      this.securityContext = securityContext;
      this.value = value;
      this.unit = unit;
      this.sourceSpan = sourceSpan;
    }
    BoundElementPropertyAst.prototype.visit = function(visitor, context) {
      return visitor.visitElementProperty(this, context);
    };
    Object.defineProperty(BoundElementPropertyAst.prototype, "isAnimation", {
      get: function() {
        return this.type === PropertyBindingType.Animation;
      },
      enumerable: true,
      configurable: true
    });
    return BoundElementPropertyAst;
  }());
  var BoundEventAst = (function() {
    function BoundEventAst(name, target, phase, handler, sourceSpan) {
      this.name = name;
      this.target = target;
      this.phase = phase;
      this.handler = handler;
      this.sourceSpan = sourceSpan;
    }
    BoundEventAst.calcFullName = function(name, target, phase) {
      if (target) {
        return target + ":" + name;
      } else if (phase) {
        return "@" + name + "." + phase;
      } else {
        return name;
      }
    };
    BoundEventAst.prototype.visit = function(visitor, context) {
      return visitor.visitEvent(this, context);
    };
    Object.defineProperty(BoundEventAst.prototype, "fullName", {
      get: function() {
        return BoundEventAst.calcFullName(this.name, this.target, this.phase);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BoundEventAst.prototype, "isAnimation", {
      get: function() {
        return !!this.phase;
      },
      enumerable: true,
      configurable: true
    });
    return BoundEventAst;
  }());
  var ReferenceAst = (function() {
    function ReferenceAst(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    ReferenceAst.prototype.visit = function(visitor, context) {
      return visitor.visitReference(this, context);
    };
    return ReferenceAst;
  }());
  var VariableAst = (function() {
    function VariableAst(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    VariableAst.prototype.visit = function(visitor, context) {
      return visitor.visitVariable(this, context);
    };
    return VariableAst;
  }());
  var ElementAst = (function() {
    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {
      this.name = name;
      this.attrs = attrs;
      this.inputs = inputs;
      this.outputs = outputs;
      this.references = references;
      this.directives = directives;
      this.providers = providers;
      this.hasViewContainer = hasViewContainer;
      this.queryMatches = queryMatches;
      this.children = children;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
      this.endSourceSpan = endSourceSpan;
    }
    ElementAst.prototype.visit = function(visitor, context) {
      return visitor.visitElement(this, context);
    };
    return ElementAst;
  }());
  var EmbeddedTemplateAst = (function() {
    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {
      this.attrs = attrs;
      this.outputs = outputs;
      this.references = references;
      this.variables = variables;
      this.directives = directives;
      this.providers = providers;
      this.hasViewContainer = hasViewContainer;
      this.queryMatches = queryMatches;
      this.children = children;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    EmbeddedTemplateAst.prototype.visit = function(visitor, context) {
      return visitor.visitEmbeddedTemplate(this, context);
    };
    return EmbeddedTemplateAst;
  }());
  var BoundDirectivePropertyAst = (function() {
    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {
      this.directiveName = directiveName;
      this.templateName = templateName;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    BoundDirectivePropertyAst.prototype.visit = function(visitor, context) {
      return visitor.visitDirectiveProperty(this, context);
    };
    return BoundDirectivePropertyAst;
  }());
  var DirectiveAst = (function() {
    function DirectiveAst(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {
      this.directive = directive;
      this.inputs = inputs;
      this.hostProperties = hostProperties;
      this.hostEvents = hostEvents;
      this.contentQueryStartId = contentQueryStartId;
      this.sourceSpan = sourceSpan;
    }
    DirectiveAst.prototype.visit = function(visitor, context) {
      return visitor.visitDirective(this, context);
    };
    return DirectiveAst;
  }());
  var ProviderAst = (function() {
    function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {
      this.token = token;
      this.multiProvider = multiProvider;
      this.eager = eager;
      this.providers = providers;
      this.providerType = providerType;
      this.lifecycleHooks = lifecycleHooks;
      this.sourceSpan = sourceSpan;
    }
    ProviderAst.prototype.visit = function(visitor, context) {
      return null;
    };
    return ProviderAst;
  }());
  var ProviderAstType = {};
  ProviderAstType.PublicService = 0;
  ProviderAstType.PrivateService = 1;
  ProviderAstType.Component = 2;
  ProviderAstType.Directive = 3;
  ProviderAstType.Builtin = 4;
  ProviderAstType[ProviderAstType.PublicService] = "PublicService";
  ProviderAstType[ProviderAstType.PrivateService] = "PrivateService";
  ProviderAstType[ProviderAstType.Component] = "Component";
  ProviderAstType[ProviderAstType.Directive] = "Directive";
  ProviderAstType[ProviderAstType.Builtin] = "Builtin";
  var NgContentAst = (function() {
    function NgContentAst(index, ngContentIndex, sourceSpan) {
      this.index = index;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    NgContentAst.prototype.visit = function(visitor, context) {
      return visitor.visitNgContent(this, context);
    };
    return NgContentAst;
  }());
  var PropertyBindingType = {};
  PropertyBindingType.Property = 0;
  PropertyBindingType.Attribute = 1;
  PropertyBindingType.Class = 2;
  PropertyBindingType.Style = 3;
  PropertyBindingType.Animation = 4;
  PropertyBindingType[PropertyBindingType.Property] = "Property";
  PropertyBindingType[PropertyBindingType.Attribute] = "Attribute";
  PropertyBindingType[PropertyBindingType.Class] = "Class";
  PropertyBindingType[PropertyBindingType.Style] = "Style";
  PropertyBindingType[PropertyBindingType.Animation] = "Animation";
  var NullTemplateVisitor = (function() {
    function NullTemplateVisitor() {}
    NullTemplateVisitor.prototype.visitNgContent = function(ast, context) {};
    NullTemplateVisitor.prototype.visitEmbeddedTemplate = function(ast, context) {};
    NullTemplateVisitor.prototype.visitElement = function(ast, context) {};
    NullTemplateVisitor.prototype.visitReference = function(ast, context) {};
    NullTemplateVisitor.prototype.visitVariable = function(ast, context) {};
    NullTemplateVisitor.prototype.visitEvent = function(ast, context) {};
    NullTemplateVisitor.prototype.visitElementProperty = function(ast, context) {};
    NullTemplateVisitor.prototype.visitAttr = function(ast, context) {};
    NullTemplateVisitor.prototype.visitBoundText = function(ast, context) {};
    NullTemplateVisitor.prototype.visitText = function(ast, context) {};
    NullTemplateVisitor.prototype.visitDirective = function(ast, context) {};
    NullTemplateVisitor.prototype.visitDirectiveProperty = function(ast, context) {};
    return NullTemplateVisitor;
  }());
  var RecursiveTemplateAstVisitor = (function(_super) {
    __extends(RecursiveTemplateAstVisitor, _super);
    function RecursiveTemplateAstVisitor() {
      return _super.call(this) || this;
    }
    RecursiveTemplateAstVisitor.prototype.visitEmbeddedTemplate = function(ast, context) {
      return this.visitChildren(context, function(visit) {
        visit(ast.attrs);
        visit(ast.references);
        visit(ast.variables);
        visit(ast.directives);
        visit(ast.providers);
        visit(ast.children);
      });
    };
    RecursiveTemplateAstVisitor.prototype.visitElement = function(ast, context) {
      return this.visitChildren(context, function(visit) {
        visit(ast.attrs);
        visit(ast.inputs);
        visit(ast.outputs);
        visit(ast.references);
        visit(ast.directives);
        visit(ast.providers);
        visit(ast.children);
      });
    };
    RecursiveTemplateAstVisitor.prototype.visitDirective = function(ast, context) {
      return this.visitChildren(context, function(visit) {
        visit(ast.inputs);
        visit(ast.hostProperties);
        visit(ast.hostEvents);
      });
    };
    RecursiveTemplateAstVisitor.prototype.visitChildren = function(context, cb) {
      var results = [];
      var t = this;
      function visit(children) {
        if (children && children.length)
          results.push(templateVisitAll(t, children, context));
      }
      cb(visit);
      return [].concat.apply([], results);
    };
    return RecursiveTemplateAstVisitor;
  }(NullTemplateVisitor));
  function templateVisitAll(visitor, asts, context) {
    if (context === void 0) {
      context = null;
    }
    var result = [];
    var visit = visitor.visit ? function(ast) {
      return ((visitor.visit))(ast, context) || ast.visit(visitor, context);
    } : function(ast) {
      return ast.visit(visitor, context);
    };
    asts.forEach(function(ast) {
      var astResult = visit(ast);
      if (astResult) {
        result.push(astResult);
      }
    });
    return result;
  }
  var StaticSymbol = (function() {
    function StaticSymbol(filePath, name, members) {
      this.filePath = filePath;
      this.name = name;
      this.members = members;
    }
    StaticSymbol.prototype.assertNoMembers = function() {
      if (this.members.length) {
        throw new Error("Illegal state: symbol without members expected, but got " + JSON.stringify(this) + ".");
      }
    };
    return StaticSymbol;
  }());
  var StaticSymbolCache = (function() {
    function StaticSymbolCache() {
      this.cache = new Map();
    }
    StaticSymbolCache.prototype.get = function(declarationFile, name, members) {
      members = members || [];
      var memberSuffix = members.length ? "." + members.join('.') : '';
      var key = "\"" + declarationFile + "\"." + name + memberSuffix;
      var result = this.cache.get(key);
      if (!result) {
        result = new StaticSymbol(declarationFile, name, members);
        this.cache.set(key, result);
      }
      return result;
    };
    return StaticSymbolCache;
  }());
  var TagContentType = {};
  TagContentType.RAW_TEXT = 0;
  TagContentType.ESCAPABLE_RAW_TEXT = 1;
  TagContentType.PARSABLE_DATA = 2;
  TagContentType[TagContentType.RAW_TEXT] = "RAW_TEXT";
  TagContentType[TagContentType.ESCAPABLE_RAW_TEXT] = "ESCAPABLE_RAW_TEXT";
  TagContentType[TagContentType.PARSABLE_DATA] = "PARSABLE_DATA";
  function splitNsName(elementName) {
    if (elementName[0] != ':') {
      return [null, elementName];
    }
    var colonIndex = elementName.indexOf(':', 1);
    if (colonIndex == -1) {
      throw new Error("Unsupported format \"" + elementName + "\" expecting \":namespace:name\"");
    }
    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
  }
  function isNgContainer(tagName) {
    return splitNsName(tagName)[1] === 'ng-container';
  }
  function isNgContent(tagName) {
    return splitNsName(tagName)[1] === 'ng-content';
  }
  function isNgTemplate(tagName) {
    return splitNsName(tagName)[1] === 'ng-template';
  }
  function getNsPrefix(fullName) {
    return fullName === null ? null : splitNsName(fullName)[0];
  }
  function mergeNsAndName(prefix, localName) {
    return prefix ? ":" + prefix + ":" + localName : localName;
  }
  var NAMED_ENTITIES = {
    'Aacute': '\u00C1',
    'aacute': '\u00E1',
    'Acirc': '\u00C2',
    'acirc': '\u00E2',
    'acute': '\u00B4',
    'AElig': '\u00C6',
    'aelig': '\u00E6',
    'Agrave': '\u00C0',
    'agrave': '\u00E0',
    'alefsym': '\u2135',
    'Alpha': '\u0391',
    'alpha': '\u03B1',
    'amp': '&',
    'and': '\u2227',
    'ang': '\u2220',
    'apos': '\u0027',
    'Aring': '\u00C5',
    'aring': '\u00E5',
    'asymp': '\u2248',
    'Atilde': '\u00C3',
    'atilde': '\u00E3',
    'Auml': '\u00C4',
    'auml': '\u00E4',
    'bdquo': '\u201E',
    'Beta': '\u0392',
    'beta': '\u03B2',
    'brvbar': '\u00A6',
    'bull': '\u2022',
    'cap': '\u2229',
    'Ccedil': '\u00C7',
    'ccedil': '\u00E7',
    'cedil': '\u00B8',
    'cent': '\u00A2',
    'Chi': '\u03A7',
    'chi': '\u03C7',
    'circ': '\u02C6',
    'clubs': '\u2663',
    'cong': '\u2245',
    'copy': '\u00A9',
    'crarr': '\u21B5',
    'cup': '\u222A',
    'curren': '\u00A4',
    'dagger': '\u2020',
    'Dagger': '\u2021',
    'darr': '\u2193',
    'dArr': '\u21D3',
    'deg': '\u00B0',
    'Delta': '\u0394',
    'delta': '\u03B4',
    'diams': '\u2666',
    'divide': '\u00F7',
    'Eacute': '\u00C9',
    'eacute': '\u00E9',
    'Ecirc': '\u00CA',
    'ecirc': '\u00EA',
    'Egrave': '\u00C8',
    'egrave': '\u00E8',
    'empty': '\u2205',
    'emsp': '\u2003',
    'ensp': '\u2002',
    'Epsilon': '\u0395',
    'epsilon': '\u03B5',
    'equiv': '\u2261',
    'Eta': '\u0397',
    'eta': '\u03B7',
    'ETH': '\u00D0',
    'eth': '\u00F0',
    'Euml': '\u00CB',
    'euml': '\u00EB',
    'euro': '\u20AC',
    'exist': '\u2203',
    'fnof': '\u0192',
    'forall': '\u2200',
    'frac12': '\u00BD',
    'frac14': '\u00BC',
    'frac34': '\u00BE',
    'frasl': '\u2044',
    'Gamma': '\u0393',
    'gamma': '\u03B3',
    'ge': '\u2265',
    'gt': '>',
    'harr': '\u2194',
    'hArr': '\u21D4',
    'hearts': '\u2665',
    'hellip': '\u2026',
    'Iacute': '\u00CD',
    'iacute': '\u00ED',
    'Icirc': '\u00CE',
    'icirc': '\u00EE',
    'iexcl': '\u00A1',
    'Igrave': '\u00CC',
    'igrave': '\u00EC',
    'image': '\u2111',
    'infin': '\u221E',
    'int': '\u222B',
    'Iota': '\u0399',
    'iota': '\u03B9',
    'iquest': '\u00BF',
    'isin': '\u2208',
    'Iuml': '\u00CF',
    'iuml': '\u00EF',
    'Kappa': '\u039A',
    'kappa': '\u03BA',
    'Lambda': '\u039B',
    'lambda': '\u03BB',
    'lang': '\u27E8',
    'laquo': '\u00AB',
    'larr': '\u2190',
    'lArr': '\u21D0',
    'lceil': '\u2308',
    'ldquo': '\u201C',
    'le': '\u2264',
    'lfloor': '\u230A',
    'lowast': '\u2217',
    'loz': '\u25CA',
    'lrm': '\u200E',
    'lsaquo': '\u2039',
    'lsquo': '\u2018',
    'lt': '<',
    'macr': '\u00AF',
    'mdash': '\u2014',
    'micro': '\u00B5',
    'middot': '\u00B7',
    'minus': '\u2212',
    'Mu': '\u039C',
    'mu': '\u03BC',
    'nabla': '\u2207',
    'nbsp': '\u00A0',
    'ndash': '\u2013',
    'ne': '\u2260',
    'ni': '\u220B',
    'not': '\u00AC',
    'notin': '\u2209',
    'nsub': '\u2284',
    'Ntilde': '\u00D1',
    'ntilde': '\u00F1',
    'Nu': '\u039D',
    'nu': '\u03BD',
    'Oacute': '\u00D3',
    'oacute': '\u00F3',
    'Ocirc': '\u00D4',
    'ocirc': '\u00F4',
    'OElig': '\u0152',
    'oelig': '\u0153',
    'Ograve': '\u00D2',
    'ograve': '\u00F2',
    'oline': '\u203E',
    'Omega': '\u03A9',
    'omega': '\u03C9',
    'Omicron': '\u039F',
    'omicron': '\u03BF',
    'oplus': '\u2295',
    'or': '\u2228',
    'ordf': '\u00AA',
    'ordm': '\u00BA',
    'Oslash': '\u00D8',
    'oslash': '\u00F8',
    'Otilde': '\u00D5',
    'otilde': '\u00F5',
    'otimes': '\u2297',
    'Ouml': '\u00D6',
    'ouml': '\u00F6',
    'para': '\u00B6',
    'permil': '\u2030',
    'perp': '\u22A5',
    'Phi': '\u03A6',
    'phi': '\u03C6',
    'Pi': '\u03A0',
    'pi': '\u03C0',
    'piv': '\u03D6',
    'plusmn': '\u00B1',
    'pound': '\u00A3',
    'prime': '\u2032',
    'Prime': '\u2033',
    'prod': '\u220F',
    'prop': '\u221D',
    'Psi': '\u03A8',
    'psi': '\u03C8',
    'quot': '\u0022',
    'radic': '\u221A',
    'rang': '\u27E9',
    'raquo': '\u00BB',
    'rarr': '\u2192',
    'rArr': '\u21D2',
    'rceil': '\u2309',
    'rdquo': '\u201D',
    'real': '\u211C',
    'reg': '\u00AE',
    'rfloor': '\u230B',
    'Rho': '\u03A1',
    'rho': '\u03C1',
    'rlm': '\u200F',
    'rsaquo': '\u203A',
    'rsquo': '\u2019',
    'sbquo': '\u201A',
    'Scaron': '\u0160',
    'scaron': '\u0161',
    'sdot': '\u22C5',
    'sect': '\u00A7',
    'shy': '\u00AD',
    'Sigma': '\u03A3',
    'sigma': '\u03C3',
    'sigmaf': '\u03C2',
    'sim': '\u223C',
    'spades': '\u2660',
    'sub': '\u2282',
    'sube': '\u2286',
    'sum': '\u2211',
    'sup': '\u2283',
    'sup1': '\u00B9',
    'sup2': '\u00B2',
    'sup3': '\u00B3',
    'supe': '\u2287',
    'szlig': '\u00DF',
    'Tau': '\u03A4',
    'tau': '\u03C4',
    'there4': '\u2234',
    'Theta': '\u0398',
    'theta': '\u03B8',
    'thetasym': '\u03D1',
    'thinsp': '\u2009',
    'THORN': '\u00DE',
    'thorn': '\u00FE',
    'tilde': '\u02DC',
    'times': '\u00D7',
    'trade': '\u2122',
    'Uacute': '\u00DA',
    'uacute': '\u00FA',
    'uarr': '\u2191',
    'uArr': '\u21D1',
    'Ucirc': '\u00DB',
    'ucirc': '\u00FB',
    'Ugrave': '\u00D9',
    'ugrave': '\u00F9',
    'uml': '\u00A8',
    'upsih': '\u03D2',
    'Upsilon': '\u03A5',
    'upsilon': '\u03C5',
    'Uuml': '\u00DC',
    'uuml': '\u00FC',
    'weierp': '\u2118',
    'Xi': '\u039E',
    'xi': '\u03BE',
    'Yacute': '\u00DD',
    'yacute': '\u00FD',
    'yen': '\u00A5',
    'yuml': '\u00FF',
    'Yuml': '\u0178',
    'Zeta': '\u0396',
    'zeta': '\u03B6',
    'zwj': '\u200D',
    'zwnj': '\u200C'
  };
  var HtmlTagDefinition = (function() {
    function HtmlTagDefinition(_a) {
      var _b = _a === void 0 ? {} : _a,
          closedByChildren = _b.closedByChildren,
          requiredParents = _b.requiredParents,
          implicitNamespacePrefix = _b.implicitNamespacePrefix,
          _c = _b.contentType,
          contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c,
          _d = _b.closedByParent,
          closedByParent = _d === void 0 ? false : _d,
          _e = _b.isVoid,
          isVoid = _e === void 0 ? false : _e,
          _f = _b.ignoreFirstLf,
          ignoreFirstLf = _f === void 0 ? false : _f;
      var _this = this;
      this.closedByChildren = {};
      this.closedByParent = false;
      this.canSelfClose = false;
      if (closedByChildren && closedByChildren.length > 0) {
        closedByChildren.forEach(function(tagName) {
          return _this.closedByChildren[tagName] = true;
        });
      }
      this.isVoid = isVoid;
      this.closedByParent = closedByParent || isVoid;
      if (requiredParents && requiredParents.length > 0) {
        this.requiredParents = {};
        this.parentToAdd = requiredParents[0];
        requiredParents.forEach(function(tagName) {
          return _this.requiredParents[tagName] = true;
        });
      }
      this.implicitNamespacePrefix = implicitNamespacePrefix || null;
      this.contentType = contentType;
      this.ignoreFirstLf = ignoreFirstLf;
    }
    HtmlTagDefinition.prototype.requireExtraParent = function(currentParent) {
      if (!this.requiredParents) {
        return false;
      }
      if (!currentParent) {
        return true;
      }
      var lcParent = currentParent.toLowerCase();
      var isParentTemplate = lcParent === 'template' || currentParent === 'ng-template';
      return !isParentTemplate && this.requiredParents[lcParent] != true;
    };
    HtmlTagDefinition.prototype.isClosedByChild = function(name) {
      return this.isVoid || name.toLowerCase() in this.closedByChildren;
    };
    return HtmlTagDefinition;
  }());
  var TAG_DEFINITIONS = {
    'base': new HtmlTagDefinition({isVoid: true}),
    'meta': new HtmlTagDefinition({isVoid: true}),
    'area': new HtmlTagDefinition({isVoid: true}),
    'embed': new HtmlTagDefinition({isVoid: true}),
    'link': new HtmlTagDefinition({isVoid: true}),
    'img': new HtmlTagDefinition({isVoid: true}),
    'input': new HtmlTagDefinition({isVoid: true}),
    'param': new HtmlTagDefinition({isVoid: true}),
    'hr': new HtmlTagDefinition({isVoid: true}),
    'br': new HtmlTagDefinition({isVoid: true}),
    'source': new HtmlTagDefinition({isVoid: true}),
    'track': new HtmlTagDefinition({isVoid: true}),
    'wbr': new HtmlTagDefinition({isVoid: true}),
    'p': new HtmlTagDefinition({
      closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'],
      closedByParent: true
    }),
    'thead': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot']}),
    'tbody': new HtmlTagDefinition({
      closedByChildren: ['tbody', 'tfoot'],
      closedByParent: true
    }),
    'tfoot': new HtmlTagDefinition({
      closedByChildren: ['tbody'],
      closedByParent: true
    }),
    'tr': new HtmlTagDefinition({
      closedByChildren: ['tr'],
      requiredParents: ['tbody', 'tfoot', 'thead'],
      closedByParent: true
    }),
    'td': new HtmlTagDefinition({
      closedByChildren: ['td', 'th'],
      closedByParent: true
    }),
    'th': new HtmlTagDefinition({
      closedByChildren: ['td', 'th'],
      closedByParent: true
    }),
    'col': new HtmlTagDefinition({
      requiredParents: ['colgroup'],
      isVoid: true
    }),
    'svg': new HtmlTagDefinition({implicitNamespacePrefix: 'svg'}),
    'math': new HtmlTagDefinition({implicitNamespacePrefix: 'math'}),
    'li': new HtmlTagDefinition({
      closedByChildren: ['li'],
      closedByParent: true
    }),
    'dt': new HtmlTagDefinition({closedByChildren: ['dt', 'dd']}),
    'dd': new HtmlTagDefinition({
      closedByChildren: ['dt', 'dd'],
      closedByParent: true
    }),
    'rb': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
      closedByParent: true
    }),
    'rt': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
      closedByParent: true
    }),
    'rtc': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rtc', 'rp'],
      closedByParent: true
    }),
    'rp': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
      closedByParent: true
    }),
    'optgroup': new HtmlTagDefinition({
      closedByChildren: ['optgroup'],
      closedByParent: true
    }),
    'option': new HtmlTagDefinition({
      closedByChildren: ['option', 'optgroup'],
      closedByParent: true
    }),
    'pre': new HtmlTagDefinition({ignoreFirstLf: true}),
    'listing': new HtmlTagDefinition({ignoreFirstLf: true}),
    'style': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),
    'script': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),
    'title': new HtmlTagDefinition({contentType: TagContentType.ESCAPABLE_RAW_TEXT}),
    'textarea': new HtmlTagDefinition({
      contentType: TagContentType.ESCAPABLE_RAW_TEXT,
      ignoreFirstLf: true
    })
  };
  var _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
  function getHtmlTagDefinition(tagName) {
    return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;
  }
  var _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' + '([-\\w]+)|' + '(?:\\.([-\\w]+))|' + '(?:\\[([-.\\w*]+)(?:=([\"\']?)([^\\]\"\']*)\\5)?\\])|' + '(\\))|' + '(\\s*,\\s*)', 'g');
  var CssSelector = (function() {
    function CssSelector() {
      this.element = null;
      this.classNames = [];
      this.attrs = [];
      this.notSelectors = [];
    }
    CssSelector.parse = function(selector) {
      var results = [];
      var _addResult = function(res, cssSel) {
        if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {
          cssSel.element = '*';
        }
        res.push(cssSel);
      };
      var cssSelector = new CssSelector();
      var match;
      var current = cssSelector;
      var inNot = false;
      _SELECTOR_REGEXP.lastIndex = 0;
      while (match = _SELECTOR_REGEXP.exec(selector)) {
        if (match[1]) {
          if (inNot) {
            throw new Error('Nesting :not is not allowed in a selector');
          }
          inNot = true;
          current = new CssSelector();
          cssSelector.notSelectors.push(current);
        }
        if (match[2]) {
          current.setElement(match[2]);
        }
        if (match[3]) {
          current.addClassName(match[3]);
        }
        if (match[4]) {
          current.addAttribute(match[4], match[6]);
        }
        if (match[7]) {
          inNot = false;
          current = cssSelector;
        }
        if (match[8]) {
          if (inNot) {
            throw new Error('Multiple selectors in :not are not supported');
          }
          _addResult(results, cssSelector);
          cssSelector = current = new CssSelector();
        }
      }
      _addResult(results, cssSelector);
      return results;
    };
    CssSelector.prototype.isElementSelector = function() {
      return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;
    };
    CssSelector.prototype.hasElementSelector = function() {
      return !!this.element;
    };
    CssSelector.prototype.setElement = function(element) {
      if (element === void 0) {
        element = null;
      }
      this.element = element;
    };
    CssSelector.prototype.getMatchingElementTemplate = function() {
      var tagName = this.element || 'div';
      var classAttr = this.classNames.length > 0 ? " class=\"" + this.classNames.join(' ') + "\"" : '';
      var attrs = '';
      for (var i = 0; i < this.attrs.length; i += 2) {
        var attrName = this.attrs[i];
        var attrValue = this.attrs[i + 1] !== '' ? "=\"" + this.attrs[i + 1] + "\"" : '';
        attrs += " " + attrName + attrValue;
      }
      return getHtmlTagDefinition(tagName).isVoid ? "<" + tagName + classAttr + attrs + "/>" : "<" + tagName + classAttr + attrs + "></" + tagName + ">";
    };
    CssSelector.prototype.addAttribute = function(name, value) {
      if (value === void 0) {
        value = '';
      }
      this.attrs.push(name, value && value.toLowerCase() || '');
    };
    CssSelector.prototype.addClassName = function(name) {
      this.classNames.push(name.toLowerCase());
    };
    CssSelector.prototype.toString = function() {
      var res = this.element || '';
      if (this.classNames) {
        this.classNames.forEach(function(klass) {
          return res += "." + klass;
        });
      }
      if (this.attrs) {
        for (var i = 0; i < this.attrs.length; i += 2) {
          var name = this.attrs[i];
          var value = this.attrs[i + 1];
          res += "[" + name + (value ? '=' + value : '') + "]";
        }
      }
      this.notSelectors.forEach(function(notSelector) {
        return res += ":not(" + notSelector + ")";
      });
      return res;
    };
    return CssSelector;
  }());
  var SelectorMatcher = (function() {
    function SelectorMatcher() {
      this._elementMap = new Map();
      this._elementPartialMap = new Map();
      this._classMap = new Map();
      this._classPartialMap = new Map();
      this._attrValueMap = new Map();
      this._attrValuePartialMap = new Map();
      this._listContexts = [];
    }
    SelectorMatcher.createNotMatcher = function(notSelectors) {
      var notMatcher = new SelectorMatcher();
      notMatcher.addSelectables(notSelectors, null);
      return notMatcher;
    };
    SelectorMatcher.prototype.addSelectables = function(cssSelectors, callbackCtxt) {
      var listContext = ((null));
      if (cssSelectors.length > 1) {
        listContext = new SelectorListContext(cssSelectors);
        this._listContexts.push(listContext);
      }
      for (var i = 0; i < cssSelectors.length; i++) {
        this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
      }
    };
    SelectorMatcher.prototype._addSelectable = function(cssSelector, callbackCtxt, listContext) {
      var matcher = this;
      var element = cssSelector.element;
      var classNames = cssSelector.classNames;
      var attrs = cssSelector.attrs;
      var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
      if (element) {
        var isTerminal = attrs.length === 0 && classNames.length === 0;
        if (isTerminal) {
          this._addTerminal(matcher._elementMap, element, selectable);
        } else {
          matcher = this._addPartial(matcher._elementPartialMap, element);
        }
      }
      if (classNames) {
        for (var i = 0; i < classNames.length; i++) {
          var isTerminal = attrs.length === 0 && i === classNames.length - 1;
          var className = classNames[i];
          if (isTerminal) {
            this._addTerminal(matcher._classMap, className, selectable);
          } else {
            matcher = this._addPartial(matcher._classPartialMap, className);
          }
        }
      }
      if (attrs) {
        for (var i = 0; i < attrs.length; i += 2) {
          var isTerminal = i === attrs.length - 2;
          var name = attrs[i];
          var value = attrs[i + 1];
          if (isTerminal) {
            var terminalMap = matcher._attrValueMap;
            var terminalValuesMap = terminalMap.get(name);
            if (!terminalValuesMap) {
              terminalValuesMap = new Map();
              terminalMap.set(name, terminalValuesMap);
            }
            this._addTerminal(terminalValuesMap, value, selectable);
          } else {
            var partialMap = matcher._attrValuePartialMap;
            var partialValuesMap = partialMap.get(name);
            if (!partialValuesMap) {
              partialValuesMap = new Map();
              partialMap.set(name, partialValuesMap);
            }
            matcher = this._addPartial(partialValuesMap, value);
          }
        }
      }
    };
    SelectorMatcher.prototype._addTerminal = function(map, name, selectable) {
      var terminalList = map.get(name);
      if (!terminalList) {
        terminalList = [];
        map.set(name, terminalList);
      }
      terminalList.push(selectable);
    };
    SelectorMatcher.prototype._addPartial = function(map, name) {
      var matcher = map.get(name);
      if (!matcher) {
        matcher = new SelectorMatcher();
        map.set(name, matcher);
      }
      return matcher;
    };
    SelectorMatcher.prototype.match = function(cssSelector, matchedCallback) {
      var result = false;
      var element = ((cssSelector.element));
      var classNames = cssSelector.classNames;
      var attrs = cssSelector.attrs;
      for (var i = 0; i < this._listContexts.length; i++) {
        this._listContexts[i].alreadyMatched = false;
      }
      result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
      result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;
      if (classNames) {
        for (var i = 0; i < classNames.length; i++) {
          var className = classNames[i];
          result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
          result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;
        }
      }
      if (attrs) {
        for (var i = 0; i < attrs.length; i += 2) {
          var name = attrs[i];
          var value = attrs[i + 1];
          var terminalValuesMap = ((this._attrValueMap.get(name)));
          if (value) {
            result = this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;
          }
          result = this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;
          var partialValuesMap = ((this._attrValuePartialMap.get(name)));
          if (value) {
            result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;
          }
          result = this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
        }
      }
      return result;
    };
    SelectorMatcher.prototype._matchTerminal = function(map, name, cssSelector, matchedCallback) {
      if (!map || typeof name !== 'string') {
        return false;
      }
      var selectables = map.get(name) || [];
      var starSelectables = ((map.get('*')));
      if (starSelectables) {
        selectables = selectables.concat(starSelectables);
      }
      if (selectables.length === 0) {
        return false;
      }
      var selectable;
      var result = false;
      for (var i = 0; i < selectables.length; i++) {
        selectable = selectables[i];
        result = selectable.finalize(cssSelector, matchedCallback) || result;
      }
      return result;
    };
    SelectorMatcher.prototype._matchPartial = function(map, name, cssSelector, matchedCallback) {
      if (!map || typeof name !== 'string') {
        return false;
      }
      var nestedSelector = map.get(name);
      if (!nestedSelector) {
        return false;
      }
      return nestedSelector.match(cssSelector, matchedCallback);
    };
    return SelectorMatcher;
  }());
  var SelectorListContext = (function() {
    function SelectorListContext(selectors) {
      this.selectors = selectors;
      this.alreadyMatched = false;
    }
    return SelectorListContext;
  }());
  var SelectorContext = (function() {
    function SelectorContext(selector, cbContext, listContext) {
      this.selector = selector;
      this.cbContext = cbContext;
      this.listContext = listContext;
      this.notSelectors = selector.notSelectors;
    }
    SelectorContext.prototype.finalize = function(cssSelector, callback) {
      var result = true;
      if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
        var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
        result = !notMatcher.match(cssSelector, null);
      }
      if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
        if (this.listContext) {
          this.listContext.alreadyMatched = true;
        }
        callback(this.selector, this.cbContext);
      }
      return result;
    };
    return SelectorContext;
  }());
  var MODULE_SUFFIX = '';
  var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
  function dashCaseToCamelCase(input) {
    return input.replace(DASH_CASE_REGEXP, function() {
      var m = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        m[_i] = arguments[_i];
      }
      return m[1].toUpperCase();
    });
  }
  function splitAtColon(input, defaultValues) {
    return _splitAt(input, ':', defaultValues);
  }
  function splitAtPeriod(input, defaultValues) {
    return _splitAt(input, '.', defaultValues);
  }
  function _splitAt(input, character, defaultValues) {
    var characterIndex = input.indexOf(character);
    if (characterIndex == -1)
      return defaultValues;
    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
  }
  function visitValue(value, visitor, context) {
    if (Array.isArray(value)) {
      return visitor.visitArray((value), context);
    }
    if (isStrictStringMap(value)) {
      return visitor.visitStringMap((value), context);
    }
    if (value == null || typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean') {
      return visitor.visitPrimitive(value, context);
    }
    return visitor.visitOther(value, context);
  }
  function isDefined(val) {
    return val !== null && val !== undefined;
  }
  function noUndefined(val) {
    return val === undefined ? ((null)) : val;
  }
  var ValueTransformer = (function() {
    function ValueTransformer() {}
    ValueTransformer.prototype.visitArray = function(arr, context) {
      var _this = this;
      return arr.map(function(value) {
        return visitValue(value, _this, context);
      });
    };
    ValueTransformer.prototype.visitStringMap = function(map, context) {
      var _this = this;
      var result = {};
      Object.keys(map).forEach(function(key) {
        result[key] = visitValue(map[key], _this, context);
      });
      return result;
    };
    ValueTransformer.prototype.visitPrimitive = function(value, context) {
      return value;
    };
    ValueTransformer.prototype.visitOther = function(value, context) {
      return value;
    };
    return ValueTransformer;
  }());
  var SyncAsync = {
    assertSync: function(value) {
      if (_angular_core.ɵisPromise(value)) {
        throw new Error("Illegal state: value cannot be a promise");
      }
      return value;
    },
    then: function(value, cb) {
      return _angular_core.ɵisPromise(value) ? value.then(cb) : cb(value);
    },
    all: function(syncAsyncValues) {
      return syncAsyncValues.some(_angular_core.ɵisPromise) ? Promise.all(syncAsyncValues) : (syncAsyncValues);
    }
  };
  function syntaxError(msg, parseErrors) {
    var error = Error(msg);
    ((error))[ERROR_SYNTAX_ERROR] = true;
    if (parseErrors)
      ((error))[ERROR_PARSE_ERRORS] = parseErrors;
    return error;
  }
  var ERROR_SYNTAX_ERROR = 'ngSyntaxError';
  var ERROR_PARSE_ERRORS = 'ngParseErrors';
  function isSyntaxError(error) {
    return ((error))[ERROR_SYNTAX_ERROR];
  }
  function getParseErrors(error) {
    return ((error))[ERROR_PARSE_ERRORS] || [];
  }
  function escapeRegExp(s) {
    return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }
  var STRING_MAP_PROTO = Object.getPrototypeOf({});
  function isStrictStringMap(obj) {
    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
  }
  function utf8Encode(str) {
    var encoded = '';
    for (var index = 0; index < str.length; index++) {
      var codePoint = str.charCodeAt(index);
      if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {
        var low = str.charCodeAt(index + 1);
        if (low >= 0xdc00 && low <= 0xdfff) {
          index++;
          codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;
        }
      }
      if (codePoint <= 0x7f) {
        encoded += String.fromCharCode(codePoint);
      } else if (codePoint <= 0x7ff) {
        encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);
      } else if (codePoint <= 0xffff) {
        encoded += String.fromCharCode((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
      } else if (codePoint <= 0x1fffff) {
        encoded += String.fromCharCode(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
      }
    }
    return encoded;
  }
  var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  var CompileAnimationEntryMetadata = (function() {
    function CompileAnimationEntryMetadata(name, definitions) {
      if (name === void 0) {
        name = null;
      }
      if (definitions === void 0) {
        definitions = null;
      }
      this.name = name;
      this.definitions = definitions;
    }
    return CompileAnimationEntryMetadata;
  }());
  var CompileAnimationStateMetadata = (function() {
    function CompileAnimationStateMetadata() {}
    return CompileAnimationStateMetadata;
  }());
  var CompileAnimationStateDeclarationMetadata = (function(_super) {
    __extends(CompileAnimationStateDeclarationMetadata, _super);
    function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {
      var _this = _super.call(this) || this;
      _this.stateNameExpr = stateNameExpr;
      _this.styles = styles;
      return _this;
    }
    return CompileAnimationStateDeclarationMetadata;
  }(CompileAnimationStateMetadata));
  var CompileAnimationStateTransitionMetadata = (function(_super) {
    __extends(CompileAnimationStateTransitionMetadata, _super);
    function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {
      var _this = _super.call(this) || this;
      _this.stateChangeExpr = stateChangeExpr;
      _this.steps = steps;
      return _this;
    }
    return CompileAnimationStateTransitionMetadata;
  }(CompileAnimationStateMetadata));
  var CompileAnimationMetadata = (function() {
    function CompileAnimationMetadata() {}
    return CompileAnimationMetadata;
  }());
  var CompileAnimationKeyframesSequenceMetadata = (function(_super) {
    __extends(CompileAnimationKeyframesSequenceMetadata, _super);
    function CompileAnimationKeyframesSequenceMetadata(steps) {
      if (steps === void 0) {
        steps = [];
      }
      var _this = _super.call(this) || this;
      _this.steps = steps;
      return _this;
    }
    return CompileAnimationKeyframesSequenceMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationStyleMetadata = (function(_super) {
    __extends(CompileAnimationStyleMetadata, _super);
    function CompileAnimationStyleMetadata(offset, styles) {
      if (styles === void 0) {
        styles = null;
      }
      var _this = _super.call(this) || this;
      _this.offset = offset;
      _this.styles = styles;
      return _this;
    }
    return CompileAnimationStyleMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationAnimateMetadata = (function(_super) {
    __extends(CompileAnimationAnimateMetadata, _super);
    function CompileAnimationAnimateMetadata(timings, styles) {
      if (timings === void 0) {
        timings = 0;
      }
      if (styles === void 0) {
        styles = null;
      }
      var _this = _super.call(this) || this;
      _this.timings = timings;
      _this.styles = styles;
      return _this;
    }
    return CompileAnimationAnimateMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationWithStepsMetadata = (function(_super) {
    __extends(CompileAnimationWithStepsMetadata, _super);
    function CompileAnimationWithStepsMetadata(steps) {
      if (steps === void 0) {
        steps = null;
      }
      var _this = _super.call(this) || this;
      _this.steps = steps;
      return _this;
    }
    return CompileAnimationWithStepsMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationSequenceMetadata = (function(_super) {
    __extends(CompileAnimationSequenceMetadata, _super);
    function CompileAnimationSequenceMetadata(steps) {
      if (steps === void 0) {
        steps = null;
      }
      return _super.call(this, steps) || this;
    }
    return CompileAnimationSequenceMetadata;
  }(CompileAnimationWithStepsMetadata));
  var CompileAnimationGroupMetadata = (function(_super) {
    __extends(CompileAnimationGroupMetadata, _super);
    function CompileAnimationGroupMetadata(steps) {
      if (steps === void 0) {
        steps = null;
      }
      return _super.call(this, steps) || this;
    }
    return CompileAnimationGroupMetadata;
  }(CompileAnimationWithStepsMetadata));
  function _sanitizeIdentifier(name) {
    return name.replace(/\W/g, '_');
  }
  var _anonymousTypeIndex = 0;
  function identifierName(compileIdentifier) {
    if (!compileIdentifier || !compileIdentifier.reference) {
      return null;
    }
    var ref = compileIdentifier.reference;
    if (ref instanceof StaticSymbol) {
      return ref.name;
    }
    if (ref['__anonymousType']) {
      return ref['__anonymousType'];
    }
    var identifier = _angular_core.ɵstringify(ref);
    if (identifier.indexOf('(') >= 0) {
      identifier = "anonymous_" + _anonymousTypeIndex++;
      ref['__anonymousType'] = identifier;
    } else {
      identifier = _sanitizeIdentifier(identifier);
    }
    return identifier;
  }
  function identifierModuleUrl(compileIdentifier) {
    var ref = compileIdentifier.reference;
    if (ref instanceof StaticSymbol) {
      return ref.filePath;
    }
    return "./" + _angular_core.ɵstringify(ref);
  }
  function viewClassName(compType, embeddedTemplateIndex) {
    return "View_" + identifierName({reference: compType}) + "_" + embeddedTemplateIndex;
  }
  function rendererTypeName(compType) {
    return "RenderType_" + identifierName({reference: compType});
  }
  function hostViewClassName(compType) {
    return "HostView_" + identifierName({reference: compType});
  }
  function componentFactoryName(compType) {
    return identifierName({reference: compType}) + "NgFactory";
  }
  var CompileSummaryKind = {};
  CompileSummaryKind.Pipe = 0;
  CompileSummaryKind.Directive = 1;
  CompileSummaryKind.NgModule = 2;
  CompileSummaryKind.Injectable = 3;
  CompileSummaryKind[CompileSummaryKind.Pipe] = "Pipe";
  CompileSummaryKind[CompileSummaryKind.Directive] = "Directive";
  CompileSummaryKind[CompileSummaryKind.NgModule] = "NgModule";
  CompileSummaryKind[CompileSummaryKind.Injectable] = "Injectable";
  function tokenName(token) {
    return token.value != null ? _sanitizeIdentifier(token.value) : identifierName(token.identifier);
  }
  function tokenReference(token) {
    if (token.identifier != null) {
      return token.identifier.reference;
    } else {
      return token.value;
    }
  }
  var CompileStylesheetMetadata = (function() {
    function CompileStylesheetMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          moduleUrl = _b.moduleUrl,
          styles = _b.styles,
          styleUrls = _b.styleUrls;
      this.moduleUrl = moduleUrl || null;
      this.styles = _normalizeArray(styles);
      this.styleUrls = _normalizeArray(styleUrls);
    }
    return CompileStylesheetMetadata;
  }());
  var CompileTemplateMetadata = (function() {
    function CompileTemplateMetadata(_a) {
      var encapsulation = _a.encapsulation,
          template = _a.template,
          templateUrl = _a.templateUrl,
          styles = _a.styles,
          styleUrls = _a.styleUrls,
          externalStylesheets = _a.externalStylesheets,
          animations = _a.animations,
          ngContentSelectors = _a.ngContentSelectors,
          interpolation = _a.interpolation,
          isInline = _a.isInline;
      this.encapsulation = encapsulation;
      this.template = template;
      this.templateUrl = templateUrl;
      this.styles = _normalizeArray(styles);
      this.styleUrls = _normalizeArray(styleUrls);
      this.externalStylesheets = _normalizeArray(externalStylesheets);
      this.animations = animations ? flatten(animations) : [];
      this.ngContentSelectors = ngContentSelectors || [];
      if (interpolation && interpolation.length != 2) {
        throw new Error("'interpolation' should have a start and an end symbol.");
      }
      this.interpolation = interpolation;
      this.isInline = isInline;
    }
    CompileTemplateMetadata.prototype.toSummary = function() {
      return {
        animations: this.animations.map(function(anim) {
          return anim.name;
        }),
        ngContentSelectors: this.ngContentSelectors,
        encapsulation: this.encapsulation
      };
    };
    return CompileTemplateMetadata;
  }());
  var CompileDirectiveMetadata = (function() {
    function CompileDirectiveMetadata(_a) {
      var isHost = _a.isHost,
          type = _a.type,
          isComponent = _a.isComponent,
          selector = _a.selector,
          exportAs = _a.exportAs,
          changeDetection = _a.changeDetection,
          inputs = _a.inputs,
          outputs = _a.outputs,
          hostListeners = _a.hostListeners,
          hostProperties = _a.hostProperties,
          hostAttributes = _a.hostAttributes,
          providers = _a.providers,
          viewProviders = _a.viewProviders,
          queries = _a.queries,
          viewQueries = _a.viewQueries,
          entryComponents = _a.entryComponents,
          template = _a.template,
          componentViewType = _a.componentViewType,
          rendererType = _a.rendererType,
          componentFactory = _a.componentFactory;
      this.isHost = !!isHost;
      this.type = type;
      this.isComponent = isComponent;
      this.selector = selector;
      this.exportAs = exportAs;
      this.changeDetection = changeDetection;
      this.inputs = inputs;
      this.outputs = outputs;
      this.hostListeners = hostListeners;
      this.hostProperties = hostProperties;
      this.hostAttributes = hostAttributes;
      this.providers = _normalizeArray(providers);
      this.viewProviders = _normalizeArray(viewProviders);
      this.queries = _normalizeArray(queries);
      this.viewQueries = _normalizeArray(viewQueries);
      this.entryComponents = _normalizeArray(entryComponents);
      this.template = template;
      this.componentViewType = componentViewType;
      this.rendererType = rendererType;
      this.componentFactory = componentFactory;
    }
    CompileDirectiveMetadata.create = function(_a) {
      var isHost = _a.isHost,
          type = _a.type,
          isComponent = _a.isComponent,
          selector = _a.selector,
          exportAs = _a.exportAs,
          changeDetection = _a.changeDetection,
          inputs = _a.inputs,
          outputs = _a.outputs,
          host = _a.host,
          providers = _a.providers,
          viewProviders = _a.viewProviders,
          queries = _a.queries,
          viewQueries = _a.viewQueries,
          entryComponents = _a.entryComponents,
          template = _a.template,
          componentViewType = _a.componentViewType,
          rendererType = _a.rendererType,
          componentFactory = _a.componentFactory;
      var hostListeners = {};
      var hostProperties = {};
      var hostAttributes = {};
      if (host != null) {
        Object.keys(host).forEach(function(key) {
          var value = host[key];
          var matches = key.match(HOST_REG_EXP);
          if (matches === null) {
            hostAttributes[key] = value;
          } else if (matches[1] != null) {
            hostProperties[matches[1]] = value;
          } else if (matches[2] != null) {
            hostListeners[matches[2]] = value;
          }
        });
      }
      var inputsMap = {};
      if (inputs != null) {
        inputs.forEach(function(bindConfig) {
          var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
          inputsMap[parts[0]] = parts[1];
        });
      }
      var outputsMap = {};
      if (outputs != null) {
        outputs.forEach(function(bindConfig) {
          var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
          outputsMap[parts[0]] = parts[1];
        });
      }
      return new CompileDirectiveMetadata({
        isHost: isHost,
        type: type,
        isComponent: !!isComponent,
        selector: selector,
        exportAs: exportAs,
        changeDetection: changeDetection,
        inputs: inputsMap,
        outputs: outputsMap,
        hostListeners: hostListeners,
        hostProperties: hostProperties,
        hostAttributes: hostAttributes,
        providers: providers,
        viewProviders: viewProviders,
        queries: queries,
        viewQueries: viewQueries,
        entryComponents: entryComponents,
        template: template,
        componentViewType: componentViewType,
        rendererType: rendererType,
        componentFactory: componentFactory
      });
    };
    CompileDirectiveMetadata.prototype.toSummary = function() {
      return {
        summaryKind: CompileSummaryKind.Directive,
        type: this.type,
        isComponent: this.isComponent,
        selector: this.selector,
        exportAs: this.exportAs,
        inputs: this.inputs,
        outputs: this.outputs,
        hostListeners: this.hostListeners,
        hostProperties: this.hostProperties,
        hostAttributes: this.hostAttributes,
        providers: this.providers,
        viewProviders: this.viewProviders,
        queries: this.queries,
        viewQueries: this.viewQueries,
        entryComponents: this.entryComponents,
        changeDetection: this.changeDetection,
        template: this.template && this.template.toSummary(),
        componentViewType: this.componentViewType,
        rendererType: this.rendererType,
        componentFactory: this.componentFactory
      };
    };
    return CompileDirectiveMetadata;
  }());
  function createHostComponentMeta(hostTypeReference, compMeta, hostViewType) {
    var template = CssSelector.parse(((compMeta.selector)))[0].getMatchingElementTemplate();
    return CompileDirectiveMetadata.create({
      isHost: true,
      type: {
        reference: hostTypeReference,
        diDeps: [],
        lifecycleHooks: []
      },
      template: new CompileTemplateMetadata({
        encapsulation: _angular_core.ViewEncapsulation.None,
        template: template,
        templateUrl: '',
        styles: [],
        styleUrls: [],
        ngContentSelectors: [],
        animations: [],
        isInline: true,
        externalStylesheets: [],
        interpolation: null
      }),
      exportAs: null,
      changeDetection: _angular_core.ChangeDetectionStrategy.Default,
      inputs: [],
      outputs: [],
      host: {},
      isComponent: true,
      selector: '*',
      providers: [],
      viewProviders: [],
      queries: [],
      viewQueries: [],
      componentViewType: hostViewType,
      rendererType: {
        id: '__Host__',
        encapsulation: _angular_core.ViewEncapsulation.None,
        styles: [],
        data: {}
      },
      entryComponents: [],
      componentFactory: null
    });
  }
  var CompilePipeMetadata = (function() {
    function CompilePipeMetadata(_a) {
      var type = _a.type,
          name = _a.name,
          pure = _a.pure;
      this.type = type;
      this.name = name;
      this.pure = !!pure;
    }
    CompilePipeMetadata.prototype.toSummary = function() {
      return {
        summaryKind: CompileSummaryKind.Pipe,
        type: this.type,
        name: this.name,
        pure: this.pure
      };
    };
    return CompilePipeMetadata;
  }());
  var CompileNgModuleMetadata = (function() {
    function CompileNgModuleMetadata(_a) {
      var type = _a.type,
          providers = _a.providers,
          declaredDirectives = _a.declaredDirectives,
          exportedDirectives = _a.exportedDirectives,
          declaredPipes = _a.declaredPipes,
          exportedPipes = _a.exportedPipes,
          entryComponents = _a.entryComponents,
          bootstrapComponents = _a.bootstrapComponents,
          importedModules = _a.importedModules,
          exportedModules = _a.exportedModules,
          schemas = _a.schemas,
          transitiveModule = _a.transitiveModule,
          id = _a.id;
      this.type = type || null;
      this.declaredDirectives = _normalizeArray(declaredDirectives);
      this.exportedDirectives = _normalizeArray(exportedDirectives);
      this.declaredPipes = _normalizeArray(declaredPipes);
      this.exportedPipes = _normalizeArray(exportedPipes);
      this.providers = _normalizeArray(providers);
      this.entryComponents = _normalizeArray(entryComponents);
      this.bootstrapComponents = _normalizeArray(bootstrapComponents);
      this.importedModules = _normalizeArray(importedModules);
      this.exportedModules = _normalizeArray(exportedModules);
      this.schemas = _normalizeArray(schemas);
      this.id = id || null;
      this.transitiveModule = transitiveModule || null;
    }
    CompileNgModuleMetadata.prototype.toSummary = function() {
      var module = ((this.transitiveModule));
      return {
        summaryKind: CompileSummaryKind.NgModule,
        type: this.type,
        entryComponents: module.entryComponents,
        providers: module.providers,
        modules: module.modules,
        exportedDirectives: module.exportedDirectives,
        exportedPipes: module.exportedPipes
      };
    };
    return CompileNgModuleMetadata;
  }());
  var TransitiveCompileNgModuleMetadata = (function() {
    function TransitiveCompileNgModuleMetadata() {
      this.directivesSet = new Set();
      this.directives = [];
      this.exportedDirectivesSet = new Set();
      this.exportedDirectives = [];
      this.pipesSet = new Set();
      this.pipes = [];
      this.exportedPipesSet = new Set();
      this.exportedPipes = [];
      this.modulesSet = new Set();
      this.modules = [];
      this.entryComponentsSet = new Set();
      this.entryComponents = [];
      this.providers = [];
    }
    TransitiveCompileNgModuleMetadata.prototype.addProvider = function(provider, module) {
      this.providers.push({
        provider: provider,
        module: module
      });
    };
    TransitiveCompileNgModuleMetadata.prototype.addDirective = function(id) {
      if (!this.directivesSet.has(id.reference)) {
        this.directivesSet.add(id.reference);
        this.directives.push(id);
      }
    };
    TransitiveCompileNgModuleMetadata.prototype.addExportedDirective = function(id) {
      if (!this.exportedDirectivesSet.has(id.reference)) {
        this.exportedDirectivesSet.add(id.reference);
        this.exportedDirectives.push(id);
      }
    };
    TransitiveCompileNgModuleMetadata.prototype.addPipe = function(id) {
      if (!this.pipesSet.has(id.reference)) {
        this.pipesSet.add(id.reference);
        this.pipes.push(id);
      }
    };
    TransitiveCompileNgModuleMetadata.prototype.addExportedPipe = function(id) {
      if (!this.exportedPipesSet.has(id.reference)) {
        this.exportedPipesSet.add(id.reference);
        this.exportedPipes.push(id);
      }
    };
    TransitiveCompileNgModuleMetadata.prototype.addModule = function(id) {
      if (!this.modulesSet.has(id.reference)) {
        this.modulesSet.add(id.reference);
        this.modules.push(id);
      }
    };
    TransitiveCompileNgModuleMetadata.prototype.addEntryComponent = function(ec) {
      if (!this.entryComponentsSet.has(ec.componentType)) {
        this.entryComponentsSet.add(ec.componentType);
        this.entryComponents.push(ec);
      }
    };
    return TransitiveCompileNgModuleMetadata;
  }());
  function _normalizeArray(obj) {
    return obj || [];
  }
  var ProviderMeta = (function() {
    function ProviderMeta(token, _a) {
      var useClass = _a.useClass,
          useValue = _a.useValue,
          useExisting = _a.useExisting,
          useFactory = _a.useFactory,
          deps = _a.deps,
          multi = _a.multi;
      this.token = token;
      this.useClass = useClass || null;
      this.useValue = useValue;
      this.useExisting = useExisting;
      this.useFactory = useFactory || null;
      this.dependencies = deps || null;
      this.multi = !!multi;
    }
    return ProviderMeta;
  }());
  function flatten(list) {
    return list.reduce(function(flat, item) {
      var flatItem = Array.isArray(item) ? flatten(item) : item;
      return ((flat)).concat(flatItem);
    }, []);
  }
  function sourceUrl(url) {
    return url.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, 'ng:///');
  }
  function templateSourceUrl(ngModuleType, compMeta, templateMeta) {
    var url;
    if (templateMeta.isInline) {
      if (compMeta.type.reference instanceof StaticSymbol) {
        url = compMeta.type.reference.filePath + "." + compMeta.type.reference.name + ".html";
      } else {
        url = identifierName(ngModuleType) + "/" + identifierName(compMeta.type) + ".html";
      }
    } else {
      url = ((templateMeta.templateUrl));
    }
    return sourceUrl(url);
  }
  function sharedStylesheetJitUrl(meta, id) {
    var pathParts = ((meta.moduleUrl)).split(/\/\\/g);
    var baseName = pathParts[pathParts.length - 1];
    return sourceUrl("css/" + id + baseName + ".ngstyle.js");
  }
  function ngModuleJitUrl(moduleMeta) {
    return sourceUrl(identifierName(moduleMeta.type) + "/module.ngfactory.js");
  }
  function templateJitUrl(ngModuleType, compMeta) {
    return sourceUrl(identifierName(ngModuleType) + "/" + identifierName(compMeta.type) + ".ngfactory.js");
  }
  var CompileReflector = (function() {
    function CompileReflector() {}
    CompileReflector.prototype.parameters = function(typeOrFunc) {};
    CompileReflector.prototype.annotations = function(typeOrFunc) {};
    CompileReflector.prototype.propMetadata = function(typeOrFunc) {};
    CompileReflector.prototype.hasLifecycleHook = function(type, lcProperty) {};
    CompileReflector.prototype.componentModuleUrl = function(type, cmpMetadata) {};
    CompileReflector.prototype.resolveExternalReference = function(ref) {};
    return CompileReflector;
  }());
  var CompilerConfig = (function() {
    function CompilerConfig(_a) {
      var _b = _a === void 0 ? {} : _a,
          _c = _b.defaultEncapsulation,
          defaultEncapsulation = _c === void 0 ? _angular_core.ViewEncapsulation.Emulated : _c,
          _d = _b.useJit,
          useJit = _d === void 0 ? true : _d,
          missingTranslation = _b.missingTranslation,
          enableLegacyTemplate = _b.enableLegacyTemplate;
      this.defaultEncapsulation = defaultEncapsulation;
      this.useJit = !!useJit;
      this.missingTranslation = missingTranslation || null;
      this.enableLegacyTemplate = enableLegacyTemplate !== false;
    }
    return CompilerConfig;
  }());
  var ParserError = (function() {
    function ParserError(message, input, errLocation, ctxLocation) {
      this.input = input;
      this.errLocation = errLocation;
      this.ctxLocation = ctxLocation;
      this.message = "Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation;
    }
    return ParserError;
  }());
  var ParseSpan = (function() {
    function ParseSpan(start, end) {
      this.start = start;
      this.end = end;
    }
    return ParseSpan;
  }());
  var AST = (function() {
    function AST(span) {
      this.span = span;
    }
    AST.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return null;
    };
    AST.prototype.toString = function() {
      return 'AST';
    };
    return AST;
  }());
  var Quote = (function(_super) {
    __extends(Quote, _super);
    function Quote(span, prefix, uninterpretedExpression, location) {
      var _this = _super.call(this, span) || this;
      _this.prefix = prefix;
      _this.uninterpretedExpression = uninterpretedExpression;
      _this.location = location;
      return _this;
    }
    Quote.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitQuote(this, context);
    };
    Quote.prototype.toString = function() {
      return 'Quote';
    };
    return Quote;
  }(AST));
  var EmptyExpr = (function(_super) {
    __extends(EmptyExpr, _super);
    function EmptyExpr() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    EmptyExpr.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
    };
    return EmptyExpr;
  }(AST));
  var ImplicitReceiver = (function(_super) {
    __extends(ImplicitReceiver, _super);
    function ImplicitReceiver() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImplicitReceiver.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitImplicitReceiver(this, context);
    };
    return ImplicitReceiver;
  }(AST));
  var Chain = (function(_super) {
    __extends(Chain, _super);
    function Chain(span, expressions) {
      var _this = _super.call(this, span) || this;
      _this.expressions = expressions;
      return _this;
    }
    Chain.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitChain(this, context);
    };
    return Chain;
  }(AST));
  var Conditional = (function(_super) {
    __extends(Conditional, _super);
    function Conditional(span, condition, trueExp, falseExp) {
      var _this = _super.call(this, span) || this;
      _this.condition = condition;
      _this.trueExp = trueExp;
      _this.falseExp = falseExp;
      return _this;
    }
    Conditional.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitConditional(this, context);
    };
    return Conditional;
  }(AST));
  var PropertyRead = (function(_super) {
    __extends(PropertyRead, _super);
    function PropertyRead(span, receiver, name) {
      var _this = _super.call(this, span) || this;
      _this.receiver = receiver;
      _this.name = name;
      return _this;
    }
    PropertyRead.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPropertyRead(this, context);
    };
    return PropertyRead;
  }(AST));
  var PropertyWrite = (function(_super) {
    __extends(PropertyWrite, _super);
    function PropertyWrite(span, receiver, name, value) {
      var _this = _super.call(this, span) || this;
      _this.receiver = receiver;
      _this.name = name;
      _this.value = value;
      return _this;
    }
    PropertyWrite.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPropertyWrite(this, context);
    };
    return PropertyWrite;
  }(AST));
  var SafePropertyRead = (function(_super) {
    __extends(SafePropertyRead, _super);
    function SafePropertyRead(span, receiver, name) {
      var _this = _super.call(this, span) || this;
      _this.receiver = receiver;
      _this.name = name;
      return _this;
    }
    SafePropertyRead.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitSafePropertyRead(this, context);
    };
    return SafePropertyRead;
  }(AST));
  var KeyedRead = (function(_super) {
    __extends(KeyedRead, _super);
    function KeyedRead(span, obj, key) {
      var _this = _super.call(this, span) || this;
      _this.obj = obj;
      _this.key = key;
      return _this;
    }
    KeyedRead.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitKeyedRead(this, context);
    };
    return KeyedRead;
  }(AST));
  var KeyedWrite = (function(_super) {
    __extends(KeyedWrite, _super);
    function KeyedWrite(span, obj, key, value) {
      var _this = _super.call(this, span) || this;
      _this.obj = obj;
      _this.key = key;
      _this.value = value;
      return _this;
    }
    KeyedWrite.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitKeyedWrite(this, context);
    };
    return KeyedWrite;
  }(AST));
  var BindingPipe = (function(_super) {
    __extends(BindingPipe, _super);
    function BindingPipe(span, exp, name, args) {
      var _this = _super.call(this, span) || this;
      _this.exp = exp;
      _this.name = name;
      _this.args = args;
      return _this;
    }
    BindingPipe.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPipe(this, context);
    };
    return BindingPipe;
  }(AST));
  var LiteralPrimitive = (function(_super) {
    __extends(LiteralPrimitive, _super);
    function LiteralPrimitive(span, value) {
      var _this = _super.call(this, span) || this;
      _this.value = value;
      return _this;
    }
    LiteralPrimitive.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitLiteralPrimitive(this, context);
    };
    return LiteralPrimitive;
  }(AST));
  var LiteralArray = (function(_super) {
    __extends(LiteralArray, _super);
    function LiteralArray(span, expressions) {
      var _this = _super.call(this, span) || this;
      _this.expressions = expressions;
      return _this;
    }
    LiteralArray.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitLiteralArray(this, context);
    };
    return LiteralArray;
  }(AST));
  var LiteralMap = (function(_super) {
    __extends(LiteralMap, _super);
    function LiteralMap(span, keys, values) {
      var _this = _super.call(this, span) || this;
      _this.keys = keys;
      _this.values = values;
      return _this;
    }
    LiteralMap.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitLiteralMap(this, context);
    };
    return LiteralMap;
  }(AST));
  var Interpolation = (function(_super) {
    __extends(Interpolation, _super);
    function Interpolation(span, strings, expressions) {
      var _this = _super.call(this, span) || this;
      _this.strings = strings;
      _this.expressions = expressions;
      return _this;
    }
    Interpolation.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitInterpolation(this, context);
    };
    return Interpolation;
  }(AST));
  var Binary = (function(_super) {
    __extends(Binary, _super);
    function Binary(span, operation, left, right) {
      var _this = _super.call(this, span) || this;
      _this.operation = operation;
      _this.left = left;
      _this.right = right;
      return _this;
    }
    Binary.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitBinary(this, context);
    };
    return Binary;
  }(AST));
  var PrefixNot = (function(_super) {
    __extends(PrefixNot, _super);
    function PrefixNot(span, expression) {
      var _this = _super.call(this, span) || this;
      _this.expression = expression;
      return _this;
    }
    PrefixNot.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPrefixNot(this, context);
    };
    return PrefixNot;
  }(AST));
  var NonNullAssert = (function(_super) {
    __extends(NonNullAssert, _super);
    function NonNullAssert(span, expression) {
      var _this = _super.call(this, span) || this;
      _this.expression = expression;
      return _this;
    }
    NonNullAssert.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitNonNullAssert(this, context);
    };
    return NonNullAssert;
  }(AST));
  var MethodCall = (function(_super) {
    __extends(MethodCall, _super);
    function MethodCall(span, receiver, name, args) {
      var _this = _super.call(this, span) || this;
      _this.receiver = receiver;
      _this.name = name;
      _this.args = args;
      return _this;
    }
    MethodCall.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitMethodCall(this, context);
    };
    return MethodCall;
  }(AST));
  var SafeMethodCall = (function(_super) {
    __extends(SafeMethodCall, _super);
    function SafeMethodCall(span, receiver, name, args) {
      var _this = _super.call(this, span) || this;
      _this.receiver = receiver;
      _this.name = name;
      _this.args = args;
      return _this;
    }
    SafeMethodCall.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitSafeMethodCall(this, context);
    };
    return SafeMethodCall;
  }(AST));
  var FunctionCall = (function(_super) {
    __extends(FunctionCall, _super);
    function FunctionCall(span, target, args) {
      var _this = _super.call(this, span) || this;
      _this.target = target;
      _this.args = args;
      return _this;
    }
    FunctionCall.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitFunctionCall(this, context);
    };
    return FunctionCall;
  }(AST));
  var ASTWithSource = (function(_super) {
    __extends(ASTWithSource, _super);
    function ASTWithSource(ast, source, location, errors) {
      var _this = _super.call(this, new ParseSpan(0, source == null ? 0 : source.length)) || this;
      _this.ast = ast;
      _this.source = source;
      _this.location = location;
      _this.errors = errors;
      return _this;
    }
    ASTWithSource.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return this.ast.visit(visitor, context);
    };
    ASTWithSource.prototype.toString = function() {
      return this.source + " in " + this.location;
    };
    return ASTWithSource;
  }(AST));
  var TemplateBinding = (function() {
    function TemplateBinding(span, key, keyIsVar, name, expression) {
      this.span = span;
      this.key = key;
      this.keyIsVar = keyIsVar;
      this.name = name;
      this.expression = expression;
    }
    return TemplateBinding;
  }());
  var NullAstVisitor = (function() {
    function NullAstVisitor() {}
    NullAstVisitor.prototype.visitBinary = function(ast, context) {};
    NullAstVisitor.prototype.visitChain = function(ast, context) {};
    NullAstVisitor.prototype.visitConditional = function(ast, context) {};
    NullAstVisitor.prototype.visitFunctionCall = function(ast, context) {};
    NullAstVisitor.prototype.visitImplicitReceiver = function(ast, context) {};
    NullAstVisitor.prototype.visitInterpolation = function(ast, context) {};
    NullAstVisitor.prototype.visitKeyedRead = function(ast, context) {};
    NullAstVisitor.prototype.visitKeyedWrite = function(ast, context) {};
    NullAstVisitor.prototype.visitLiteralArray = function(ast, context) {};
    NullAstVisitor.prototype.visitLiteralMap = function(ast, context) {};
    NullAstVisitor.prototype.visitLiteralPrimitive = function(ast, context) {};
    NullAstVisitor.prototype.visitMethodCall = function(ast, context) {};
    NullAstVisitor.prototype.visitPipe = function(ast, context) {};
    NullAstVisitor.prototype.visitPrefixNot = function(ast, context) {};
    NullAstVisitor.prototype.visitNonNullAssert = function(ast, context) {};
    NullAstVisitor.prototype.visitPropertyRead = function(ast, context) {};
    NullAstVisitor.prototype.visitPropertyWrite = function(ast, context) {};
    NullAstVisitor.prototype.visitQuote = function(ast, context) {};
    NullAstVisitor.prototype.visitSafeMethodCall = function(ast, context) {};
    NullAstVisitor.prototype.visitSafePropertyRead = function(ast, context) {};
    return NullAstVisitor;
  }());
  var RecursiveAstVisitor = (function() {
    function RecursiveAstVisitor() {}
    RecursiveAstVisitor.prototype.visitBinary = function(ast, context) {
      ast.left.visit(this);
      ast.right.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitChain = function(ast, context) {
      return this.visitAll(ast.expressions, context);
    };
    RecursiveAstVisitor.prototype.visitConditional = function(ast, context) {
      ast.condition.visit(this);
      ast.trueExp.visit(this);
      ast.falseExp.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitPipe = function(ast, context) {
      ast.exp.visit(this);
      this.visitAll(ast.args, context);
      return null;
    };
    RecursiveAstVisitor.prototype.visitFunctionCall = function(ast, context) {
      ((ast.target)).visit(this);
      this.visitAll(ast.args, context);
      return null;
    };
    RecursiveAstVisitor.prototype.visitImplicitReceiver = function(ast, context) {
      return null;
    };
    RecursiveAstVisitor.prototype.visitInterpolation = function(ast, context) {
      return this.visitAll(ast.expressions, context);
    };
    RecursiveAstVisitor.prototype.visitKeyedRead = function(ast, context) {
      ast.obj.visit(this);
      ast.key.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitKeyedWrite = function(ast, context) {
      ast.obj.visit(this);
      ast.key.visit(this);
      ast.value.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitLiteralArray = function(ast, context) {
      return this.visitAll(ast.expressions, context);
    };
    RecursiveAstVisitor.prototype.visitLiteralMap = function(ast, context) {
      return this.visitAll(ast.values, context);
    };
    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function(ast, context) {
      return null;
    };
    RecursiveAstVisitor.prototype.visitMethodCall = function(ast, context) {
      ast.receiver.visit(this);
      return this.visitAll(ast.args, context);
    };
    RecursiveAstVisitor.prototype.visitPrefixNot = function(ast, context) {
      ast.expression.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitNonNullAssert = function(ast, context) {
      ast.expression.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyRead = function(ast, context) {
      ast.receiver.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyWrite = function(ast, context) {
      ast.receiver.visit(this);
      ast.value.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitSafePropertyRead = function(ast, context) {
      ast.receiver.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitSafeMethodCall = function(ast, context) {
      ast.receiver.visit(this);
      return this.visitAll(ast.args, context);
    };
    RecursiveAstVisitor.prototype.visitAll = function(asts, context) {
      var _this = this;
      asts.forEach(function(ast) {
        return ast.visit(_this, context);
      });
      return null;
    };
    RecursiveAstVisitor.prototype.visitQuote = function(ast, context) {
      return null;
    };
    return RecursiveAstVisitor;
  }());
  var AstTransformer = (function() {
    function AstTransformer() {}
    AstTransformer.prototype.visitImplicitReceiver = function(ast, context) {
      return ast;
    };
    AstTransformer.prototype.visitInterpolation = function(ast, context) {
      return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitLiteralPrimitive = function(ast, context) {
      return new LiteralPrimitive(ast.span, ast.value);
    };
    AstTransformer.prototype.visitPropertyRead = function(ast, context) {
      return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);
    };
    AstTransformer.prototype.visitPropertyWrite = function(ast, context) {
      return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value.visit(this));
    };
    AstTransformer.prototype.visitSafePropertyRead = function(ast, context) {
      return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);
    };
    AstTransformer.prototype.visitMethodCall = function(ast, context) {
      return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitSafeMethodCall = function(ast, context) {
      return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitFunctionCall = function(ast, context) {
      return new FunctionCall(ast.span, ((ast.target)).visit(this), this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitLiteralArray = function(ast, context) {
      return new LiteralArray(ast.span, this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitLiteralMap = function(ast, context) {
      return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));
    };
    AstTransformer.prototype.visitBinary = function(ast, context) {
      return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));
    };
    AstTransformer.prototype.visitPrefixNot = function(ast, context) {
      return new PrefixNot(ast.span, ast.expression.visit(this));
    };
    AstTransformer.prototype.visitNonNullAssert = function(ast, context) {
      return new NonNullAssert(ast.span, ast.expression.visit(this));
    };
    AstTransformer.prototype.visitConditional = function(ast, context) {
      return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
    };
    AstTransformer.prototype.visitPipe = function(ast, context) {
      return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitKeyedRead = function(ast, context) {
      return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));
    };
    AstTransformer.prototype.visitKeyedWrite = function(ast, context) {
      return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
    };
    AstTransformer.prototype.visitAll = function(asts) {
      var res = new Array(asts.length);
      for (var i = 0; i < asts.length; ++i) {
        res[i] = asts[i].visit(this);
      }
      return res;
    };
    AstTransformer.prototype.visitChain = function(ast, context) {
      return new Chain(ast.span, this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitQuote = function(ast, context) {
      return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);
    };
    return AstTransformer;
  }());
  function visitAstChildren(ast, visitor, context) {
    function visit(ast) {
      visitor.visit && visitor.visit(ast, context) || ast.visit(visitor, context);
    }
    function visitAll(asts) {
      asts.forEach(visit);
    }
    ast.visit({
      visitBinary: function(ast) {
        visit(ast.left);
        visit(ast.right);
      },
      visitChain: function(ast) {
        visitAll(ast.expressions);
      },
      visitConditional: function(ast) {
        visit(ast.condition);
        visit(ast.trueExp);
        visit(ast.falseExp);
      },
      visitFunctionCall: function(ast) {
        if (ast.target) {
          visit(ast.target);
        }
        visitAll(ast.args);
      },
      visitImplicitReceiver: function(ast) {},
      visitInterpolation: function(ast) {
        visitAll(ast.expressions);
      },
      visitKeyedRead: function(ast) {
        visit(ast.obj);
        visit(ast.key);
      },
      visitKeyedWrite: function(ast) {
        visit(ast.obj);
        visit(ast.key);
        visit(ast.obj);
      },
      visitLiteralArray: function(ast) {
        visitAll(ast.expressions);
      },
      visitLiteralMap: function(ast) {},
      visitLiteralPrimitive: function(ast) {},
      visitMethodCall: function(ast) {
        visit(ast.receiver);
        visitAll(ast.args);
      },
      visitPipe: function(ast) {
        visit(ast.exp);
        visitAll(ast.args);
      },
      visitPrefixNot: function(ast) {
        visit(ast.expression);
      },
      visitNonNullAssert: function(ast) {
        visit(ast.expression);
      },
      visitPropertyRead: function(ast) {
        visit(ast.receiver);
      },
      visitPropertyWrite: function(ast) {
        visit(ast.receiver);
        visit(ast.value);
      },
      visitQuote: function(ast) {},
      visitSafeMethodCall: function(ast) {
        visit(ast.receiver);
        visitAll(ast.args);
      },
      visitSafePropertyRead: function(ast) {
        visit(ast.receiver);
      }
    });
  }
  var $EOF = 0;
  var $TAB = 9;
  var $LF = 10;
  var $VTAB = 11;
  var $FF = 12;
  var $CR = 13;
  var $SPACE = 32;
  var $BANG = 33;
  var $DQ = 34;
  var $HASH = 35;
  var $$ = 36;
  var $PERCENT = 37;
  var $AMPERSAND = 38;
  var $SQ = 39;
  var $LPAREN = 40;
  var $RPAREN = 41;
  var $STAR = 42;
  var $PLUS = 43;
  var $COMMA = 44;
  var $MINUS = 45;
  var $PERIOD = 46;
  var $SLASH = 47;
  var $COLON = 58;
  var $SEMICOLON = 59;
  var $LT = 60;
  var $EQ = 61;
  var $GT = 62;
  var $QUESTION = 63;
  var $0 = 48;
  var $9 = 57;
  var $A = 65;
  var $E = 69;
  var $F = 70;
  var $X = 88;
  var $Z = 90;
  var $LBRACKET = 91;
  var $BACKSLASH = 92;
  var $RBRACKET = 93;
  var $CARET = 94;
  var $_ = 95;
  var $a = 97;
  var $e = 101;
  var $f = 102;
  var $n = 110;
  var $r = 114;
  var $t = 116;
  var $u = 117;
  var $v = 118;
  var $x = 120;
  var $z = 122;
  var $LBRACE = 123;
  var $BAR = 124;
  var $RBRACE = 125;
  var $NBSP = 160;
  var $BT = 96;
  function isWhitespace(code) {
    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
  }
  function isDigit(code) {
    return $0 <= code && code <= $9;
  }
  function isAsciiLetter(code) {
    return code >= $a && code <= $z || code >= $A && code <= $Z;
  }
  function isAsciiHexDigit(code) {
    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
  }
  function CompilerInjectable() {
    return function(x) {
      return x;
    };
  }
  function assertArrayOfStrings(identifier, value) {
    if (!_angular_core.isDevMode() || value == null) {
      return;
    }
    if (!Array.isArray(value)) {
      throw new Error("Expected '" + identifier + "' to be an array of strings.");
    }
    for (var i = 0; i < value.length; i += 1) {
      if (typeof value[i] !== 'string') {
        throw new Error("Expected '" + identifier + "' to be an array of strings.");
      }
    }
  }
  var INTERPOLATION_BLACKLIST_REGEXPS = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
  function assertInterpolationSymbols(identifier, value) {
    if (value != null && !(Array.isArray(value) && value.length == 2)) {
      throw new Error("Expected '" + identifier + "' to be an array, [start, end].");
    } else if (_angular_core.isDevMode() && value != null) {
      var start_1 = (value[0]);
      var end_1 = (value[1]);
      INTERPOLATION_BLACKLIST_REGEXPS.forEach(function(regexp) {
        if (regexp.test(start_1) || regexp.test(end_1)) {
          throw new Error("['" + start_1 + "', '" + end_1 + "'] contains unusable interpolation symbol.");
        }
      });
    }
  }
  var InterpolationConfig = (function() {
    function InterpolationConfig(start, end) {
      this.start = start;
      this.end = end;
    }
    InterpolationConfig.fromArray = function(markers) {
      if (!markers) {
        return DEFAULT_INTERPOLATION_CONFIG;
      }
      assertInterpolationSymbols('interpolation', markers);
      return new InterpolationConfig(markers[0], markers[1]);
    };
    return InterpolationConfig;
  }());
  var DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');
  var TokenType = {};
  TokenType.Character = 0;
  TokenType.Identifier = 1;
  TokenType.Keyword = 2;
  TokenType.String = 3;
  TokenType.Operator = 4;
  TokenType.Number = 5;
  TokenType.Error = 6;
  TokenType[TokenType.Character] = "Character";
  TokenType[TokenType.Identifier] = "Identifier";
  TokenType[TokenType.Keyword] = "Keyword";
  TokenType[TokenType.String] = "String";
  TokenType[TokenType.Operator] = "Operator";
  TokenType[TokenType.Number] = "Number";
  TokenType[TokenType.Error] = "Error";
  var KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];
  var Lexer = (function() {
    function Lexer() {}
    Lexer.prototype.tokenize = function(text) {
      var scanner = new _Scanner(text);
      var tokens = [];
      var token = scanner.scanToken();
      while (token != null) {
        tokens.push(token);
        token = scanner.scanToken();
      }
      return tokens;
    };
    return Lexer;
  }());
  Lexer.decorators = [{type: CompilerInjectable}];
  Lexer.ctorParameters = function() {
    return [];
  };
  var Token = (function() {
    function Token(index, type, numValue, strValue) {
      this.index = index;
      this.type = type;
      this.numValue = numValue;
      this.strValue = strValue;
    }
    Token.prototype.isCharacter = function(code) {
      return this.type == TokenType.Character && this.numValue == code;
    };
    Token.prototype.isNumber = function() {
      return this.type == TokenType.Number;
    };
    Token.prototype.isString = function() {
      return this.type == TokenType.String;
    };
    Token.prototype.isOperator = function(operater) {
      return this.type == TokenType.Operator && this.strValue == operater;
    };
    Token.prototype.isIdentifier = function() {
      return this.type == TokenType.Identifier;
    };
    Token.prototype.isKeyword = function() {
      return this.type == TokenType.Keyword;
    };
    Token.prototype.isKeywordLet = function() {
      return this.type == TokenType.Keyword && this.strValue == 'let';
    };
    Token.prototype.isKeywordAs = function() {
      return this.type == TokenType.Keyword && this.strValue == 'as';
    };
    Token.prototype.isKeywordNull = function() {
      return this.type == TokenType.Keyword && this.strValue == 'null';
    };
    Token.prototype.isKeywordUndefined = function() {
      return this.type == TokenType.Keyword && this.strValue == 'undefined';
    };
    Token.prototype.isKeywordTrue = function() {
      return this.type == TokenType.Keyword && this.strValue == 'true';
    };
    Token.prototype.isKeywordFalse = function() {
      return this.type == TokenType.Keyword && this.strValue == 'false';
    };
    Token.prototype.isKeywordThis = function() {
      return this.type == TokenType.Keyword && this.strValue == 'this';
    };
    Token.prototype.isError = function() {
      return this.type == TokenType.Error;
    };
    Token.prototype.toNumber = function() {
      return this.type == TokenType.Number ? this.numValue : -1;
    };
    Token.prototype.toString = function() {
      switch (this.type) {
        case TokenType.Character:
        case TokenType.Identifier:
        case TokenType.Keyword:
        case TokenType.Operator:
        case TokenType.String:
        case TokenType.Error:
          return this.strValue;
        case TokenType.Number:
          return this.numValue.toString();
        default:
          return null;
      }
    };
    return Token;
  }());
  function newCharacterToken(index, code) {
    return new Token(index, TokenType.Character, code, String.fromCharCode(code));
  }
  function newIdentifierToken(index, text) {
    return new Token(index, TokenType.Identifier, 0, text);
  }
  function newKeywordToken(index, text) {
    return new Token(index, TokenType.Keyword, 0, text);
  }
  function newOperatorToken(index, text) {
    return new Token(index, TokenType.Operator, 0, text);
  }
  function newStringToken(index, text) {
    return new Token(index, TokenType.String, 0, text);
  }
  function newNumberToken(index, n) {
    return new Token(index, TokenType.Number, n, '');
  }
  function newErrorToken(index, message) {
    return new Token(index, TokenType.Error, 0, message);
  }
  var EOF = new Token(-1, TokenType.Character, 0, '');
  var _Scanner = (function() {
    function _Scanner(input) {
      this.input = input;
      this.peek = 0;
      this.index = -1;
      this.length = input.length;
      this.advance();
    }
    _Scanner.prototype.advance = function() {
      this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
    };
    _Scanner.prototype.scanToken = function() {
      var input = this.input,
          length = this.length;
      var peek = this.peek,
          index = this.index;
      while (peek <= $SPACE) {
        if (++index >= length) {
          peek = $EOF;
          break;
        } else {
          peek = input.charCodeAt(index);
        }
      }
      this.peek = peek;
      this.index = index;
      if (index >= length) {
        return null;
      }
      if (isIdentifierStart(peek))
        return this.scanIdentifier();
      if (isDigit(peek))
        return this.scanNumber(index);
      var start = index;
      switch (peek) {
        case $PERIOD:
          this.advance();
          return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, $PERIOD);
        case $LPAREN:
        case $RPAREN:
        case $LBRACE:
        case $RBRACE:
        case $LBRACKET:
        case $RBRACKET:
        case $COMMA:
        case $COLON:
        case $SEMICOLON:
          return this.scanCharacter(start, peek);
        case $SQ:
        case $DQ:
          return this.scanString();
        case $HASH:
        case $PLUS:
        case $MINUS:
        case $STAR:
        case $SLASH:
        case $PERCENT:
        case $CARET:
          return this.scanOperator(start, String.fromCharCode(peek));
        case $QUESTION:
          return this.scanComplexOperator(start, '?', $PERIOD, '.');
        case $LT:
        case $GT:
          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');
        case $BANG:
        case $EQ:
          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');
        case $AMPERSAND:
          return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
        case $BAR:
          return this.scanComplexOperator(start, '|', $BAR, '|');
        case $NBSP:
          while (isWhitespace(this.peek))
            this.advance();
          return this.scanToken();
      }
      this.advance();
      return this.error("Unexpected character [" + String.fromCharCode(peek) + "]", 0);
    };
    _Scanner.prototype.scanCharacter = function(start, code) {
      this.advance();
      return newCharacterToken(start, code);
    };
    _Scanner.prototype.scanOperator = function(start, str) {
      this.advance();
      return newOperatorToken(start, str);
    };
    _Scanner.prototype.scanComplexOperator = function(start, one, twoCode, two, threeCode, three) {
      this.advance();
      var str = one;
      if (this.peek == twoCode) {
        this.advance();
        str += two;
      }
      if (threeCode != null && this.peek == threeCode) {
        this.advance();
        str += three;
      }
      return newOperatorToken(start, str);
    };
    _Scanner.prototype.scanIdentifier = function() {
      var start = this.index;
      this.advance();
      while (isIdentifierPart(this.peek))
        this.advance();
      var str = this.input.substring(start, this.index);
      return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) : newIdentifierToken(start, str);
    };
    _Scanner.prototype.scanNumber = function(start) {
      var simple = (this.index === start);
      this.advance();
      while (true) {
        if (isDigit(this.peek)) {} else if (this.peek == $PERIOD) {
          simple = false;
        } else if (isExponentStart(this.peek)) {
          this.advance();
          if (isExponentSign(this.peek))
            this.advance();
          if (!isDigit(this.peek))
            return this.error('Invalid exponent', -1);
          simple = false;
        } else {
          break;
        }
        this.advance();
      }
      var str = this.input.substring(start, this.index);
      var value = simple ? parseIntAutoRadix(str) : parseFloat(str);
      return newNumberToken(start, value);
    };
    _Scanner.prototype.scanString = function() {
      var start = this.index;
      var quote = this.peek;
      this.advance();
      var buffer = '';
      var marker = this.index;
      var input = this.input;
      while (this.peek != quote) {
        if (this.peek == $BACKSLASH) {
          buffer += input.substring(marker, this.index);
          this.advance();
          var unescapedCode = void 0;
          this.peek = this.peek;
          if (this.peek == $u) {
            var hex = input.substring(this.index + 1, this.index + 5);
            if (/^[0-9a-f]+$/i.test(hex)) {
              unescapedCode = parseInt(hex, 16);
            } else {
              return this.error("Invalid unicode escape [\\u" + hex + "]", 0);
            }
            for (var i = 0; i < 5; i++) {
              this.advance();
            }
          } else {
            unescapedCode = unescape(this.peek);
            this.advance();
          }
          buffer += String.fromCharCode(unescapedCode);
          marker = this.index;
        } else if (this.peek == $EOF) {
          return this.error('Unterminated quote', 0);
        } else {
          this.advance();
        }
      }
      var last = input.substring(marker, this.index);
      this.advance();
      return newStringToken(start, buffer + last);
    };
    _Scanner.prototype.error = function(message, offset) {
      var position = this.index + offset;
      return newErrorToken(position, "Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
    };
    return _Scanner;
  }());
  function isIdentifierStart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || (code == $_) || (code == $$);
  }
  function isIdentifier(input) {
    if (input.length == 0)
      return false;
    var scanner = new _Scanner(input);
    if (!isIdentifierStart(scanner.peek))
      return false;
    scanner.advance();
    while (scanner.peek !== $EOF) {
      if (!isIdentifierPart(scanner.peek))
        return false;
      scanner.advance();
    }
    return true;
  }
  function isIdentifierPart(code) {
    return isAsciiLetter(code) || isDigit(code) || (code == $_) || (code == $$);
  }
  function isExponentStart(code) {
    return code == $e || code == $E;
  }
  function isExponentSign(code) {
    return code == $MINUS || code == $PLUS;
  }
  function isQuote(code) {
    return code === $SQ || code === $DQ || code === $BT;
  }
  function unescape(code) {
    switch (code) {
      case $n:
        return $LF;
      case $f:
        return $FF;
      case $r:
        return $CR;
      case $t:
        return $TAB;
      case $v:
        return $VTAB;
      default:
        return code;
    }
  }
  function parseIntAutoRadix(text) {
    var result = parseInt(text);
    if (isNaN(result)) {
      throw new Error('Invalid integer literal when parsing ' + text);
    }
    return result;
  }
  var SplitInterpolation = (function() {
    function SplitInterpolation(strings, expressions, offsets) {
      this.strings = strings;
      this.expressions = expressions;
      this.offsets = offsets;
    }
    return SplitInterpolation;
  }());
  var TemplateBindingParseResult = (function() {
    function TemplateBindingParseResult(templateBindings, warnings, errors) {
      this.templateBindings = templateBindings;
      this.warnings = warnings;
      this.errors = errors;
    }
    return TemplateBindingParseResult;
  }());
  function _createInterpolateRegExp(config) {
    var pattern = escapeRegExp(config.start) + '([\\s\\S]*?)' + escapeRegExp(config.end);
    return new RegExp(pattern, 'g');
  }
  var Parser = (function() {
    function Parser(_lexer) {
      this._lexer = _lexer;
      this.errors = [];
    }
    Parser.prototype.parseAction = function(input, location, interpolationConfig) {
      if (interpolationConfig === void 0) {
        interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;
      }
      this._checkNoInterpolation(input, location, interpolationConfig);
      var sourceToLex = this._stripComments(input);
      var tokens = this._lexer.tokenize(this._stripComments(input));
      var ast = new _ParseAST(input, location, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length).parseChain();
      return new ASTWithSource(ast, input, location, this.errors);
    };
    Parser.prototype.parseBinding = function(input, location, interpolationConfig) {
      if (interpolationConfig === void 0) {
        interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;
      }
      var ast = this._parseBindingAst(input, location, interpolationConfig);
      return new ASTWithSource(ast, input, location, this.errors);
    };
    Parser.prototype.parseSimpleBinding = function(input, location, interpolationConfig) {
      if (interpolationConfig === void 0) {
        interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;
      }
      var ast = this._parseBindingAst(input, location, interpolationConfig);
      var errors = SimpleExpressionChecker.check(ast);
      if (errors.length > 0) {
        this._reportError("Host binding expression cannot contain " + errors.join(' '), input, location);
      }
      return new ASTWithSource(ast, input, location, this.errors);
    };
    Parser.prototype._reportError = function(message, input, errLocation, ctxLocation) {
      this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
    };
    Parser.prototype._parseBindingAst = function(input, location, interpolationConfig) {
      var quote = this._parseQuote(input, location);
      if (quote != null) {
        return quote;
      }
      this._checkNoInterpolation(input, location, interpolationConfig);
      var sourceToLex = this._stripComments(input);
      var tokens = this._lexer.tokenize(sourceToLex);
      return new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length).parseChain();
    };
    Parser.prototype._parseQuote = function(input, location) {
      if (input == null)
        return null;
      var prefixSeparatorIndex = input.indexOf(':');
      if (prefixSeparatorIndex == -1)
        return null;
      var prefix = input.substring(0, prefixSeparatorIndex).trim();
      if (!isIdentifier(prefix))
        return null;
      var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
      return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);
    };
    Parser.prototype.parseTemplateBindings = function(prefixToken, input, location) {
      var tokens = this._lexer.tokenize(input);
      if (prefixToken) {
        var prefixTokens = this._lexer.tokenize(prefixToken).map(function(t) {
          t.index = 0;
          return t;
        });
        tokens.unshift.apply(tokens, prefixTokens);
      }
      return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0).parseTemplateBindings();
    };
    Parser.prototype.parseInterpolation = function(input, location, interpolationConfig) {
      if (interpolationConfig === void 0) {
        interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;
      }
      var split = this.splitInterpolation(input, location, interpolationConfig);
      if (split == null)
        return null;
      var expressions = [];
      for (var i = 0; i < split.expressions.length; ++i) {
        var expressionText = split.expressions[i];
        var sourceToLex = this._stripComments(expressionText);
        var tokens = this._lexer.tokenize(sourceToLex);
        var ast = new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length)).parseChain();
        expressions.push(ast);
      }
      return new ASTWithSource(new Interpolation(new ParseSpan(0, input == null ? 0 : input.length), split.strings, expressions), input, location, this.errors);
    };
    Parser.prototype.splitInterpolation = function(input, location, interpolationConfig) {
      if (interpolationConfig === void 0) {
        interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;
      }
      var regexp = _createInterpolateRegExp(interpolationConfig);
      var parts = input.split(regexp);
      if (parts.length <= 1) {
        return null;
      }
      var strings = [];
      var expressions = [];
      var offsets = [];
      var offset = 0;
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (i % 2 === 0) {
          strings.push(part);
          offset += part.length;
        } else if (part.trim().length > 0) {
          offset += interpolationConfig.start.length;
          expressions.push(part);
          offsets.push(offset);
          offset += part.length + interpolationConfig.end.length;
        } else {
          this._reportError('Blank expressions are not allowed in interpolated strings', input, "at column " + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + " in", location);
          expressions.push('$implict');
          offsets.push(offset);
        }
      }
      return new SplitInterpolation(strings, expressions, offsets);
    };
    Parser.prototype.wrapLiteralPrimitive = function(input, location) {
      return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, input == null ? 0 : input.length), input), input, location, this.errors);
    };
    Parser.prototype._stripComments = function(input) {
      var i = this._commentStart(input);
      return i != null ? input.substring(0, i).trim() : input;
    };
    Parser.prototype._commentStart = function(input) {
      var outerQuote = null;
      for (var i = 0; i < input.length - 1; i++) {
        var char = input.charCodeAt(i);
        var nextChar = input.charCodeAt(i + 1);
        if (char === $SLASH && nextChar == $SLASH && outerQuote == null)
          return i;
        if (outerQuote === char) {
          outerQuote = null;
        } else if (outerQuote == null && isQuote(char)) {
          outerQuote = char;
        }
      }
      return null;
    };
    Parser.prototype._checkNoInterpolation = function(input, location, interpolationConfig) {
      var regexp = _createInterpolateRegExp(interpolationConfig);
      var parts = input.split(regexp);
      if (parts.length > 1) {
        this._reportError("Got interpolation (" + interpolationConfig.start + interpolationConfig.end + ") where expression was expected", input, "at column " + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + " in", location);
      }
    };
    Parser.prototype._findInterpolationErrorColumn = function(parts, partInErrIdx, interpolationConfig) {
      var errLocation = '';
      for (var j = 0; j < partInErrIdx; j++) {
        errLocation += j % 2 === 0 ? parts[j] : "" + interpolationConfig.start + parts[j] + interpolationConfig.end;
      }
      return errLocation.length;
    };
    return Parser;
  }());
  Parser.decorators = [{type: CompilerInjectable}];
  Parser.ctorParameters = function() {
    return [{type: Lexer}];
  };
  var _ParseAST = (function() {
    function _ParseAST(input, location, tokens, inputLength, parseAction, errors, offset) {
      this.input = input;
      this.location = location;
      this.tokens = tokens;
      this.inputLength = inputLength;
      this.parseAction = parseAction;
      this.errors = errors;
      this.offset = offset;
      this.rparensExpected = 0;
      this.rbracketsExpected = 0;
      this.rbracesExpected = 0;
      this.index = 0;
    }
    _ParseAST.prototype.peek = function(offset) {
      var i = this.index + offset;
      return i < this.tokens.length ? this.tokens[i] : EOF;
    };
    Object.defineProperty(_ParseAST.prototype, "next", {
      get: function() {
        return this.peek(0);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(_ParseAST.prototype, "inputIndex", {
      get: function() {
        return (this.index < this.tokens.length) ? this.next.index + this.offset : this.inputLength + this.offset;
      },
      enumerable: true,
      configurable: true
    });
    _ParseAST.prototype.span = function(start) {
      return new ParseSpan(start, this.inputIndex);
    };
    _ParseAST.prototype.advance = function() {
      this.index++;
    };
    _ParseAST.prototype.optionalCharacter = function(code) {
      if (this.next.isCharacter(code)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    };
    _ParseAST.prototype.peekKeywordLet = function() {
      return this.next.isKeywordLet();
    };
    _ParseAST.prototype.peekKeywordAs = function() {
      return this.next.isKeywordAs();
    };
    _ParseAST.prototype.expectCharacter = function(code) {
      if (this.optionalCharacter(code))
        return;
      this.error("Missing expected " + String.fromCharCode(code));
    };
    _ParseAST.prototype.optionalOperator = function(op) {
      if (this.next.isOperator(op)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    };
    _ParseAST.prototype.expectOperator = function(operator) {
      if (this.optionalOperator(operator))
        return;
      this.error("Missing expected operator " + operator);
    };
    _ParseAST.prototype.expectIdentifierOrKeyword = function() {
      var n = this.next;
      if (!n.isIdentifier() && !n.isKeyword()) {
        this.error("Unexpected token " + n + ", expected identifier or keyword");
        return '';
      }
      this.advance();
      return (n.toString());
    };
    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function() {
      var n = this.next;
      if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
        this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
        return '';
      }
      this.advance();
      return (n.toString());
    };
    _ParseAST.prototype.parseChain = function() {
      var exprs = [];
      var start = this.inputIndex;
      while (this.index < this.tokens.length) {
        var expr = this.parsePipe();
        exprs.push(expr);
        if (this.optionalCharacter($SEMICOLON)) {
          if (!this.parseAction) {
            this.error('Binding expression cannot contain chained expression');
          }
          while (this.optionalCharacter($SEMICOLON)) {}
        } else if (this.index < this.tokens.length) {
          this.error("Unexpected token '" + this.next + "'");
        }
      }
      if (exprs.length == 0)
        return new EmptyExpr(this.span(start));
      if (exprs.length == 1)
        return exprs[0];
      return new Chain(this.span(start), exprs);
    };
    _ParseAST.prototype.parsePipe = function() {
      var result = this.parseExpression();
      if (this.optionalOperator('|')) {
        if (this.parseAction) {
          this.error('Cannot have a pipe in an action expression');
        }
        do {
          var name = this.expectIdentifierOrKeyword();
          var args = [];
          while (this.optionalCharacter($COLON)) {
            args.push(this.parseExpression());
          }
          result = new BindingPipe(this.span(result.span.start), result, name, args);
        } while (this.optionalOperator('|'));
      }
      return result;
    };
    _ParseAST.prototype.parseExpression = function() {
      return this.parseConditional();
    };
    _ParseAST.prototype.parseConditional = function() {
      var start = this.inputIndex;
      var result = this.parseLogicalOr();
      if (this.optionalOperator('?')) {
        var yes = this.parsePipe();
        var no = void 0;
        if (!this.optionalCharacter($COLON)) {
          var end = this.inputIndex;
          var expression = this.input.substring(start, end);
          this.error("Conditional expression " + expression + " requires all 3 expressions");
          no = new EmptyExpr(this.span(start));
        } else {
          no = this.parsePipe();
        }
        return new Conditional(this.span(start), result, yes, no);
      } else {
        return result;
      }
    };
    _ParseAST.prototype.parseLogicalOr = function() {
      var result = this.parseLogicalAnd();
      while (this.optionalOperator('||')) {
        var right = this.parseLogicalAnd();
        result = new Binary(this.span(result.span.start), '||', result, right);
      }
      return result;
    };
    _ParseAST.prototype.parseLogicalAnd = function() {
      var result = this.parseEquality();
      while (this.optionalOperator('&&')) {
        var right = this.parseEquality();
        result = new Binary(this.span(result.span.start), '&&', result, right);
      }
      return result;
    };
    _ParseAST.prototype.parseEquality = function() {
      var result = this.parseRelational();
      while (this.next.type == TokenType.Operator) {
        var operator = this.next.strValue;
        switch (operator) {
          case '==':
          case '===':
          case '!=':
          case '!==':
            this.advance();
            var right = this.parseRelational();
            result = new Binary(this.span(result.span.start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    };
    _ParseAST.prototype.parseRelational = function() {
      var result = this.parseAdditive();
      while (this.next.type == TokenType.Operator) {
        var operator = this.next.strValue;
        switch (operator) {
          case '<':
          case '>':
          case '<=':
          case '>=':
            this.advance();
            var right = this.parseAdditive();
            result = new Binary(this.span(result.span.start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    };
    _ParseAST.prototype.parseAdditive = function() {
      var result = this.parseMultiplicative();
      while (this.next.type == TokenType.Operator) {
        var operator = this.next.strValue;
        switch (operator) {
          case '+':
          case '-':
            this.advance();
            var right = this.parseMultiplicative();
            result = new Binary(this.span(result.span.start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    };
    _ParseAST.prototype.parseMultiplicative = function() {
      var result = this.parsePrefix();
      while (this.next.type == TokenType.Operator) {
        var operator = this.next.strValue;
        switch (operator) {
          case '*':
          case '%':
          case '/':
            this.advance();
            var right = this.parsePrefix();
            result = new Binary(this.span(result.span.start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    };
    _ParseAST.prototype.parsePrefix = function() {
      if (this.next.type == TokenType.Operator) {
        var start = this.inputIndex;
        var operator = this.next.strValue;
        var result = void 0;
        switch (operator) {
          case '+':
            this.advance();
            return this.parsePrefix();
          case '-':
            this.advance();
            result = this.parsePrefix();
            return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);
          case '!':
            this.advance();
            result = this.parsePrefix();
            return new PrefixNot(this.span(start), result);
        }
      }
      return this.parseCallChain();
    };
    _ParseAST.prototype.parseCallChain = function() {
      var result = this.parsePrimary();
      while (true) {
        if (this.optionalCharacter($PERIOD)) {
          result = this.parseAccessMemberOrMethodCall(result, false);
        } else if (this.optionalOperator('?.')) {
          result = this.parseAccessMemberOrMethodCall(result, true);
        } else if (this.optionalCharacter($LBRACKET)) {
          this.rbracketsExpected++;
          var key = this.parsePipe();
          this.rbracketsExpected--;
          this.expectCharacter($RBRACKET);
          if (this.optionalOperator('=')) {
            var value = this.parseConditional();
            result = new KeyedWrite(this.span(result.span.start), result, key, value);
          } else {
            result = new KeyedRead(this.span(result.span.start), result, key);
          }
        } else if (this.optionalCharacter($LPAREN)) {
          this.rparensExpected++;
          var args = this.parseCallArguments();
          this.rparensExpected--;
          this.expectCharacter($RPAREN);
          result = new FunctionCall(this.span(result.span.start), result, args);
        } else if (this.optionalOperator('!')) {
          result = new NonNullAssert(this.span(result.span.start), result);
        } else {
          return result;
        }
      }
    };
    _ParseAST.prototype.parsePrimary = function() {
      var start = this.inputIndex;
      if (this.optionalCharacter($LPAREN)) {
        this.rparensExpected++;
        var result = this.parsePipe();
        this.rparensExpected--;
        this.expectCharacter($RPAREN);
        return result;
      } else if (this.next.isKeywordNull()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), null);
      } else if (this.next.isKeywordUndefined()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), void 0);
      } else if (this.next.isKeywordTrue()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), true);
      } else if (this.next.isKeywordFalse()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), false);
      } else if (this.next.isKeywordThis()) {
        this.advance();
        return new ImplicitReceiver(this.span(start));
      } else if (this.optionalCharacter($LBRACKET)) {
        this.rbracketsExpected++;
        var elements = this.parseExpressionList($RBRACKET);
        this.rbracketsExpected--;
        this.expectCharacter($RBRACKET);
        return new LiteralArray(this.span(start), elements);
      } else if (this.next.isCharacter($LBRACE)) {
        return this.parseLiteralMap();
      } else if (this.next.isIdentifier()) {
        return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);
      } else if (this.next.isNumber()) {
        var value = this.next.toNumber();
        this.advance();
        return new LiteralPrimitive(this.span(start), value);
      } else if (this.next.isString()) {
        var literalValue = this.next.toString();
        this.advance();
        return new LiteralPrimitive(this.span(start), literalValue);
      } else if (this.index >= this.tokens.length) {
        this.error("Unexpected end of expression: " + this.input);
        return new EmptyExpr(this.span(start));
      } else {
        this.error("Unexpected token " + this.next);
        return new EmptyExpr(this.span(start));
      }
    };
    _ParseAST.prototype.parseExpressionList = function(terminator) {
      var result = [];
      if (!this.next.isCharacter(terminator)) {
        do {
          result.push(this.parsePipe());
        } while (this.optionalCharacter($COMMA));
      }
      return result;
    };
    _ParseAST.prototype.parseLiteralMap = function() {
      var keys = [];
      var values = [];
      var start = this.inputIndex;
      this.expectCharacter($LBRACE);
      if (!this.optionalCharacter($RBRACE)) {
        this.rbracesExpected++;
        do {
          var quoted = this.next.isString();
          var key = this.expectIdentifierOrKeywordOrString();
          keys.push({
            key: key,
            quoted: quoted
          });
          this.expectCharacter($COLON);
          values.push(this.parsePipe());
        } while (this.optionalCharacter($COMMA));
        this.rbracesExpected--;
        this.expectCharacter($RBRACE);
      }
      return new LiteralMap(this.span(start), keys, values);
    };
    _ParseAST.prototype.parseAccessMemberOrMethodCall = function(receiver, isSafe) {
      if (isSafe === void 0) {
        isSafe = false;
      }
      var start = receiver.span.start;
      var id = this.expectIdentifierOrKeyword();
      if (this.optionalCharacter($LPAREN)) {
        this.rparensExpected++;
        var args = this.parseCallArguments();
        this.expectCharacter($RPAREN);
        this.rparensExpected--;
        var span = this.span(start);
        return isSafe ? new SafeMethodCall(span, receiver, id, args) : new MethodCall(span, receiver, id, args);
      } else {
        if (isSafe) {
          if (this.optionalOperator('=')) {
            this.error('The \'?.\' operator cannot be used in the assignment');
            return new EmptyExpr(this.span(start));
          } else {
            return new SafePropertyRead(this.span(start), receiver, id);
          }
        } else {
          if (this.optionalOperator('=')) {
            if (!this.parseAction) {
              this.error('Bindings cannot contain assignments');
              return new EmptyExpr(this.span(start));
            }
            var value = this.parseConditional();
            return new PropertyWrite(this.span(start), receiver, id, value);
          } else {
            return new PropertyRead(this.span(start), receiver, id);
          }
        }
      }
    };
    _ParseAST.prototype.parseCallArguments = function() {
      if (this.next.isCharacter($RPAREN))
        return [];
      var positionals = [];
      do {
        positionals.push(this.parsePipe());
      } while (this.optionalCharacter($COMMA));
      return (positionals);
    };
    _ParseAST.prototype.expectTemplateBindingKey = function() {
      var result = '';
      var operatorFound = false;
      do {
        result += this.expectIdentifierOrKeywordOrString();
        operatorFound = this.optionalOperator('-');
        if (operatorFound) {
          result += '-';
        }
      } while (operatorFound);
      return result.toString();
    };
    _ParseAST.prototype.parseTemplateBindings = function() {
      var bindings = [];
      var prefix = ((null));
      var warnings = [];
      while (this.index < this.tokens.length) {
        var start = this.inputIndex;
        var keyIsVar = this.peekKeywordLet();
        if (keyIsVar) {
          this.advance();
        }
        var rawKey = this.expectTemplateBindingKey();
        var key = rawKey;
        if (!keyIsVar) {
          if (prefix == null) {
            prefix = key;
          } else {
            key = prefix + key[0].toUpperCase() + key.substring(1);
          }
        }
        this.optionalCharacter($COLON);
        var name = ((null));
        var expression = ((null));
        if (keyIsVar) {
          if (this.optionalOperator('=')) {
            name = this.expectTemplateBindingKey();
          } else {
            name = '\$implicit';
          }
        } else if (this.peekKeywordAs()) {
          var letStart = this.inputIndex;
          this.advance();
          name = rawKey;
          key = this.expectTemplateBindingKey();
          keyIsVar = true;
        } else if (this.next !== EOF && !this.peekKeywordLet()) {
          var start_2 = this.inputIndex;
          var ast = this.parsePipe();
          var source = this.input.substring(start_2 - this.offset, this.inputIndex - this.offset);
          expression = new ASTWithSource(ast, source, this.location, this.errors);
        }
        bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));
        if (this.peekKeywordAs() && !keyIsVar) {
          var letStart = this.inputIndex;
          this.advance();
          var letName = this.expectTemplateBindingKey();
          bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, ((null))));
        }
        if (!this.optionalCharacter($SEMICOLON)) {
          this.optionalCharacter($COMMA);
        }
      }
      return new TemplateBindingParseResult(bindings, warnings, this.errors);
    };
    _ParseAST.prototype.error = function(message, index) {
      if (index === void 0) {
        index = null;
      }
      this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
      this.skip();
    };
    _ParseAST.prototype.locationText = function(index) {
      if (index === void 0) {
        index = null;
      }
      if (index == null)
        index = this.index;
      return (index < this.tokens.length) ? "at column " + (this.tokens[index].index + 1) + " in" : "at the end of the expression";
    };
    _ParseAST.prototype.skip = function() {
      var n = this.next;
      while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {
        if (this.next.isError()) {
          this.errors.push(new ParserError(((this.next.toString())), this.input, this.locationText(), this.location));
        }
        this.advance();
        n = this.next;
      }
    };
    return _ParseAST;
  }());
  var SimpleExpressionChecker = (function() {
    function SimpleExpressionChecker() {
      this.errors = [];
    }
    SimpleExpressionChecker.check = function(ast) {
      var s = new SimpleExpressionChecker();
      ast.visit(s);
      return s.errors;
    };
    SimpleExpressionChecker.prototype.visitImplicitReceiver = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitInterpolation = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitPropertyRead = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitPropertyWrite = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitSafePropertyRead = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitMethodCall = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitSafeMethodCall = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitFunctionCall = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitLiteralArray = function(ast, context) {
      this.visitAll(ast.expressions);
    };
    SimpleExpressionChecker.prototype.visitLiteralMap = function(ast, context) {
      this.visitAll(ast.values);
    };
    SimpleExpressionChecker.prototype.visitBinary = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitPrefixNot = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitNonNullAssert = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitConditional = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitPipe = function(ast, context) {
      this.errors.push('pipes');
    };
    SimpleExpressionChecker.prototype.visitKeyedRead = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitKeyedWrite = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitAll = function(asts) {
      var _this = this;
      return asts.map(function(node) {
        return node.visit(_this);
      });
    };
    SimpleExpressionChecker.prototype.visitChain = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitQuote = function(ast, context) {};
    return SimpleExpressionChecker;
  }());
  var ParseLocation = (function() {
    function ParseLocation(file, offset, line, col) {
      this.file = file;
      this.offset = offset;
      this.line = line;
      this.col = col;
    }
    ParseLocation.prototype.toString = function() {
      return this.offset != null ? this.file.url + "@" + this.line + ":" + this.col : this.file.url;
    };
    ParseLocation.prototype.moveBy = function(delta) {
      var source = this.file.content;
      var len = source.length;
      var offset = this.offset;
      var line = this.line;
      var col = this.col;
      while (offset > 0 && delta < 0) {
        offset--;
        delta++;
        var ch = source.charCodeAt(offset);
        if (ch == $LF) {
          line--;
          var priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
          col = priorLine > 0 ? offset - priorLine : offset;
        } else {
          col--;
        }
      }
      while (offset < len && delta > 0) {
        var ch = source.charCodeAt(offset);
        offset++;
        delta--;
        if (ch == $LF) {
          line++;
          col = 0;
        } else {
          col++;
        }
      }
      return new ParseLocation(this.file, offset, line, col);
    };
    ParseLocation.prototype.getContext = function(maxChars, maxLines) {
      var content = this.file.content;
      var startOffset = this.offset;
      if (startOffset != null) {
        if (startOffset > content.length - 1) {
          startOffset = content.length - 1;
        }
        var endOffset = startOffset;
        var ctxChars = 0;
        var ctxLines = 0;
        while (ctxChars < maxChars && startOffset > 0) {
          startOffset--;
          ctxChars++;
          if (content[startOffset] == '\n') {
            if (++ctxLines == maxLines) {
              break;
            }
          }
        }
        ctxChars = 0;
        ctxLines = 0;
        while (ctxChars < maxChars && endOffset < content.length - 1) {
          endOffset++;
          ctxChars++;
          if (content[endOffset] == '\n') {
            if (++ctxLines == maxLines) {
              break;
            }
          }
        }
        return {
          before: content.substring(startOffset, this.offset),
          after: content.substring(this.offset, endOffset + 1)
        };
      }
      return null;
    };
    return ParseLocation;
  }());
  var ParseSourceFile = (function() {
    function ParseSourceFile(content, url) {
      this.content = content;
      this.url = url;
    }
    return ParseSourceFile;
  }());
  var ParseSourceSpan = (function() {
    function ParseSourceSpan(start, end, details) {
      if (details === void 0) {
        details = null;
      }
      this.start = start;
      this.end = end;
      this.details = details;
    }
    ParseSourceSpan.prototype.toString = function() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    };
    return ParseSourceSpan;
  }());
  var ParseErrorLevel = {};
  ParseErrorLevel.WARNING = 0;
  ParseErrorLevel.ERROR = 1;
  ParseErrorLevel[ParseErrorLevel.WARNING] = "WARNING";
  ParseErrorLevel[ParseErrorLevel.ERROR] = "ERROR";
  var ParseError = (function() {
    function ParseError(span, msg, level) {
      if (level === void 0) {
        level = ParseErrorLevel.ERROR;
      }
      this.span = span;
      this.msg = msg;
      this.level = level;
    }
    ParseError.prototype.contextualMessage = function() {
      var ctx = this.span.start.getContext(100, 3);
      return ctx ? " (\"" + ctx.before + "[" + ParseErrorLevel[this.level] + " ->]" + ctx.after + "\")" : '';
    };
    ParseError.prototype.toString = function() {
      var details = this.span.details ? ", " + this.span.details : '';
      return "" + this.msg + this.contextualMessage() + ": " + this.span.start + details;
    };
    return ParseError;
  }());
  function typeSourceSpan(kind, type) {
    var moduleUrl = identifierModuleUrl(type);
    var sourceFileName = moduleUrl != null ? "in " + kind + " " + identifierName(type) + " in " + moduleUrl : "in " + kind + " " + identifierName(type);
    var sourceFile = new ParseSourceFile('', sourceFileName);
    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
  }
  var AstPath = (function() {
    function AstPath(path, position) {
      if (position === void 0) {
        position = -1;
      }
      this.path = path;
      this.position = position;
    }
    Object.defineProperty(AstPath.prototype, "empty", {
      get: function() {
        return !this.path || !this.path.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AstPath.prototype, "head", {
      get: function() {
        return this.path[0];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AstPath.prototype, "tail", {
      get: function() {
        return this.path[this.path.length - 1];
      },
      enumerable: true,
      configurable: true
    });
    AstPath.prototype.parentOf = function(node) {
      return node && this.path[this.path.indexOf(node) - 1];
    };
    AstPath.prototype.childOf = function(node) {
      return this.path[this.path.indexOf(node) + 1];
    };
    AstPath.prototype.first = function(ctor) {
      for (var i = this.path.length - 1; i >= 0; i--) {
        var item = this.path[i];
        if (item instanceof ctor)
          return (item);
      }
    };
    AstPath.prototype.push = function(node) {
      this.path.push(node);
    };
    AstPath.prototype.pop = function() {
      return ((this.path.pop()));
    };
    return AstPath;
  }());
  var Text = (function() {
    function Text(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    Text.prototype.visit = function(visitor, context) {
      return visitor.visitText(this, context);
    };
    return Text;
  }());
  var Expansion = (function() {
    function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {
      this.switchValue = switchValue;
      this.type = type;
      this.cases = cases;
      this.sourceSpan = sourceSpan;
      this.switchValueSourceSpan = switchValueSourceSpan;
    }
    Expansion.prototype.visit = function(visitor, context) {
      return visitor.visitExpansion(this, context);
    };
    return Expansion;
  }());
  var ExpansionCase = (function() {
    function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
      this.value = value;
      this.expression = expression;
      this.sourceSpan = sourceSpan;
      this.valueSourceSpan = valueSourceSpan;
      this.expSourceSpan = expSourceSpan;
    }
    ExpansionCase.prototype.visit = function(visitor, context) {
      return visitor.visitExpansionCase(this, context);
    };
    return ExpansionCase;
  }());
  var Attribute$1 = (function() {
    function Attribute$1(name, value, sourceSpan, valueSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
      this.valueSpan = valueSpan;
    }
    Attribute$1.prototype.visit = function(visitor, context) {
      return visitor.visitAttribute(this, context);
    };
    return Attribute$1;
  }());
  var Element = (function() {
    function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {
      if (startSourceSpan === void 0) {
        startSourceSpan = null;
      }
      if (endSourceSpan === void 0) {
        endSourceSpan = null;
      }
      this.name = name;
      this.attrs = attrs;
      this.children = children;
      this.sourceSpan = sourceSpan;
      this.startSourceSpan = startSourceSpan;
      this.endSourceSpan = endSourceSpan;
    }
    Element.prototype.visit = function(visitor, context) {
      return visitor.visitElement(this, context);
    };
    return Element;
  }());
  var Comment = (function() {
    function Comment(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    Comment.prototype.visit = function(visitor, context) {
      return visitor.visitComment(this, context);
    };
    return Comment;
  }());
  function visitAll(visitor, nodes, context) {
    if (context === void 0) {
      context = null;
    }
    var result = [];
    var visit = visitor.visit ? function(ast) {
      return ((visitor.visit))(ast, context) || ast.visit(visitor, context);
    } : function(ast) {
      return ast.visit(visitor, context);
    };
    nodes.forEach(function(ast) {
      var astResult = visit(ast);
      if (astResult) {
        result.push(astResult);
      }
    });
    return result;
  }
  var RecursiveVisitor = (function() {
    function RecursiveVisitor() {}
    RecursiveVisitor.prototype.visitElement = function(ast, context) {
      this.visitChildren(context, function(visit) {
        visit(ast.attrs);
        visit(ast.children);
      });
    };
    RecursiveVisitor.prototype.visitAttribute = function(ast, context) {};
    RecursiveVisitor.prototype.visitText = function(ast, context) {};
    RecursiveVisitor.prototype.visitComment = function(ast, context) {};
    RecursiveVisitor.prototype.visitExpansion = function(ast, context) {
      return this.visitChildren(context, function(visit) {
        visit(ast.cases);
      });
    };
    RecursiveVisitor.prototype.visitExpansionCase = function(ast, context) {};
    RecursiveVisitor.prototype.visitChildren = function(context, cb) {
      var results = [];
      var t = this;
      function visit(children) {
        if (children)
          results.push(visitAll(t, children, context));
      }
      cb(visit);
      return [].concat.apply([], results);
    };
    return RecursiveVisitor;
  }());
  function spanOf(ast) {
    var start = ast.sourceSpan.start.offset;
    var end = ast.sourceSpan.end.offset;
    if (ast instanceof Element) {
      if (ast.endSourceSpan) {
        end = ast.endSourceSpan.end.offset;
      } else if (ast.children && ast.children.length) {
        end = spanOf(ast.children[ast.children.length - 1]).end;
      }
    }
    return {
      start: start,
      end: end
    };
  }
  function findNode(nodes, position) {
    var path = [];
    var visitor = new (function(_super) {
      __extends(class_1, _super);
      function class_1() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      class_1.prototype.visit = function(ast, context) {
        var span = spanOf(ast);
        if (span.start <= position && position < span.end) {
          path.push(ast);
        } else {
          return true;
        }
      };
      return class_1;
    }(RecursiveVisitor));
    visitAll(visitor, nodes);
    return new AstPath(path, position);
  }
  var TokenType$1 = {};
  TokenType$1.TAG_OPEN_START = 0;
  TokenType$1.TAG_OPEN_END = 1;
  TokenType$1.TAG_OPEN_END_VOID = 2;
  TokenType$1.TAG_CLOSE = 3;
  TokenType$1.TEXT = 4;
  TokenType$1.ESCAPABLE_RAW_TEXT = 5;
  TokenType$1.RAW_TEXT = 6;
  TokenType$1.COMMENT_START = 7;
  TokenType$1.COMMENT_END = 8;
  TokenType$1.CDATA_START = 9;
  TokenType$1.CDATA_END = 10;
  TokenType$1.ATTR_NAME = 11;
  TokenType$1.ATTR_VALUE = 12;
  TokenType$1.DOC_TYPE = 13;
  TokenType$1.EXPANSION_FORM_START = 14;
  TokenType$1.EXPANSION_CASE_VALUE = 15;
  TokenType$1.EXPANSION_CASE_EXP_START = 16;
  TokenType$1.EXPANSION_CASE_EXP_END = 17;
  TokenType$1.EXPANSION_FORM_END = 18;
  TokenType$1.EOF = 19;
  TokenType$1[TokenType$1.TAG_OPEN_START] = "TAG_OPEN_START";
  TokenType$1[TokenType$1.TAG_OPEN_END] = "TAG_OPEN_END";
  TokenType$1[TokenType$1.TAG_OPEN_END_VOID] = "TAG_OPEN_END_VOID";
  TokenType$1[TokenType$1.TAG_CLOSE] = "TAG_CLOSE";
  TokenType$1[TokenType$1.TEXT] = "TEXT";
  TokenType$1[TokenType$1.ESCAPABLE_RAW_TEXT] = "ESCAPABLE_RAW_TEXT";
  TokenType$1[TokenType$1.RAW_TEXT] = "RAW_TEXT";
  TokenType$1[TokenType$1.COMMENT_START] = "COMMENT_START";
  TokenType$1[TokenType$1.COMMENT_END] = "COMMENT_END";
  TokenType$1[TokenType$1.CDATA_START] = "CDATA_START";
  TokenType$1[TokenType$1.CDATA_END] = "CDATA_END";
  TokenType$1[TokenType$1.ATTR_NAME] = "ATTR_NAME";
  TokenType$1[TokenType$1.ATTR_VALUE] = "ATTR_VALUE";
  TokenType$1[TokenType$1.DOC_TYPE] = "DOC_TYPE";
  TokenType$1[TokenType$1.EXPANSION_FORM_START] = "EXPANSION_FORM_START";
  TokenType$1[TokenType$1.EXPANSION_CASE_VALUE] = "EXPANSION_CASE_VALUE";
  TokenType$1[TokenType$1.EXPANSION_CASE_EXP_START] = "EXPANSION_CASE_EXP_START";
  TokenType$1[TokenType$1.EXPANSION_CASE_EXP_END] = "EXPANSION_CASE_EXP_END";
  TokenType$1[TokenType$1.EXPANSION_FORM_END] = "EXPANSION_FORM_END";
  TokenType$1[TokenType$1.EOF] = "EOF";
  var Token$1 = (function() {
    function Token$1(type, parts, sourceSpan) {
      this.type = type;
      this.parts = parts;
      this.sourceSpan = sourceSpan;
    }
    return Token$1;
  }());
  var TokenError = (function(_super) {
    __extends(TokenError, _super);
    function TokenError(errorMsg, tokenType, span) {
      var _this = _super.call(this, span, errorMsg) || this;
      _this.tokenType = tokenType;
      return _this;
    }
    return TokenError;
  }(ParseError));
  var TokenizeResult = (function() {
    function TokenizeResult(tokens, errors) {
      this.tokens = tokens;
      this.errors = errors;
    }
    return TokenizeResult;
  }());
  function tokenize(source, url, getTagDefinition, tokenizeExpansionForms, interpolationConfig) {
    if (tokenizeExpansionForms === void 0) {
      tokenizeExpansionForms = false;
    }
    if (interpolationConfig === void 0) {
      interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;
    }
    return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig).tokenize();
  }
  var _CR_OR_CRLF_REGEXP = /\r\n?/g;
  function _unexpectedCharacterErrorMsg(charCode) {
    var char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);
    return "Unexpected character \"" + char + "\"";
  }
  function _unknownEntityErrorMsg(entitySrc) {
    return "Unknown entity \"" + entitySrc + "\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax";
  }
  var _ControlFlowError = (function() {
    function _ControlFlowError(error) {
      this.error = error;
    }
    return _ControlFlowError;
  }());
  var _Tokenizer = (function() {
    function _Tokenizer(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig) {
      if (_interpolationConfig === void 0) {
        _interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;
      }
      this._file = _file;
      this._getTagDefinition = _getTagDefinition;
      this._tokenizeIcu = _tokenizeIcu;
      this._interpolationConfig = _interpolationConfig;
      this._peek = -1;
      this._nextPeek = -1;
      this._index = -1;
      this._line = 0;
      this._column = -1;
      this._expansionCaseStack = [];
      this._inInterpolation = false;
      this.tokens = [];
      this.errors = [];
      this._input = _file.content;
      this._length = _file.content.length;
      this._advance();
    }
    _Tokenizer.prototype._processCarriageReturns = function(content) {
      return content.replace(_CR_OR_CRLF_REGEXP, '\n');
    };
    _Tokenizer.prototype.tokenize = function() {
      while (this._peek !== $EOF) {
        var start = this._getLocation();
        try {
          if (this._attemptCharCode($LT)) {
            if (this._attemptCharCode($BANG)) {
              if (this._attemptCharCode($LBRACKET)) {
                this._consumeCdata(start);
              } else if (this._attemptCharCode($MINUS)) {
                this._consumeComment(start);
              } else {
                this._consumeDocType(start);
              }
            } else if (this._attemptCharCode($SLASH)) {
              this._consumeTagClose(start);
            } else {
              this._consumeTagOpen(start);
            }
          } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
            this._consumeText();
          }
        } catch (e) {
          if (e instanceof _ControlFlowError) {
            this.errors.push(e.error);
          } else {
            throw e;
          }
        }
      }
      this._beginToken(TokenType$1.EOF);
      this._endToken([]);
      return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);
    };
    _Tokenizer.prototype._tokenizeExpansionForm = function() {
      if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
        this._consumeExpansionFormStart();
        return true;
      }
      if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {
        this._consumeExpansionCaseStart();
        return true;
      }
      if (this._peek === $RBRACE) {
        if (this._isInExpansionCase()) {
          this._consumeExpansionCaseEnd();
          return true;
        }
        if (this._isInExpansionForm()) {
          this._consumeExpansionFormEnd();
          return true;
        }
      }
      return false;
    };
    _Tokenizer.prototype._getLocation = function() {
      return new ParseLocation(this._file, this._index, this._line, this._column);
    };
    _Tokenizer.prototype._getSpan = function(start, end) {
      if (start === void 0) {
        start = this._getLocation();
      }
      if (end === void 0) {
        end = this._getLocation();
      }
      return new ParseSourceSpan(start, end);
    };
    _Tokenizer.prototype._beginToken = function(type, start) {
      if (start === void 0) {
        start = this._getLocation();
      }
      this._currentTokenStart = start;
      this._currentTokenType = type;
    };
    _Tokenizer.prototype._endToken = function(parts, end) {
      if (end === void 0) {
        end = this._getLocation();
      }
      var token = new Token$1(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));
      this.tokens.push(token);
      this._currentTokenStart = ((null));
      this._currentTokenType = ((null));
      return token;
    };
    _Tokenizer.prototype._createError = function(msg, span) {
      if (this._isInExpansionForm()) {
        msg += " (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)";
      }
      var error = new TokenError(msg, this._currentTokenType, span);
      this._currentTokenStart = ((null));
      this._currentTokenType = ((null));
      return new _ControlFlowError(error);
    };
    _Tokenizer.prototype._advance = function() {
      if (this._index >= this._length) {
        throw this._createError(_unexpectedCharacterErrorMsg($EOF), this._getSpan());
      }
      if (this._peek === $LF) {
        this._line++;
        this._column = 0;
      } else if (this._peek !== $LF && this._peek !== $CR) {
        this._column++;
      }
      this._index++;
      this._peek = this._index >= this._length ? $EOF : this._input.charCodeAt(this._index);
      this._nextPeek = this._index + 1 >= this._length ? $EOF : this._input.charCodeAt(this._index + 1);
    };
    _Tokenizer.prototype._attemptCharCode = function(charCode) {
      if (this._peek === charCode) {
        this._advance();
        return true;
      }
      return false;
    };
    _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function(charCode) {
      if (compareCharCodeCaseInsensitive(this._peek, charCode)) {
        this._advance();
        return true;
      }
      return false;
    };
    _Tokenizer.prototype._requireCharCode = function(charCode) {
      var location = this._getLocation();
      if (!this._attemptCharCode(charCode)) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));
      }
    };
    _Tokenizer.prototype._attemptStr = function(chars) {
      var len = chars.length;
      if (this._index + len > this._length) {
        return false;
      }
      var initialPosition = this._savePosition();
      for (var i = 0; i < len; i++) {
        if (!this._attemptCharCode(chars.charCodeAt(i))) {
          this._restorePosition(initialPosition);
          return false;
        }
      }
      return true;
    };
    _Tokenizer.prototype._attemptStrCaseInsensitive = function(chars) {
      for (var i = 0; i < chars.length; i++) {
        if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    };
    _Tokenizer.prototype._requireStr = function(chars) {
      var location = this._getLocation();
      if (!this._attemptStr(chars)) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));
      }
    };
    _Tokenizer.prototype._attemptCharCodeUntilFn = function(predicate) {
      while (!predicate(this._peek)) {
        this._advance();
      }
    };
    _Tokenizer.prototype._requireCharCodeUntilFn = function(predicate, len) {
      var start = this._getLocation();
      this._attemptCharCodeUntilFn(predicate);
      if (this._index - start.offset < len) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));
      }
    };
    _Tokenizer.prototype._attemptUntilChar = function(char) {
      while (this._peek !== char) {
        this._advance();
      }
    };
    _Tokenizer.prototype._readChar = function(decodeEntities) {
      if (decodeEntities && this._peek === $AMPERSAND) {
        return this._decodeEntity();
      } else {
        var index = this._index;
        this._advance();
        return this._input[index];
      }
    };
    _Tokenizer.prototype._decodeEntity = function() {
      var start = this._getLocation();
      this._advance();
      if (this._attemptCharCode($HASH)) {
        var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
        var numberStart = this._getLocation().offset;
        this._attemptCharCodeUntilFn(isDigitEntityEnd);
        if (this._peek != $SEMICOLON) {
          throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
        }
        this._advance();
        var strNum = this._input.substring(numberStart, this._index - 1);
        try {
          var charCode = parseInt(strNum, isHex ? 16 : 10);
          return String.fromCharCode(charCode);
        } catch (e) {
          var entity = this._input.substring(start.offset + 1, this._index - 1);
          throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));
        }
      } else {
        var startPosition = this._savePosition();
        this._attemptCharCodeUntilFn(isNamedEntityEnd);
        if (this._peek != $SEMICOLON) {
          this._restorePosition(startPosition);
          return '&';
        }
        this._advance();
        var name = this._input.substring(start.offset + 1, this._index - 1);
        var char = NAMED_ENTITIES[name];
        if (!char) {
          throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));
        }
        return char;
      }
    };
    _Tokenizer.prototype._consumeRawText = function(decodeEntities, firstCharOfEnd, attemptEndRest) {
      var tagCloseStart;
      var textStart = this._getLocation();
      this._beginToken(decodeEntities ? TokenType$1.ESCAPABLE_RAW_TEXT : TokenType$1.RAW_TEXT, textStart);
      var parts = [];
      while (true) {
        tagCloseStart = this._getLocation();
        if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {
          break;
        }
        if (this._index > tagCloseStart.offset) {
          parts.push(this._input.substring(tagCloseStart.offset, this._index));
        }
        while (this._peek !== firstCharOfEnd) {
          parts.push(this._readChar(decodeEntities));
        }
      }
      return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);
    };
    _Tokenizer.prototype._consumeComment = function(start) {
      var _this = this;
      this._beginToken(TokenType$1.COMMENT_START, start);
      this._requireCharCode($MINUS);
      this._endToken([]);
      var textToken = this._consumeRawText(false, $MINUS, function() {
        return _this._attemptStr('->');
      });
      this._beginToken(TokenType$1.COMMENT_END, textToken.sourceSpan.end);
      this._endToken([]);
    };
    _Tokenizer.prototype._consumeCdata = function(start) {
      var _this = this;
      this._beginToken(TokenType$1.CDATA_START, start);
      this._requireStr('CDATA[');
      this._endToken([]);
      var textToken = this._consumeRawText(false, $RBRACKET, function() {
        return _this._attemptStr(']>');
      });
      this._beginToken(TokenType$1.CDATA_END, textToken.sourceSpan.end);
      this._endToken([]);
    };
    _Tokenizer.prototype._consumeDocType = function(start) {
      this._beginToken(TokenType$1.DOC_TYPE, start);
      this._attemptUntilChar($GT);
      this._advance();
      this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);
    };
    _Tokenizer.prototype._consumePrefixAndName = function() {
      var nameOrPrefixStart = this._index;
      var prefix = ((null));
      while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {
        this._advance();
      }
      var nameStart;
      if (this._peek === $COLON) {
        this._advance();
        prefix = this._input.substring(nameOrPrefixStart, this._index - 1);
        nameStart = this._index;
      } else {
        nameStart = nameOrPrefixStart;
      }
      this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);
      var name = this._input.substring(nameStart, this._index);
      return [prefix, name];
    };
    _Tokenizer.prototype._consumeTagOpen = function(start) {
      var savedPos = this._savePosition();
      var tagName;
      var lowercaseTagName;
      try {
        if (!isAsciiLetter(this._peek)) {
          throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
        }
        var nameStart = this._index;
        this._consumeTagOpenStart(start);
        tagName = this._input.substring(nameStart, this._index);
        lowercaseTagName = tagName.toLowerCase();
        this._attemptCharCodeUntilFn(isNotWhitespace);
        while (this._peek !== $SLASH && this._peek !== $GT) {
          this._consumeAttributeName();
          this._attemptCharCodeUntilFn(isNotWhitespace);
          if (this._attemptCharCode($EQ)) {
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._consumeAttributeValue();
          }
          this._attemptCharCodeUntilFn(isNotWhitespace);
        }
        this._consumeTagOpenEnd();
      } catch (e) {
        if (e instanceof _ControlFlowError) {
          this._restorePosition(savedPos);
          this._beginToken(TokenType$1.TEXT, start);
          this._endToken(['<']);
          return;
        }
        throw e;
      }
      var contentTokenType = this._getTagDefinition(tagName).contentType;
      if (contentTokenType === TagContentType.RAW_TEXT) {
        this._consumeRawTextWithTagClose(lowercaseTagName, false);
      } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
        this._consumeRawTextWithTagClose(lowercaseTagName, true);
      }
    };
    _Tokenizer.prototype._consumeRawTextWithTagClose = function(lowercaseTagName, decodeEntities) {
      var _this = this;
      var textToken = this._consumeRawText(decodeEntities, $LT, function() {
        if (!_this._attemptCharCode($SLASH))
          return false;
        _this._attemptCharCodeUntilFn(isNotWhitespace);
        if (!_this._attemptStrCaseInsensitive(lowercaseTagName))
          return false;
        _this._attemptCharCodeUntilFn(isNotWhitespace);
        return _this._attemptCharCode($GT);
      });
      this._beginToken(TokenType$1.TAG_CLOSE, textToken.sourceSpan.end);
      this._endToken([((null)), lowercaseTagName]);
    };
    _Tokenizer.prototype._consumeTagOpenStart = function(start) {
      this._beginToken(TokenType$1.TAG_OPEN_START, start);
      var parts = this._consumePrefixAndName();
      this._endToken(parts);
    };
    _Tokenizer.prototype._consumeAttributeName = function() {
      this._beginToken(TokenType$1.ATTR_NAME);
      var prefixAndName = this._consumePrefixAndName();
      this._endToken(prefixAndName);
    };
    _Tokenizer.prototype._consumeAttributeValue = function() {
      this._beginToken(TokenType$1.ATTR_VALUE);
      var value;
      if (this._peek === $SQ || this._peek === $DQ) {
        var quoteChar = this._peek;
        this._advance();
        var parts = [];
        while (this._peek !== quoteChar) {
          parts.push(this._readChar(true));
        }
        value = parts.join('');
        this._advance();
      } else {
        var valueStart = this._index;
        this._requireCharCodeUntilFn(isNameEnd, 1);
        value = this._input.substring(valueStart, this._index);
      }
      this._endToken([this._processCarriageReturns(value)]);
    };
    _Tokenizer.prototype._consumeTagOpenEnd = function() {
      var tokenType = this._attemptCharCode($SLASH) ? TokenType$1.TAG_OPEN_END_VOID : TokenType$1.TAG_OPEN_END;
      this._beginToken(tokenType);
      this._requireCharCode($GT);
      this._endToken([]);
    };
    _Tokenizer.prototype._consumeTagClose = function(start) {
      this._beginToken(TokenType$1.TAG_CLOSE, start);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      var prefixAndName = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._requireCharCode($GT);
      this._endToken(prefixAndName);
    };
    _Tokenizer.prototype._consumeExpansionFormStart = function() {
      this._beginToken(TokenType$1.EXPANSION_FORM_START, this._getLocation());
      this._requireCharCode($LBRACE);
      this._endToken([]);
      this._expansionCaseStack.push(TokenType$1.EXPANSION_FORM_START);
      this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
      var condition = this._readUntil($COMMA);
      this._endToken([condition], this._getLocation());
      this._requireCharCode($COMMA);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
      var type = this._readUntil($COMMA);
      this._endToken([type], this._getLocation());
      this._requireCharCode($COMMA);
      this._attemptCharCodeUntilFn(isNotWhitespace);
    };
    _Tokenizer.prototype._consumeExpansionCaseStart = function() {
      this._beginToken(TokenType$1.EXPANSION_CASE_VALUE, this._getLocation());
      var value = this._readUntil($LBRACE).trim();
      this._endToken([value], this._getLocation());
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._beginToken(TokenType$1.EXPANSION_CASE_EXP_START, this._getLocation());
      this._requireCharCode($LBRACE);
      this._endToken([], this._getLocation());
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._expansionCaseStack.push(TokenType$1.EXPANSION_CASE_EXP_START);
    };
    _Tokenizer.prototype._consumeExpansionCaseEnd = function() {
      this._beginToken(TokenType$1.EXPANSION_CASE_EXP_END, this._getLocation());
      this._requireCharCode($RBRACE);
      this._endToken([], this._getLocation());
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._expansionCaseStack.pop();
    };
    _Tokenizer.prototype._consumeExpansionFormEnd = function() {
      this._beginToken(TokenType$1.EXPANSION_FORM_END, this._getLocation());
      this._requireCharCode($RBRACE);
      this._endToken([]);
      this._expansionCaseStack.pop();
    };
    _Tokenizer.prototype._consumeText = function() {
      var start = this._getLocation();
      this._beginToken(TokenType$1.TEXT, start);
      var parts = [];
      do {
        if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
          parts.push(this._interpolationConfig.start);
          this._inInterpolation = true;
        } else if (this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end)) {
          parts.push(this._interpolationConfig.end);
          this._inInterpolation = false;
        } else {
          parts.push(this._readChar(true));
        }
      } while (!this._isTextEnd());
      this._endToken([this._processCarriageReturns(parts.join(''))]);
    };
    _Tokenizer.prototype._isTextEnd = function() {
      if (this._peek === $LT || this._peek === $EOF) {
        return true;
      }
      if (this._tokenizeIcu && !this._inInterpolation) {
        if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
          return true;
        }
        if (this._peek === $RBRACE && this._isInExpansionCase()) {
          return true;
        }
      }
      return false;
    };
    _Tokenizer.prototype._savePosition = function() {
      return [this._peek, this._index, this._column, this._line, this.tokens.length];
    };
    _Tokenizer.prototype._readUntil = function(char) {
      var start = this._index;
      this._attemptUntilChar(char);
      return this._input.substring(start, this._index);
    };
    _Tokenizer.prototype._restorePosition = function(position) {
      this._peek = position[0];
      this._index = position[1];
      this._column = position[2];
      this._line = position[3];
      var nbTokens = position[4];
      if (nbTokens < this.tokens.length) {
        this.tokens = this.tokens.slice(0, nbTokens);
      }
    };
    _Tokenizer.prototype._isInExpansionCase = function() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType$1.EXPANSION_CASE_EXP_START;
    };
    _Tokenizer.prototype._isInExpansionForm = function() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType$1.EXPANSION_FORM_START;
    };
    return _Tokenizer;
  }());
  function isNotWhitespace(code) {
    return !isWhitespace(code) || code === $EOF;
  }
  function isNameEnd(code) {
    return isWhitespace(code) || code === $GT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ;
  }
  function isPrefixEnd(code) {
    return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);
  }
  function isDigitEntityEnd(code) {
    return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);
  }
  function isNamedEntityEnd(code) {
    return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);
  }
  function isExpansionFormStart(input, offset, interpolationConfig) {
    var isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;
    return input.charCodeAt(offset) == $LBRACE && !isInterpolationStart;
  }
  function isExpansionCaseStart(peek) {
    return peek === $EQ || isAsciiLetter(peek) || isDigit(peek);
  }
  function compareCharCodeCaseInsensitive(code1, code2) {
    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
  }
  function toUpperCaseCharCode(code) {
    return code >= $a && code <= $z ? code - $a + $A : code;
  }
  function mergeTextTokens(srcTokens) {
    var dstTokens = [];
    var lastDstToken = undefined;
    for (var i = 0; i < srcTokens.length; i++) {
      var token = srcTokens[i];
      if (lastDstToken && lastDstToken.type == TokenType$1.TEXT && token.type == TokenType$1.TEXT) {
        lastDstToken.parts[0] += token.parts[0];
        lastDstToken.sourceSpan.end = token.sourceSpan.end;
      } else {
        lastDstToken = token;
        dstTokens.push(lastDstToken);
      }
    }
    return dstTokens;
  }
  var TreeError = (function(_super) {
    __extends(TreeError, _super);
    function TreeError(elementName, span, msg) {
      var _this = _super.call(this, span, msg) || this;
      _this.elementName = elementName;
      return _this;
    }
    TreeError.create = function(elementName, span, msg) {
      return new TreeError(elementName, span, msg);
    };
    return TreeError;
  }(ParseError));
  var ParseTreeResult = (function() {
    function ParseTreeResult(rootNodes, errors) {
      this.rootNodes = rootNodes;
      this.errors = errors;
    }
    return ParseTreeResult;
  }());
  var Parser$1 = (function() {
    function Parser$1(getTagDefinition) {
      this.getTagDefinition = getTagDefinition;
    }
    Parser$1.prototype.parse = function(source, url, parseExpansionForms, interpolationConfig) {
      if (parseExpansionForms === void 0) {
        parseExpansionForms = false;
      }
      if (interpolationConfig === void 0) {
        interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;
      }
      var tokensAndErrors = tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);
      var treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();
      return new ParseTreeResult(treeAndErrors.rootNodes, ((tokensAndErrors.errors)).concat(treeAndErrors.errors));
    };
    return Parser$1;
  }());
  var _TreeBuilder = (function() {
    function _TreeBuilder(tokens, getTagDefinition) {
      this.tokens = tokens;
      this.getTagDefinition = getTagDefinition;
      this._index = -1;
      this._rootNodes = [];
      this._errors = [];
      this._elementStack = [];
      this._advance();
    }
    _TreeBuilder.prototype.build = function() {
      while (this._peek.type !== TokenType$1.EOF) {
        if (this._peek.type === TokenType$1.TAG_OPEN_START) {
          this._consumeStartTag(this._advance());
        } else if (this._peek.type === TokenType$1.TAG_CLOSE) {
          this._consumeEndTag(this._advance());
        } else if (this._peek.type === TokenType$1.CDATA_START) {
          this._closeVoidElement();
          this._consumeCdata(this._advance());
        } else if (this._peek.type === TokenType$1.COMMENT_START) {
          this._closeVoidElement();
          this._consumeComment(this._advance());
        } else if (this._peek.type === TokenType$1.TEXT || this._peek.type === TokenType$1.RAW_TEXT || this._peek.type === TokenType$1.ESCAPABLE_RAW_TEXT) {
          this._closeVoidElement();
          this._consumeText(this._advance());
        } else if (this._peek.type === TokenType$1.EXPANSION_FORM_START) {
          this._consumeExpansion(this._advance());
        } else {
          this._advance();
        }
      }
      return new ParseTreeResult(this._rootNodes, this._errors);
    };
    _TreeBuilder.prototype._advance = function() {
      var prev = this._peek;
      if (this._index < this.tokens.length - 1) {
        this._index++;
      }
      this._peek = this.tokens[this._index];
      return prev;
    };
    _TreeBuilder.prototype._advanceIf = function(type) {
      if (this._peek.type === type) {
        return this._advance();
      }
      return null;
    };
    _TreeBuilder.prototype._consumeCdata = function(startToken) {
      this._consumeText(this._advance());
      this._advanceIf(TokenType$1.CDATA_END);
    };
    _TreeBuilder.prototype._consumeComment = function(token) {
      var text = this._advanceIf(TokenType$1.RAW_TEXT);
      this._advanceIf(TokenType$1.COMMENT_END);
      var value = text != null ? text.parts[0].trim() : null;
      this._addToParent(new Comment(value, token.sourceSpan));
    };
    _TreeBuilder.prototype._consumeExpansion = function(token) {
      var switchValue = this._advance();
      var type = this._advance();
      var cases = [];
      while (this._peek.type === TokenType$1.EXPANSION_CASE_VALUE) {
        var expCase = this._parseExpansionCase();
        if (!expCase)
          return;
        cases.push(expCase);
      }
      if (this._peek.type !== TokenType$1.EXPANSION_FORM_END) {
        this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
        return;
      }
      var sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);
      this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
      this._advance();
    };
    _TreeBuilder.prototype._parseExpansionCase = function() {
      var value = this._advance();
      if (this._peek.type !== TokenType$1.EXPANSION_CASE_EXP_START) {
        this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'."));
        return null;
      }
      var start = this._advance();
      var exp = this._collectExpansionExpTokens(start);
      if (!exp)
        return null;
      var end = this._advance();
      exp.push(new Token$1(TokenType$1.EOF, [], end.sourceSpan));
      var parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();
      if (parsedExp.errors.length > 0) {
        this._errors = this._errors.concat((parsedExp.errors));
        return null;
      }
      var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
      var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
      return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
    };
    _TreeBuilder.prototype._collectExpansionExpTokens = function(start) {
      var exp = [];
      var expansionFormStack = [TokenType$1.EXPANSION_CASE_EXP_START];
      while (true) {
        if (this._peek.type === TokenType$1.EXPANSION_FORM_START || this._peek.type === TokenType$1.EXPANSION_CASE_EXP_START) {
          expansionFormStack.push(this._peek.type);
        }
        if (this._peek.type === TokenType$1.EXPANSION_CASE_EXP_END) {
          if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_CASE_EXP_START)) {
            expansionFormStack.pop();
            if (expansionFormStack.length == 0)
              return exp;
          } else {
            this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
            return null;
          }
        }
        if (this._peek.type === TokenType$1.EXPANSION_FORM_END) {
          if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_FORM_START)) {
            expansionFormStack.pop();
          } else {
            this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
            return null;
          }
        }
        if (this._peek.type === TokenType$1.EOF) {
          this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
          return null;
        }
        exp.push(this._advance());
      }
    };
    _TreeBuilder.prototype._consumeText = function(token) {
      var text = token.parts[0];
      if (text.length > 0 && text[0] == '\n') {
        var parent = this._getParentElement();
        if (parent != null && parent.children.length == 0 && this.getTagDefinition(parent.name).ignoreFirstLf) {
          text = text.substring(1);
        }
      }
      if (text.length > 0) {
        this._addToParent(new Text(text, token.sourceSpan));
      }
    };
    _TreeBuilder.prototype._closeVoidElement = function() {
      var el = this._getParentElement();
      if (el && this.getTagDefinition(el.name).isVoid) {
        this._elementStack.pop();
      }
    };
    _TreeBuilder.prototype._consumeStartTag = function(startTagToken) {
      var prefix = startTagToken.parts[0];
      var name = startTagToken.parts[1];
      var attrs = [];
      while (this._peek.type === TokenType$1.ATTR_NAME) {
        attrs.push(this._consumeAttr(this._advance()));
      }
      var fullName = this._getElementFullName(prefix, name, this._getParentElement());
      var selfClosing = false;
      if (this._peek.type === TokenType$1.TAG_OPEN_END_VOID) {
        this._advance();
        selfClosing = true;
        var tagDef = this.getTagDefinition(fullName);
        if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
          this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, "Only void and foreign elements can be self closed \"" + startTagToken.parts[1] + "\""));
        }
      } else if (this._peek.type === TokenType$1.TAG_OPEN_END) {
        this._advance();
        selfClosing = false;
      }
      var end = this._peek.sourceSpan.start;
      var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);
      var el = new Element(fullName, attrs, [], span, span, undefined);
      this._pushElement(el);
      if (selfClosing) {
        this._popElement(fullName);
        el.endSourceSpan = span;
      }
    };
    _TreeBuilder.prototype._pushElement = function(el) {
      var parentEl = this._getParentElement();
      if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
        this._elementStack.pop();
      }
      var tagDef = this.getTagDefinition(el.name);
      var _a = this._getParentElementSkippingContainers(),
          parent = _a.parent,
          container = _a.container;
      if (parent && tagDef.requireExtraParent(parent.name)) {
        var newParent = new Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
        this._insertBeforeContainer(parent, container, newParent);
      }
      this._addToParent(el);
      this._elementStack.push(el);
    };
    _TreeBuilder.prototype._consumeEndTag = function(endTagToken) {
      var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
      if (this._getParentElement()) {
        ((this._getParentElement())).endSourceSpan = endTagToken.sourceSpan;
      }
      if (this.getTagDefinition(fullName).isVoid) {
        this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Void elements do not have end tags \"" + endTagToken.parts[1] + "\""));
      } else if (!this._popElement(fullName)) {
        var errMsg = "Unexpected closing tag \"" + fullName + "\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags";
        this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));
      }
    };
    _TreeBuilder.prototype._popElement = function(fullName) {
      for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
        var el = this._elementStack[stackIndex];
        if (el.name == fullName) {
          this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);
          return true;
        }
        if (!this.getTagDefinition(el.name).closedByParent) {
          return false;
        }
      }
      return false;
    };
    _TreeBuilder.prototype._consumeAttr = function(attrName) {
      var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
      var end = attrName.sourceSpan.end;
      var value = '';
      var valueSpan = ((undefined));
      if (this._peek.type === TokenType$1.ATTR_VALUE) {
        var valueToken = this._advance();
        value = valueToken.parts[0];
        end = valueToken.sourceSpan.end;
        valueSpan = valueToken.sourceSpan;
      }
      return new Attribute$1(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);
    };
    _TreeBuilder.prototype._getParentElement = function() {
      return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
    };
    _TreeBuilder.prototype._getParentElementSkippingContainers = function() {
      var container = null;
      for (var i = this._elementStack.length - 1; i >= 0; i--) {
        if (!isNgContainer(this._elementStack[i].name)) {
          return {
            parent: this._elementStack[i],
            container: container
          };
        }
        container = this._elementStack[i];
      }
      return {
        parent: null,
        container: container
      };
    };
    _TreeBuilder.prototype._addToParent = function(node) {
      var parent = this._getParentElement();
      if (parent != null) {
        parent.children.push(node);
      } else {
        this._rootNodes.push(node);
      }
    };
    _TreeBuilder.prototype._insertBeforeContainer = function(parent, container, node) {
      if (!container) {
        this._addToParent(node);
        this._elementStack.push(node);
      } else {
        if (parent) {
          var index = parent.children.indexOf(container);
          parent.children[index] = node;
        } else {
          this._rootNodes.push(node);
        }
        node.children.push(container);
        this._elementStack.splice(this._elementStack.indexOf(container), 0, node);
      }
    };
    _TreeBuilder.prototype._getElementFullName = function(prefix, localName, parentElement) {
      if (prefix == null) {
        prefix = ((this.getTagDefinition(localName).implicitNamespacePrefix));
        if (prefix == null && parentElement != null) {
          prefix = getNsPrefix(parentElement.name);
        }
      }
      return mergeNsAndName(prefix, localName);
    };
    return _TreeBuilder;
  }());
  function lastOnStack(stack, element) {
    return stack.length > 0 && stack[stack.length - 1] === element;
  }
  function digest(message) {
    return message.id || sha1(serializeNodes(message.nodes).join('') + ("[" + message.meaning + "]"));
  }
  function decimalDigest(message) {
    if (message.id) {
      return message.id;
    }
    var visitor = new _SerializerIgnoreIcuExpVisitor();
    var parts = message.nodes.map(function(a) {
      return a.visit(visitor, null);
    });
    return computeMsgId(parts.join(''), message.meaning);
  }
  var _SerializerVisitor = (function() {
    function _SerializerVisitor() {}
    _SerializerVisitor.prototype.visitText = function(text, context) {
      return text.value;
    };
    _SerializerVisitor.prototype.visitContainer = function(container, context) {
      var _this = this;
      return "[" + container.children.map(function(child) {
        return child.visit(_this);
      }).join(', ') + "]";
    };
    _SerializerVisitor.prototype.visitIcu = function(icu, context) {
      var _this = this;
      var strCases = Object.keys(icu.cases).map(function(k) {
        return k + " {" + icu.cases[k].visit(_this) + "}";
      });
      return "{" + icu.expression + ", " + icu.type + ", " + strCases.join(', ') + "}";
    };
    _SerializerVisitor.prototype.visitTagPlaceholder = function(ph, context) {
      var _this = this;
      return ph.isVoid ? "<ph tag name=\"" + ph.startName + "\"/>" : "<ph tag name=\"" + ph.startName + "\">" + ph.children.map(function(child) {
        return child.visit(_this);
      }).join(', ') + "</ph name=\"" + ph.closeName + "\">";
    };
    _SerializerVisitor.prototype.visitPlaceholder = function(ph, context) {
      return ph.value ? "<ph name=\"" + ph.name + "\">" + ph.value + "</ph>" : "<ph name=\"" + ph.name + "\"/>";
    };
    _SerializerVisitor.prototype.visitIcuPlaceholder = function(ph, context) {
      return "<ph icu name=\"" + ph.name + "\">" + ph.value.visit(this) + "</ph>";
    };
    return _SerializerVisitor;
  }());
  var serializerVisitor = new _SerializerVisitor();
  function serializeNodes(nodes) {
    return nodes.map(function(a) {
      return a.visit(serializerVisitor, null);
    });
  }
  var _SerializerIgnoreIcuExpVisitor = (function(_super) {
    __extends(_SerializerIgnoreIcuExpVisitor, _super);
    function _SerializerIgnoreIcuExpVisitor() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    _SerializerIgnoreIcuExpVisitor.prototype.visitIcu = function(icu, context) {
      var _this = this;
      var strCases = Object.keys(icu.cases).map(function(k) {
        return k + " {" + icu.cases[k].visit(_this) + "}";
      });
      return "{" + icu.type + ", " + strCases.join(', ') + "}";
    };
    return _SerializerIgnoreIcuExpVisitor;
  }(_SerializerVisitor));
  function sha1(str) {
    var utf8 = utf8Encode(str);
    var words32 = stringToWords32(utf8, Endian.Big);
    var len = utf8.length * 8;
    var w = new Array(80);
    var _a = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0],
        a = _a[0],
        b = _a[1],
        c = _a[2],
        d = _a[3],
        e = _a[4];
    words32[len >> 5] |= 0x80 << (24 - len % 32);
    words32[((len + 64 >> 9) << 4) + 15] = len;
    for (var i = 0; i < words32.length; i += 16) {
      var _b = [a, b, c, d, e],
          h0 = _b[0],
          h1 = _b[1],
          h2 = _b[2],
          h3 = _b[3],
          h4 = _b[4];
      for (var j = 0; j < 80; j++) {
        if (j < 16) {
          w[j] = words32[i + j];
        } else {
          w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
        }
        var _c = fk(j, b, c, d),
            f = _c[0],
            k = _c[1];
        var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
        _d = [d, c, rol32(b, 30), a, temp], e = _d[0], d = _d[1], c = _d[2], b = _d[3], a = _d[4];
      }
      _e = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)], a = _e[0], b = _e[1], c = _e[2], d = _e[3], e = _e[4];
    }
    return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    var _d,
        _e;
  }
  function fk(index, b, c, d) {
    if (index < 20) {
      return [(b & c) | (~b & d), 0x5a827999];
    }
    if (index < 40) {
      return [b ^ c ^ d, 0x6ed9eba1];
    }
    if (index < 60) {
      return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];
    }
    return [b ^ c ^ d, 0xca62c1d6];
  }
  function fingerprint(str) {
    var utf8 = utf8Encode(str);
    var _a = [hash32(utf8, 0), hash32(utf8, 102072)],
        hi = _a[0],
        lo = _a[1];
    if (hi == 0 && (lo == 0 || lo == 1)) {
      hi = hi ^ 0x130f9bef;
      lo = lo ^ -0x6b5f56d8;
    }
    return [hi, lo];
  }
  function computeMsgId(msg, meaning) {
    var _a = fingerprint(msg),
        hi = _a[0],
        lo = _a[1];
    if (meaning) {
      var _b = fingerprint(meaning),
          him = _b[0],
          lom = _b[1];
      _c = add64(rol64([hi, lo], 1), [him, lom]), hi = _c[0], lo = _c[1];
    }
    return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));
    var _c;
  }
  function hash32(str, c) {
    var _a = [0x9e3779b9, 0x9e3779b9],
        a = _a[0],
        b = _a[1];
    var i;
    var len = str.length;
    for (i = 0; i + 12 <= len; i += 12) {
      a = add32(a, wordAt(str, i, Endian.Little));
      b = add32(b, wordAt(str, i + 4, Endian.Little));
      c = add32(c, wordAt(str, i + 8, Endian.Little));
      _b = mix([a, b, c]), a = _b[0], b = _b[1], c = _b[2];
    }
    a = add32(a, wordAt(str, i, Endian.Little));
    b = add32(b, wordAt(str, i + 4, Endian.Little));
    c = add32(c, len);
    c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);
    return mix([a, b, c])[2];
    var _b;
  }
  function mix(_a) {
    var a = _a[0],
        b = _a[1],
        c = _a[2];
    a = sub32(a, b);
    a = sub32(a, c);
    a ^= c >>> 13;
    b = sub32(b, c);
    b = sub32(b, a);
    b ^= a << 8;
    c = sub32(c, a);
    c = sub32(c, b);
    c ^= b >>> 13;
    a = sub32(a, b);
    a = sub32(a, c);
    a ^= c >>> 12;
    b = sub32(b, c);
    b = sub32(b, a);
    b ^= a << 16;
    c = sub32(c, a);
    c = sub32(c, b);
    c ^= b >>> 5;
    a = sub32(a, b);
    a = sub32(a, c);
    a ^= c >>> 3;
    b = sub32(b, c);
    b = sub32(b, a);
    b ^= a << 10;
    c = sub32(c, a);
    c = sub32(c, b);
    c ^= b >>> 15;
    return [a, b, c];
  }
  var Endian = {};
  Endian.Little = 0;
  Endian.Big = 1;
  Endian[Endian.Little] = "Little";
  Endian[Endian.Big] = "Big";
  function add32(a, b) {
    return add32to64(a, b)[1];
  }
  function add32to64(a, b) {
    var low = (a & 0xffff) + (b & 0xffff);
    var high = (a >>> 16) + (b >>> 16) + (low >>> 16);
    return [high >>> 16, (high << 16) | (low & 0xffff)];
  }
  function add64(_a, _b) {
    var ah = _a[0],
        al = _a[1];
    var bh = _b[0],
        bl = _b[1];
    var _c = add32to64(al, bl),
        carry = _c[0],
        l = _c[1];
    var h = add32(add32(ah, bh), carry);
    return [h, l];
  }
  function sub32(a, b) {
    var low = (a & 0xffff) - (b & 0xffff);
    var high = (a >> 16) - (b >> 16) + (low >> 16);
    return (high << 16) | (low & 0xffff);
  }
  function rol32(a, count) {
    return (a << count) | (a >>> (32 - count));
  }
  function rol64(_a, count) {
    var hi = _a[0],
        lo = _a[1];
    var h = (hi << count) | (lo >>> (32 - count));
    var l = (lo << count) | (hi >>> (32 - count));
    return [h, l];
  }
  function stringToWords32(str, endian) {
    var words32 = Array((str.length + 3) >>> 2);
    for (var i = 0; i < words32.length; i++) {
      words32[i] = wordAt(str, i * 4, endian);
    }
    return words32;
  }
  function byteAt(str, index) {
    return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;
  }
  function wordAt(str, index, endian) {
    var word = 0;
    if (endian === Endian.Big) {
      for (var i = 0; i < 4; i++) {
        word += byteAt(str, index + i) << (24 - 8 * i);
      }
    } else {
      for (var i = 0; i < 4; i++) {
        word += byteAt(str, index + i) << 8 * i;
      }
    }
    return word;
  }
  function words32ToByteString(words32) {
    return words32.reduce(function(str, word) {
      return str + word32ToByteString(word);
    }, '');
  }
  function word32ToByteString(word) {
    var str = '';
    for (var i = 0; i < 4; i++) {
      str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);
    }
    return str;
  }
  function byteStringToHexString(str) {
    var hex = '';
    for (var i = 0; i < str.length; i++) {
      var b = byteAt(str, i);
      hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);
    }
    return hex.toLowerCase();
  }
  function byteStringToDecString(str) {
    var decimal = '';
    var toThePower = '1';
    for (var i = str.length - 1; i >= 0; i--) {
      decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));
      toThePower = numberTimesBigInt(256, toThePower);
    }
    return decimal.split('').reverse().join('');
  }
  function addBigInt(x, y) {
    var sum = '';
    var len = Math.max(x.length, y.length);
    for (var i = 0,
        carry = 0; i < len || carry; i++) {
      var tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);
      if (tmpSum >= 10) {
        carry = 1;
        sum += tmpSum - 10;
      } else {
        carry = 0;
        sum += tmpSum;
      }
    }
    return sum;
  }
  function numberTimesBigInt(num, b) {
    var product = '';
    var bToThePower = b;
    for (; num !== 0; num = num >>> 1) {
      if (num & 1)
        product = addBigInt(product, bToThePower);
      bToThePower = addBigInt(bToThePower, bToThePower);
    }
    return product;
  }
  var Message = (function() {
    function Message(nodes, placeholders, placeholderToMessage, meaning, description, id) {
      this.nodes = nodes;
      this.placeholders = placeholders;
      this.placeholderToMessage = placeholderToMessage;
      this.meaning = meaning;
      this.description = description;
      this.id = id;
      if (nodes.length) {
        this.sources = [{
          filePath: nodes[0].sourceSpan.start.file.url,
          startLine: nodes[0].sourceSpan.start.line + 1,
          startCol: nodes[0].sourceSpan.start.col + 1,
          endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,
          endCol: nodes[0].sourceSpan.start.col + 1
        }];
      } else {
        this.sources = [];
      }
    }
    return Message;
  }());
  var Text$1 = (function() {
    function Text$1(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    Text$1.prototype.visit = function(visitor, context) {
      return visitor.visitText(this, context);
    };
    return Text$1;
  }());
  var Container = (function() {
    function Container(children, sourceSpan) {
      this.children = children;
      this.sourceSpan = sourceSpan;
    }
    Container.prototype.visit = function(visitor, context) {
      return visitor.visitContainer(this, context);
    };
    return Container;
  }());
  var Icu = (function() {
    function Icu(expression, type, cases, sourceSpan) {
      this.expression = expression;
      this.type = type;
      this.cases = cases;
      this.sourceSpan = sourceSpan;
    }
    Icu.prototype.visit = function(visitor, context) {
      return visitor.visitIcu(this, context);
    };
    return Icu;
  }());
  var TagPlaceholder = (function() {
    function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {
      this.tag = tag;
      this.attrs = attrs;
      this.startName = startName;
      this.closeName = closeName;
      this.children = children;
      this.isVoid = isVoid;
      this.sourceSpan = sourceSpan;
    }
    TagPlaceholder.prototype.visit = function(visitor, context) {
      return visitor.visitTagPlaceholder(this, context);
    };
    return TagPlaceholder;
  }());
  var Placeholder = (function() {
    function Placeholder(value, name, sourceSpan) {
      this.value = value;
      this.name = name;
      this.sourceSpan = sourceSpan;
    }
    Placeholder.prototype.visit = function(visitor, context) {
      return visitor.visitPlaceholder(this, context);
    };
    return Placeholder;
  }());
  var IcuPlaceholder = (function() {
    function IcuPlaceholder(value, name, sourceSpan) {
      this.value = value;
      this.name = name;
      this.sourceSpan = sourceSpan;
    }
    IcuPlaceholder.prototype.visit = function(visitor, context) {
      return visitor.visitIcuPlaceholder(this, context);
    };
    return IcuPlaceholder;
  }());
  var CloneVisitor = (function() {
    function CloneVisitor() {}
    CloneVisitor.prototype.visitText = function(text, context) {
      return new Text$1(text.value, text.sourceSpan);
    };
    CloneVisitor.prototype.visitContainer = function(container, context) {
      var _this = this;
      var children = container.children.map(function(n) {
        return n.visit(_this, context);
      });
      return new Container(children, container.sourceSpan);
    };
    CloneVisitor.prototype.visitIcu = function(icu, context) {
      var _this = this;
      var cases = {};
      Object.keys(icu.cases).forEach(function(key) {
        return cases[key] = icu.cases[key].visit(_this, context);
      });
      var msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);
      msg.expressionPlaceholder = icu.expressionPlaceholder;
      return msg;
    };
    CloneVisitor.prototype.visitTagPlaceholder = function(ph, context) {
      var _this = this;
      var children = ph.children.map(function(n) {
        return n.visit(_this, context);
      });
      return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);
    };
    CloneVisitor.prototype.visitPlaceholder = function(ph, context) {
      return new Placeholder(ph.value, ph.name, ph.sourceSpan);
    };
    CloneVisitor.prototype.visitIcuPlaceholder = function(ph, context) {
      return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);
    };
    return CloneVisitor;
  }());
  var RecurseVisitor = (function() {
    function RecurseVisitor() {}
    RecurseVisitor.prototype.visitText = function(text, context) {};
    RecurseVisitor.prototype.visitContainer = function(container, context) {
      var _this = this;
      container.children.forEach(function(child) {
        return child.visit(_this);
      });
    };
    RecurseVisitor.prototype.visitIcu = function(icu, context) {
      var _this = this;
      Object.keys(icu.cases).forEach(function(k) {
        icu.cases[k].visit(_this);
      });
    };
    RecurseVisitor.prototype.visitTagPlaceholder = function(ph, context) {
      var _this = this;
      ph.children.forEach(function(child) {
        return child.visit(_this);
      });
    };
    RecurseVisitor.prototype.visitPlaceholder = function(ph, context) {};
    RecurseVisitor.prototype.visitIcuPlaceholder = function(ph, context) {};
    return RecurseVisitor;
  }());
  var TAG_TO_PLACEHOLDER_NAMES = {
    'A': 'LINK',
    'B': 'BOLD_TEXT',
    'BR': 'LINE_BREAK',
    'EM': 'EMPHASISED_TEXT',
    'H1': 'HEADING_LEVEL1',
    'H2': 'HEADING_LEVEL2',
    'H3': 'HEADING_LEVEL3',
    'H4': 'HEADING_LEVEL4',
    'H5': 'HEADING_LEVEL5',
    'H6': 'HEADING_LEVEL6',
    'HR': 'HORIZONTAL_RULE',
    'I': 'ITALIC_TEXT',
    'LI': 'LIST_ITEM',
    'LINK': 'MEDIA_LINK',
    'OL': 'ORDERED_LIST',
    'P': 'PARAGRAPH',
    'Q': 'QUOTATION',
    'S': 'STRIKETHROUGH_TEXT',
    'SMALL': 'SMALL_TEXT',
    'SUB': 'SUBSTRIPT',
    'SUP': 'SUPERSCRIPT',
    'TBODY': 'TABLE_BODY',
    'TD': 'TABLE_CELL',
    'TFOOT': 'TABLE_FOOTER',
    'TH': 'TABLE_HEADER_CELL',
    'THEAD': 'TABLE_HEADER',
    'TR': 'TABLE_ROW',
    'TT': 'MONOSPACED_TEXT',
    'U': 'UNDERLINED_TEXT',
    'UL': 'UNORDERED_LIST'
  };
  var PlaceholderRegistry = (function() {
    function PlaceholderRegistry() {
      this._placeHolderNameCounts = {};
      this._signatureToName = {};
    }
    PlaceholderRegistry.prototype.getStartTagPlaceholderName = function(tag, attrs, isVoid) {
      var signature = this._hashTag(tag, attrs, isVoid);
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      var upperTag = tag.toUpperCase();
      var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
      var name = this._generateUniqueName(isVoid ? baseName : "START_" + baseName);
      this._signatureToName[signature] = name;
      return name;
    };
    PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function(tag) {
      var signature = this._hashClosingTag(tag);
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      var upperTag = tag.toUpperCase();
      var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
      var name = this._generateUniqueName("CLOSE_" + baseName);
      this._signatureToName[signature] = name;
      return name;
    };
    PlaceholderRegistry.prototype.getPlaceholderName = function(name, content) {
      var upperName = name.toUpperCase();
      var signature = "PH: " + upperName + "=" + content;
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      var uniqueName = this._generateUniqueName(upperName);
      this._signatureToName[signature] = uniqueName;
      return uniqueName;
    };
    PlaceholderRegistry.prototype.getUniquePlaceholder = function(name) {
      return this._generateUniqueName(name.toUpperCase());
    };
    PlaceholderRegistry.prototype._hashTag = function(tag, attrs, isVoid) {
      var start = "<" + tag;
      var strAttrs = Object.keys(attrs).sort().map(function(name) {
        return " " + name + "=" + attrs[name];
      }).join('');
      var end = isVoid ? '/>' : "></" + tag + ">";
      return start + strAttrs + end;
    };
    PlaceholderRegistry.prototype._hashClosingTag = function(tag) {
      return this._hashTag("/" + tag, {}, false);
    };
    PlaceholderRegistry.prototype._generateUniqueName = function(base) {
      var seen = this._placeHolderNameCounts.hasOwnProperty(base);
      if (!seen) {
        this._placeHolderNameCounts[base] = 1;
        return base;
      }
      var id = this._placeHolderNameCounts[base];
      this._placeHolderNameCounts[base] = id + 1;
      return base + "_" + id;
    };
    return PlaceholderRegistry;
  }());
  var _expParser = new Parser(new Lexer());
  function createI18nMessageFactory(interpolationConfig) {
    var visitor = new _I18nVisitor(_expParser, interpolationConfig);
    return function(nodes, meaning, description, id) {
      return visitor.toI18nMessage(nodes, meaning, description, id);
    };
  }
  var _I18nVisitor = (function() {
    function _I18nVisitor(_expressionParser, _interpolationConfig) {
      this._expressionParser = _expressionParser;
      this._interpolationConfig = _interpolationConfig;
    }
    _I18nVisitor.prototype.toI18nMessage = function(nodes, meaning, description, id) {
      this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;
      this._icuDepth = 0;
      this._placeholderRegistry = new PlaceholderRegistry();
      this._placeholderToContent = {};
      this._placeholderToMessage = {};
      var i18nodes = visitAll(this, nodes, {});
      return new Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);
    };
    _I18nVisitor.prototype.visitElement = function(el, context) {
      var children = visitAll(this, el.children);
      var attrs = {};
      el.attrs.forEach(function(attr) {
        attrs[attr.name] = attr.value;
      });
      var isVoid = getHtmlTagDefinition(el.name).isVoid;
      var startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
      this._placeholderToContent[startPhName] = ((el.sourceSpan)).toString();
      var closePhName = '';
      if (!isVoid) {
        closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);
        this._placeholderToContent[closePhName] = "</" + el.name + ">";
      }
      return new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, ((el.sourceSpan)));
    };
    _I18nVisitor.prototype.visitAttribute = function(attribute, context) {
      return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);
    };
    _I18nVisitor.prototype.visitText = function(text, context) {
      return this._visitTextWithInterpolation(text.value, ((text.sourceSpan)));
    };
    _I18nVisitor.prototype.visitComment = function(comment, context) {
      return null;
    };
    _I18nVisitor.prototype.visitExpansion = function(icu, context) {
      var _this = this;
      this._icuDepth++;
      var i18nIcuCases = {};
      var i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
      icu.cases.forEach(function(caze) {
        i18nIcuCases[caze.value] = new Container(caze.expression.map(function(node) {
          return node.visit(_this, {});
        }), caze.expSourceSpan);
      });
      this._icuDepth--;
      if (this._isIcu || this._icuDepth > 0) {
        var expPh = this._placeholderRegistry.getUniquePlaceholder("VAR_" + icu.type);
        i18nIcu.expressionPlaceholder = expPh;
        this._placeholderToContent[expPh] = icu.switchValue;
        return i18nIcu;
      }
      var phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
      var visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);
      this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], '', '', '');
      return new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
    };
    _I18nVisitor.prototype.visitExpansionCase = function(icuCase, context) {
      throw new Error('Unreachable code');
    };
    _I18nVisitor.prototype._visitTextWithInterpolation = function(text, sourceSpan) {
      var splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);
      if (!splitInterpolation) {
        return new Text$1(text, sourceSpan);
      }
      var nodes = [];
      var container = new Container(nodes, sourceSpan);
      var _a = this._interpolationConfig,
          sDelimiter = _a.start,
          eDelimiter = _a.end;
      for (var i = 0; i < splitInterpolation.strings.length - 1; i++) {
        var expression = splitInterpolation.expressions[i];
        var baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';
        var phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);
        if (splitInterpolation.strings[i].length) {
          nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));
        }
        nodes.push(new Placeholder(expression, phName, sourceSpan));
        this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;
      }
      var lastStringIdx = splitInterpolation.strings.length - 1;
      if (splitInterpolation.strings[lastStringIdx].length) {
        nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));
      }
      return container;
    };
    return _I18nVisitor;
  }());
  var _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;
  function _extractPlaceholderName(input) {
    return input.split(_CUSTOM_PH_EXP)[2];
  }
  var I18nError = (function(_super) {
    __extends(I18nError, _super);
    function I18nError(span, msg) {
      return _super.call(this, span, msg) || this;
    }
    return I18nError;
  }(ParseError));
  var _I18N_ATTR = 'i18n';
  var _I18N_ATTR_PREFIX = 'i18n-';
  var _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;
  var MEANING_SEPARATOR = '|';
  var ID_SEPARATOR = '@@';
  function extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {
    var visitor = new _Visitor(implicitTags, implicitAttrs);
    return visitor.extract(nodes, interpolationConfig);
  }
  function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {
    var visitor = new _Visitor(implicitTags, implicitAttrs);
    return visitor.merge(nodes, translations, interpolationConfig);
  }
  var ExtractionResult = (function() {
    function ExtractionResult(messages, errors) {
      this.messages = messages;
      this.errors = errors;
    }
    return ExtractionResult;
  }());
  var _VisitorMode = {};
  _VisitorMode.Extract = 0;
  _VisitorMode.Merge = 1;
  _VisitorMode[_VisitorMode.Extract] = "Extract";
  _VisitorMode[_VisitorMode.Merge] = "Merge";
  var _Visitor = (function() {
    function _Visitor(_implicitTags, _implicitAttrs) {
      this._implicitTags = _implicitTags;
      this._implicitAttrs = _implicitAttrs;
    }
    _Visitor.prototype.extract = function(nodes, interpolationConfig) {
      var _this = this;
      this._init(_VisitorMode.Extract, interpolationConfig);
      nodes.forEach(function(node) {
        return node.visit(_this, null);
      });
      if (this._inI18nBlock) {
        this._reportError(nodes[nodes.length - 1], 'Unclosed block');
      }
      return new ExtractionResult(this._messages, this._errors);
    };
    _Visitor.prototype.merge = function(nodes, translations, interpolationConfig) {
      this._init(_VisitorMode.Merge, interpolationConfig);
      this._translations = translations;
      var wrapper = new Element('wrapper', [], nodes, ((undefined)), undefined, undefined);
      var translatedNode = wrapper.visit(this, null);
      if (this._inI18nBlock) {
        this._reportError(nodes[nodes.length - 1], 'Unclosed block');
      }
      return new ParseTreeResult(translatedNode.children, this._errors);
    };
    _Visitor.prototype.visitExpansionCase = function(icuCase, context) {
      var expression = visitAll(this, icuCase.expression, context);
      if (this._mode === _VisitorMode.Merge) {
        return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);
      }
    };
    _Visitor.prototype.visitExpansion = function(icu, context) {
      this._mayBeAddBlockChildren(icu);
      var wasInIcu = this._inIcu;
      if (!this._inIcu) {
        if (this._isInTranslatableSection) {
          this._addMessage([icu]);
        }
        this._inIcu = true;
      }
      var cases = visitAll(this, icu.cases, context);
      if (this._mode === _VisitorMode.Merge) {
        icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);
      }
      this._inIcu = wasInIcu;
      return icu;
    };
    _Visitor.prototype.visitComment = function(comment, context) {
      var isOpening = _isOpeningComment(comment);
      if (isOpening && this._isInTranslatableSection) {
        this._reportError(comment, 'Could not start a block inside a translatable section');
        return;
      }
      var isClosing = _isClosingComment(comment);
      if (isClosing && !this._inI18nBlock) {
        this._reportError(comment, 'Trying to close an unopened block');
        return;
      }
      if (!this._inI18nNode && !this._inIcu) {
        if (!this._inI18nBlock) {
          if (isOpening) {
            this._inI18nBlock = true;
            this._blockStartDepth = this._depth;
            this._blockChildren = [];
            this._blockMeaningAndDesc = ((comment.value)).replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();
            this._openTranslatableSection(comment);
          }
        } else {
          if (isClosing) {
            if (this._depth == this._blockStartDepth) {
              this._closeTranslatableSection(comment, this._blockChildren);
              this._inI18nBlock = false;
              var message = ((this._addMessage(this._blockChildren, this._blockMeaningAndDesc)));
              var nodes = this._translateMessage(comment, message);
              return visitAll(this, nodes);
            } else {
              this._reportError(comment, 'I18N blocks should not cross element boundaries');
              return;
            }
          }
        }
      }
    };
    _Visitor.prototype.visitText = function(text, context) {
      if (this._isInTranslatableSection) {
        this._mayBeAddBlockChildren(text);
      }
      return text;
    };
    _Visitor.prototype.visitElement = function(el, context) {
      var _this = this;
      this._mayBeAddBlockChildren(el);
      this._depth++;
      var wasInI18nNode = this._inI18nNode;
      var wasInImplicitNode = this._inImplicitNode;
      var childNodes = [];
      var translatedChildNodes = ((undefined));
      var i18nAttr = _getI18nAttr(el);
      var i18nMeta = i18nAttr ? i18nAttr.value : '';
      var isImplicit = this._implicitTags.some(function(tag) {
        return el.name === tag;
      }) && !this._inIcu && !this._isInTranslatableSection;
      var isTopLevelImplicit = !wasInImplicitNode && isImplicit;
      this._inImplicitNode = wasInImplicitNode || isImplicit;
      if (!this._isInTranslatableSection && !this._inIcu) {
        if (i18nAttr || isTopLevelImplicit) {
          this._inI18nNode = true;
          var message = ((this._addMessage(el.children, i18nMeta)));
          translatedChildNodes = this._translateMessage(el, message);
        }
        if (this._mode == _VisitorMode.Extract) {
          var isTranslatable = i18nAttr || isTopLevelImplicit;
          if (isTranslatable)
            this._openTranslatableSection(el);
          visitAll(this, el.children);
          if (isTranslatable)
            this._closeTranslatableSection(el, el.children);
        }
      } else {
        if (i18nAttr || isTopLevelImplicit) {
          this._reportError(el, 'Could not mark an element as translatable inside a translatable section');
        }
        if (this._mode == _VisitorMode.Extract) {
          visitAll(this, el.children);
        }
      }
      if (this._mode === _VisitorMode.Merge) {
        var visitNodes = translatedChildNodes || el.children;
        visitNodes.forEach(function(child) {
          var visited = child.visit(_this, context);
          if (visited && !_this._isInTranslatableSection) {
            childNodes = childNodes.concat(visited);
          }
        });
      }
      this._visitAttributesOf(el);
      this._depth--;
      this._inI18nNode = wasInI18nNode;
      this._inImplicitNode = wasInImplicitNode;
      if (this._mode === _VisitorMode.Merge) {
        var translatedAttrs = this._translateAttributes(el);
        return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
      }
      return null;
    };
    _Visitor.prototype.visitAttribute = function(attribute, context) {
      throw new Error('unreachable code');
    };
    _Visitor.prototype._init = function(mode, interpolationConfig) {
      this._mode = mode;
      this._inI18nBlock = false;
      this._inI18nNode = false;
      this._depth = 0;
      this._inIcu = false;
      this._msgCountAtSectionStart = undefined;
      this._errors = [];
      this._messages = [];
      this._inImplicitNode = false;
      this._createI18nMessage = createI18nMessageFactory(interpolationConfig);
    };
    _Visitor.prototype._visitAttributesOf = function(el) {
      var _this = this;
      var explicitAttrNameToValue = {};
      var implicitAttrNames = this._implicitAttrs[el.name] || [];
      el.attrs.filter(function(attr) {
        return attr.name.startsWith(_I18N_ATTR_PREFIX);
      }).forEach(function(attr) {
        return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] = attr.value;
      });
      el.attrs.forEach(function(attr) {
        if (attr.name in explicitAttrNameToValue) {
          _this._addMessage([attr], explicitAttrNameToValue[attr.name]);
        } else if (implicitAttrNames.some(function(name) {
          return attr.name === name;
        })) {
          _this._addMessage([attr]);
        }
      });
    };
    _Visitor.prototype._addMessage = function(ast, msgMeta) {
      if (ast.length == 0 || ast.length == 1 && ast[0] instanceof Attribute$1 && !((ast[0])).value) {
        return null;
      }
      var _a = _parseMessageMeta(msgMeta),
          meaning = _a.meaning,
          description = _a.description,
          id = _a.id;
      var message = this._createI18nMessage(ast, meaning, description, id);
      this._messages.push(message);
      return message;
    };
    _Visitor.prototype._translateMessage = function(el, message) {
      if (message && this._mode === _VisitorMode.Merge) {
        var nodes = this._translations.get(message);
        if (nodes) {
          return nodes;
        }
        this._reportError(el, "Translation unavailable for message id=\"" + this._translations.digest(message) + "\"");
      }
      return [];
    };
    _Visitor.prototype._translateAttributes = function(el) {
      var _this = this;
      var attributes = el.attrs;
      var i18nParsedMessageMeta = {};
      attributes.forEach(function(attr) {
        if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {
          i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] = _parseMessageMeta(attr.value);
        }
      });
      var translatedAttributes = [];
      attributes.forEach(function(attr) {
        if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {
          return;
        }
        if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {
          var _a = i18nParsedMessageMeta[attr.name],
              meaning = _a.meaning,
              description = _a.description,
              id = _a.id;
          var message = _this._createI18nMessage([attr], meaning, description, id);
          var nodes = _this._translations.get(message);
          if (nodes) {
            if (nodes.length == 0) {
              translatedAttributes.push(new Attribute$1(attr.name, '', attr.sourceSpan));
            } else if (nodes[0] instanceof Text) {
              var value = ((nodes[0])).value;
              translatedAttributes.push(new Attribute$1(attr.name, value, attr.sourceSpan));
            } else {
              _this._reportError(el, "Unexpected translation for attribute \"" + attr.name + "\" (id=\"" + (id || _this._translations.digest(message)) + "\")");
            }
          } else {
            _this._reportError(el, "Translation unavailable for attribute \"" + attr.name + "\" (id=\"" + (id || _this._translations.digest(message)) + "\")");
          }
        } else {
          translatedAttributes.push(attr);
        }
      });
      return translatedAttributes;
    };
    _Visitor.prototype._mayBeAddBlockChildren = function(node) {
      if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {
        this._blockChildren.push(node);
      }
    };
    _Visitor.prototype._openTranslatableSection = function(node) {
      if (this._isInTranslatableSection) {
        this._reportError(node, 'Unexpected section start');
      } else {
        this._msgCountAtSectionStart = this._messages.length;
      }
    };
    Object.defineProperty(_Visitor.prototype, "_isInTranslatableSection", {
      get: function() {
        return this._msgCountAtSectionStart !== void 0;
      },
      enumerable: true,
      configurable: true
    });
    _Visitor.prototype._closeTranslatableSection = function(node, directChildren) {
      if (!this._isInTranslatableSection) {
        this._reportError(node, 'Unexpected section end');
        return;
      }
      var startIndex = this._msgCountAtSectionStart;
      var significantChildren = directChildren.reduce(function(count, node) {
        return count + (node instanceof Comment ? 0 : 1);
      }, 0);
      if (significantChildren == 1) {
        for (var i = this._messages.length - 1; i >= ((startIndex)); i--) {
          var ast = this._messages[i].nodes;
          if (!(ast.length == 1 && ast[0] instanceof Text$1)) {
            this._messages.splice(i, 1);
            break;
          }
        }
      }
      this._msgCountAtSectionStart = undefined;
    };
    _Visitor.prototype._reportError = function(node, msg) {
      this._errors.push(new I18nError(((node.sourceSpan)), msg));
    };
    return _Visitor;
  }());
  function _isOpeningComment(n) {
    return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));
  }
  function _isClosingComment(n) {
    return !!(n instanceof Comment && n.value && n.value === '/i18n');
  }
  function _getI18nAttr(p) {
    return p.attrs.find(function(attr) {
      return attr.name === _I18N_ATTR;
    }) || null;
  }
  function _parseMessageMeta(i18n) {
    if (!i18n)
      return {
        meaning: '',
        description: '',
        id: ''
      };
    var idIndex = i18n.indexOf(ID_SEPARATOR);
    var descIndex = i18n.indexOf(MEANING_SEPARATOR);
    var _a = (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''],
        meaningAndDesc = _a[0],
        id = _a[1];
    var _b = (descIndex > -1) ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc],
        meaning = _b[0],
        description = _b[1];
    return {
      meaning: meaning,
      description: description,
      id: id
    };
  }
  var XmlTagDefinition = (function() {
    function XmlTagDefinition() {
      this.closedByParent = false;
      this.contentType = TagContentType.PARSABLE_DATA;
      this.isVoid = false;
      this.ignoreFirstLf = false;
      this.canSelfClose = true;
    }
    XmlTagDefinition.prototype.requireExtraParent = function(currentParent) {
      return false;
    };
    XmlTagDefinition.prototype.isClosedByChild = function(name) {
      return false;
    };
    return XmlTagDefinition;
  }());
  var _TAG_DEFINITION = new XmlTagDefinition();
  function getXmlTagDefinition(tagName) {
    return _TAG_DEFINITION;
  }
  var XmlParser = (function(_super) {
    __extends(XmlParser, _super);
    function XmlParser() {
      return _super.call(this, getXmlTagDefinition) || this;
    }
    XmlParser.prototype.parse = function(source, url, parseExpansionForms) {
      if (parseExpansionForms === void 0) {
        parseExpansionForms = false;
      }
      return _super.prototype.parse.call(this, source, url, parseExpansionForms);
    };
    return XmlParser;
  }(Parser$1));
  var Serializer = (function() {
    function Serializer() {}
    Serializer.prototype.write = function(messages, locale) {};
    Serializer.prototype.load = function(content, url) {};
    Serializer.prototype.digest = function(message) {};
    Serializer.prototype.createNameMapper = function(message) {
      return null;
    };
    return Serializer;
  }());
  var SimplePlaceholderMapper = (function(_super) {
    __extends(SimplePlaceholderMapper, _super);
    function SimplePlaceholderMapper(message, mapName) {
      var _this = _super.call(this) || this;
      _this.mapName = mapName;
      _this.internalToPublic = {};
      _this.publicToNextId = {};
      _this.publicToInternal = {};
      message.nodes.forEach(function(node) {
        return node.visit(_this);
      });
      return _this;
    }
    SimplePlaceholderMapper.prototype.toPublicName = function(internalName) {
      return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;
    };
    SimplePlaceholderMapper.prototype.toInternalName = function(publicName) {
      return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;
    };
    SimplePlaceholderMapper.prototype.visitText = function(text, context) {
      return null;
    };
    SimplePlaceholderMapper.prototype.visitTagPlaceholder = function(ph, context) {
      this.visitPlaceholderName(ph.startName);
      _super.prototype.visitTagPlaceholder.call(this, ph, context);
      this.visitPlaceholderName(ph.closeName);
    };
    SimplePlaceholderMapper.prototype.visitPlaceholder = function(ph, context) {
      this.visitPlaceholderName(ph.name);
    };
    SimplePlaceholderMapper.prototype.visitIcuPlaceholder = function(ph, context) {
      this.visitPlaceholderName(ph.name);
    };
    SimplePlaceholderMapper.prototype.visitPlaceholderName = function(internalName) {
      if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {
        return;
      }
      var publicName = this.mapName(internalName);
      if (this.publicToInternal.hasOwnProperty(publicName)) {
        var nextId = this.publicToNextId[publicName];
        this.publicToNextId[publicName] = nextId + 1;
        publicName = publicName + "_" + nextId;
      } else {
        this.publicToNextId[publicName] = 1;
      }
      this.internalToPublic[internalName] = publicName;
      this.publicToInternal[publicName] = internalName;
    };
    return SimplePlaceholderMapper;
  }(RecurseVisitor));
  var _Visitor$1 = (function() {
    function _Visitor$1() {}
    _Visitor$1.prototype.visitTag = function(tag) {
      var _this = this;
      var strAttrs = this._serializeAttributes(tag.attrs);
      if (tag.children.length == 0) {
        return "<" + tag.name + strAttrs + "/>";
      }
      var strChildren = tag.children.map(function(node) {
        return node.visit(_this);
      });
      return "<" + tag.name + strAttrs + ">" + strChildren.join('') + "</" + tag.name + ">";
    };
    _Visitor$1.prototype.visitText = function(text) {
      return text.value;
    };
    _Visitor$1.prototype.visitDeclaration = function(decl) {
      return "<?xml" + this._serializeAttributes(decl.attrs) + " ?>";
    };
    _Visitor$1.prototype._serializeAttributes = function(attrs) {
      var strAttrs = Object.keys(attrs).map(function(name) {
        return name + "=\"" + attrs[name] + "\"";
      }).join(' ');
      return strAttrs.length > 0 ? ' ' + strAttrs : '';
    };
    _Visitor$1.prototype.visitDoctype = function(doctype) {
      return "<!DOCTYPE " + doctype.rootTag + " [\n" + doctype.dtd + "\n]>";
    };
    return _Visitor$1;
  }());
  var _visitor = new _Visitor$1();
  function serialize(nodes) {
    return nodes.map(function(node) {
      return node.visit(_visitor);
    }).join('');
  }
  var Declaration = (function() {
    function Declaration(unescapedAttrs) {
      var _this = this;
      this.attrs = {};
      Object.keys(unescapedAttrs).forEach(function(k) {
        _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
      });
    }
    Declaration.prototype.visit = function(visitor) {
      return visitor.visitDeclaration(this);
    };
    return Declaration;
  }());
  var Doctype = (function() {
    function Doctype(rootTag, dtd) {
      this.rootTag = rootTag;
      this.dtd = dtd;
    }
    Doctype.prototype.visit = function(visitor) {
      return visitor.visitDoctype(this);
    };
    return Doctype;
  }());
  var Tag = (function() {
    function Tag(name, unescapedAttrs, children) {
      if (unescapedAttrs === void 0) {
        unescapedAttrs = {};
      }
      if (children === void 0) {
        children = [];
      }
      var _this = this;
      this.name = name;
      this.children = children;
      this.attrs = {};
      Object.keys(unescapedAttrs).forEach(function(k) {
        _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
      });
    }
    Tag.prototype.visit = function(visitor) {
      return visitor.visitTag(this);
    };
    return Tag;
  }());
  var Text$2 = (function() {
    function Text$2(unescapedValue) {
      this.value = _escapeXml(unescapedValue);
    }
    Text$2.prototype.visit = function(visitor) {
      return visitor.visitText(this);
    };
    return Text$2;
  }());
  var CR = (function(_super) {
    __extends(CR, _super);
    function CR(ws) {
      if (ws === void 0) {
        ws = 0;
      }
      return _super.call(this, "\n" + new Array(ws + 1).join(' ')) || this;
    }
    return CR;
  }(Text$2));
  var _ESCAPED_CHARS = [[/&/g, '&amp;'], [/"/g, '&quot;'], [/'/g, '&apos;'], [/</g, '&lt;'], [/>/g, '&gt;']];
  function _escapeXml(text) {
    return _ESCAPED_CHARS.reduce(function(text, entry) {
      return text.replace(entry[0], entry[1]);
    }, text);
  }
  var _VERSION = '1.2';
  var _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';
  var _DEFAULT_SOURCE_LANG = 'en';
  var _PLACEHOLDER_TAG = 'x';
  var _FILE_TAG = 'file';
  var _SOURCE_TAG = 'source';
  var _TARGET_TAG = 'target';
  var _UNIT_TAG = 'trans-unit';
  var _CONTEXT_GROUP_TAG = 'context-group';
  var _CONTEXT_TAG = 'context';
  var Xliff = (function(_super) {
    __extends(Xliff, _super);
    function Xliff() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Xliff.prototype.write = function(messages, locale) {
      var visitor = new _WriteVisitor();
      var transUnits = [];
      messages.forEach(function(message) {
        var contextTags = [];
        message.sources.forEach(function(source) {
          var contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, {purpose: 'location'});
          contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, {'context-type': 'sourcefile'}, [new Text$2(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, {'context-type': 'linenumber'}, [new Text$2("" + source.startLine)]), new CR(8));
          contextTags.push(new CR(8), contextGroupTag);
        });
        var transUnit = new Tag(_UNIT_TAG, {
          id: message.id,
          datatype: 'html'
        });
        (_a = transUnit.children).push.apply(_a, [new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes))].concat(contextTags));
        if (message.description) {
          transUnit.children.push(new CR(8), new Tag('note', {
            priority: '1',
            from: 'description'
          }, [new Text$2(message.description)]));
        }
        if (message.meaning) {
          transUnit.children.push(new CR(8), new Tag('note', {
            priority: '1',
            from: 'meaning'
          }, [new Text$2(message.meaning)]));
        }
        transUnit.children.push(new CR(6));
        transUnits.push(new CR(6), transUnit);
        var _a;
      });
      var body = new Tag('body', {}, transUnits.concat([new CR(4)]));
      var file = new Tag('file', {
        'source-language': locale || _DEFAULT_SOURCE_LANG,
        datatype: 'plaintext',
        original: 'ng2.template'
      }, [new CR(4), body, new CR(2)]);
      var xliff = new Tag('xliff', {
        version: _VERSION,
        xmlns: _XMLNS
      }, [new CR(2), file, new CR()]);
      return serialize([new Declaration({
        version: '1.0',
        encoding: 'UTF-8'
      }), new CR(), xliff, new CR()]);
    };
    Xliff.prototype.load = function(content, url) {
      var xliffParser = new XliffParser();
      var _a = xliffParser.parse(content, url),
          locale = _a.locale,
          msgIdToHtml = _a.msgIdToHtml,
          errors = _a.errors;
      var i18nNodesByMsgId = {};
      var converter = new XmlToI18n();
      Object.keys(msgIdToHtml).forEach(function(msgId) {
        var _a = converter.convert(msgIdToHtml[msgId], url),
            i18nNodes = _a.i18nNodes,
            e = _a.errors;
        errors.push.apply(errors, e);
        i18nNodesByMsgId[msgId] = i18nNodes;
      });
      if (errors.length) {
        throw new Error("xliff parse errors:\n" + errors.join('\n'));
      }
      return {
        locale: ((locale)),
        i18nNodesByMsgId: i18nNodesByMsgId
      };
    };
    Xliff.prototype.digest = function(message) {
      return digest(message);
    };
    return Xliff;
  }(Serializer));
  var _WriteVisitor = (function() {
    function _WriteVisitor() {}
    _WriteVisitor.prototype.visitText = function(text, context) {
      return [new Text$2(text.value)];
    };
    _WriteVisitor.prototype.visitContainer = function(container, context) {
      var _this = this;
      var nodes = [];
      container.children.forEach(function(node) {
        return nodes.push.apply(nodes, node.visit(_this));
      });
      return nodes;
    };
    _WriteVisitor.prototype.visitIcu = function(icu, context) {
      var _this = this;
      var nodes = [new Text$2("{" + icu.expressionPlaceholder + ", " + icu.type + ", ")];
      Object.keys(icu.cases).forEach(function(c) {
        nodes.push.apply(nodes, [new Text$2(c + " {")].concat(icu.cases[c].visit(_this), [new Text$2("} ")]));
      });
      nodes.push(new Text$2("}"));
      return nodes;
    };
    _WriteVisitor.prototype.visitTagPlaceholder = function(ph, context) {
      var ctype = getCtypeForTag(ph.tag);
      var startTagPh = new Tag(_PLACEHOLDER_TAG, {
        id: ph.startName,
        ctype: ctype
      });
      if (ph.isVoid) {
        return [startTagPh];
      }
      var closeTagPh = new Tag(_PLACEHOLDER_TAG, {
        id: ph.closeName,
        ctype: ctype
      });
      return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);
    };
    _WriteVisitor.prototype.visitPlaceholder = function(ph, context) {
      return [new Tag(_PLACEHOLDER_TAG, {id: ph.name})];
    };
    _WriteVisitor.prototype.visitIcuPlaceholder = function(ph, context) {
      return [new Tag(_PLACEHOLDER_TAG, {id: ph.name})];
    };
    _WriteVisitor.prototype.serialize = function(nodes) {
      var _this = this;
      return [].concat.apply([], nodes.map(function(node) {
        return node.visit(_this);
      }));
    };
    return _WriteVisitor;
  }());
  var XliffParser = (function() {
    function XliffParser() {
      this._locale = null;
    }
    XliffParser.prototype.parse = function(xliff, url) {
      this._unitMlString = null;
      this._msgIdToHtml = {};
      var xml = new XmlParser().parse(xliff, url, false);
      this._errors = xml.errors;
      visitAll(this, xml.rootNodes, null);
      return {
        msgIdToHtml: this._msgIdToHtml,
        errors: this._errors,
        locale: this._locale
      };
    };
    XliffParser.prototype.visitElement = function(element, context) {
      switch (element.name) {
        case _UNIT_TAG:
          this._unitMlString = ((null));
          var idAttr = element.attrs.find(function(attr) {
            return attr.name === 'id';
          });
          if (!idAttr) {
            this._addError(element, "<" + _UNIT_TAG + "> misses the \"id\" attribute");
          } else {
            var id = idAttr.value;
            if (this._msgIdToHtml.hasOwnProperty(id)) {
              this._addError(element, "Duplicated translations for msg " + id);
            } else {
              visitAll(this, element.children, null);
              if (typeof this._unitMlString === 'string') {
                this._msgIdToHtml[id] = this._unitMlString;
              } else {
                this._addError(element, "Message " + id + " misses a translation");
              }
            }
          }
          break;
        case _SOURCE_TAG:
          break;
        case _TARGET_TAG:
          var innerTextStart = ((element.startSourceSpan)).end.offset;
          var innerTextEnd = ((element.endSourceSpan)).start.offset;
          var content = ((element.startSourceSpan)).start.file.content;
          var innerText = content.slice(innerTextStart, innerTextEnd);
          this._unitMlString = innerText;
          break;
        case _FILE_TAG:
          var localeAttr = element.attrs.find(function(attr) {
            return attr.name === 'target-language';
          });
          if (localeAttr) {
            this._locale = localeAttr.value;
          }
          visitAll(this, element.children, null);
          break;
        default:
          visitAll(this, element.children, null);
      }
    };
    XliffParser.prototype.visitAttribute = function(attribute, context) {};
    XliffParser.prototype.visitText = function(text, context) {};
    XliffParser.prototype.visitComment = function(comment, context) {};
    XliffParser.prototype.visitExpansion = function(expansion, context) {};
    XliffParser.prototype.visitExpansionCase = function(expansionCase, context) {};
    XliffParser.prototype._addError = function(node, message) {
      this._errors.push(new I18nError(((node.sourceSpan)), message));
    };
    return XliffParser;
  }());
  var XmlToI18n = (function() {
    function XmlToI18n() {}
    XmlToI18n.prototype.convert = function(message, url) {
      var xmlIcu = new XmlParser().parse(message, url, true);
      this._errors = xmlIcu.errors;
      var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : visitAll(this, xmlIcu.rootNodes);
      return {
        i18nNodes: i18nNodes,
        errors: this._errors
      };
    };
    XmlToI18n.prototype.visitText = function(text, context) {
      return new Text$1(text.value, ((text.sourceSpan)));
    };
    XmlToI18n.prototype.visitElement = function(el, context) {
      if (el.name === _PLACEHOLDER_TAG) {
        var nameAttr = el.attrs.find(function(attr) {
          return attr.name === 'id';
        });
        if (nameAttr) {
          return new Placeholder('', nameAttr.value, ((el.sourceSpan)));
        }
        this._addError(el, "<" + _PLACEHOLDER_TAG + "> misses the \"id\" attribute");
      } else {
        this._addError(el, "Unexpected tag");
      }
      return null;
    };
    XmlToI18n.prototype.visitExpansion = function(icu, context) {
      var caseMap = {};
      visitAll(this, icu.cases).forEach(function(c) {
        caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
      });
      return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
    };
    XmlToI18n.prototype.visitExpansionCase = function(icuCase, context) {
      return {
        value: icuCase.value,
        nodes: visitAll(this, icuCase.expression)
      };
    };
    XmlToI18n.prototype.visitComment = function(comment, context) {};
    XmlToI18n.prototype.visitAttribute = function(attribute, context) {};
    XmlToI18n.prototype._addError = function(node, message) {
      this._errors.push(new I18nError(((node.sourceSpan)), message));
    };
    return XmlToI18n;
  }());
  function getCtypeForTag(tag) {
    switch (tag.toLowerCase()) {
      case 'br':
        return 'lb';
      case 'img':
        return 'image';
      default:
        return "x-" + tag;
    }
  }
  var _VERSION$1 = '2.0';
  var _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:2.0';
  var _DEFAULT_SOURCE_LANG$1 = 'en';
  var _PLACEHOLDER_TAG$1 = 'ph';
  var _PLACEHOLDER_SPANNING_TAG = 'pc';
  var _XLIFF_TAG = 'xliff';
  var _SOURCE_TAG$1 = 'source';
  var _TARGET_TAG$1 = 'target';
  var _UNIT_TAG$1 = 'unit';
  var Xliff2 = (function(_super) {
    __extends(Xliff2, _super);
    function Xliff2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Xliff2.prototype.write = function(messages, locale) {
      var visitor = new _WriteVisitor$1();
      var units = [];
      messages.forEach(function(message) {
        var unit = new Tag(_UNIT_TAG$1, {id: message.id});
        var notes = new Tag('notes');
        if (message.description || message.meaning) {
          if (message.description) {
            notes.children.push(new CR(8), new Tag('note', {category: 'description'}, [new Text$2(message.description)]));
          }
          if (message.meaning) {
            notes.children.push(new CR(8), new Tag('note', {category: 'meaning'}, [new Text$2(message.meaning)]));
          }
        }
        message.sources.forEach(function(source) {
          notes.children.push(new CR(8), new Tag('note', {category: 'location'}, [new Text$2(source.filePath + ":" + source.startLine + (source.endLine !== source.startLine ? ',' + source.endLine : ''))]));
        });
        notes.children.push(new CR(6));
        unit.children.push(new CR(6), notes);
        var segment = new Tag('segment');
        segment.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), new CR(6));
        unit.children.push(new CR(6), segment, new CR(4));
        units.push(new CR(4), unit);
      });
      var file = new Tag('file', {
        'original': 'ng.template',
        id: 'ngi18n'
      }, units.concat([new CR(2)]));
      var xliff = new Tag(_XLIFF_TAG, {
        version: _VERSION$1,
        xmlns: _XMLNS$1,
        srcLang: locale || _DEFAULT_SOURCE_LANG$1
      }, [new CR(2), file, new CR()]);
      return serialize([new Declaration({
        version: '1.0',
        encoding: 'UTF-8'
      }), new CR(), xliff, new CR()]);
    };
    Xliff2.prototype.load = function(content, url) {
      var xliff2Parser = new Xliff2Parser();
      var _a = xliff2Parser.parse(content, url),
          locale = _a.locale,
          msgIdToHtml = _a.msgIdToHtml,
          errors = _a.errors;
      var i18nNodesByMsgId = {};
      var converter = new XmlToI18n$1();
      Object.keys(msgIdToHtml).forEach(function(msgId) {
        var _a = converter.convert(msgIdToHtml[msgId], url),
            i18nNodes = _a.i18nNodes,
            e = _a.errors;
        errors.push.apply(errors, e);
        i18nNodesByMsgId[msgId] = i18nNodes;
      });
      if (errors.length) {
        throw new Error("xliff2 parse errors:\n" + errors.join('\n'));
      }
      return {
        locale: ((locale)),
        i18nNodesByMsgId: i18nNodesByMsgId
      };
    };
    Xliff2.prototype.digest = function(message) {
      return decimalDigest(message);
    };
    return Xliff2;
  }(Serializer));
  var _WriteVisitor$1 = (function() {
    function _WriteVisitor$1() {}
    _WriteVisitor$1.prototype.visitText = function(text, context) {
      return [new Text$2(text.value)];
    };
    _WriteVisitor$1.prototype.visitContainer = function(container, context) {
      var _this = this;
      var nodes = [];
      container.children.forEach(function(node) {
        return nodes.push.apply(nodes, node.visit(_this));
      });
      return nodes;
    };
    _WriteVisitor$1.prototype.visitIcu = function(icu, context) {
      var _this = this;
      var nodes = [new Text$2("{" + icu.expressionPlaceholder + ", " + icu.type + ", ")];
      Object.keys(icu.cases).forEach(function(c) {
        nodes.push.apply(nodes, [new Text$2(c + " {")].concat(icu.cases[c].visit(_this), [new Text$2("} ")]));
      });
      nodes.push(new Text$2("}"));
      return nodes;
    };
    _WriteVisitor$1.prototype.visitTagPlaceholder = function(ph, context) {
      var _this = this;
      var type = getTypeForTag(ph.tag);
      if (ph.isVoid) {
        var tagPh = new Tag(_PLACEHOLDER_TAG$1, {
          id: (this._nextPlaceholderId++).toString(),
          equiv: ph.startName,
          type: type,
          disp: "<" + ph.tag + "/>"
        });
        return [tagPh];
      }
      var tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {
        id: (this._nextPlaceholderId++).toString(),
        equivStart: ph.startName,
        equivEnd: ph.closeName,
        type: type,
        dispStart: "<" + ph.tag + ">",
        dispEnd: "</" + ph.tag + ">"
      });
      var nodes = [].concat.apply([], ph.children.map(function(node) {
        return node.visit(_this);
      }));
      if (nodes.length) {
        nodes.forEach(function(node) {
          return tagPc.children.push(node);
        });
      } else {
        tagPc.children.push(new Text$2(''));
      }
      return [tagPc];
    };
    _WriteVisitor$1.prototype.visitPlaceholder = function(ph, context) {
      var idStr = (this._nextPlaceholderId++).toString();
      return [new Tag(_PLACEHOLDER_TAG$1, {
        id: idStr,
        equiv: ph.name,
        disp: "{{" + ph.value + "}}"
      })];
    };
    _WriteVisitor$1.prototype.visitIcuPlaceholder = function(ph, context) {
      var cases = Object.keys(ph.value.cases).map(function(value) {
        return value + ' {...}';
      }).join(' ');
      var idStr = (this._nextPlaceholderId++).toString();
      return [new Tag(_PLACEHOLDER_TAG$1, {
        id: idStr,
        equiv: ph.name,
        disp: "{" + ph.value.expression + ", " + ph.value.type + ", " + cases + "}"
      })];
    };
    _WriteVisitor$1.prototype.serialize = function(nodes) {
      var _this = this;
      this._nextPlaceholderId = 0;
      return [].concat.apply([], nodes.map(function(node) {
        return node.visit(_this);
      }));
    };
    return _WriteVisitor$1;
  }());
  var Xliff2Parser = (function() {
    function Xliff2Parser() {
      this._locale = null;
    }
    Xliff2Parser.prototype.parse = function(xliff, url) {
      this._unitMlString = null;
      this._msgIdToHtml = {};
      var xml = new XmlParser().parse(xliff, url, false);
      this._errors = xml.errors;
      visitAll(this, xml.rootNodes, null);
      return {
        msgIdToHtml: this._msgIdToHtml,
        errors: this._errors,
        locale: this._locale
      };
    };
    Xliff2Parser.prototype.visitElement = function(element, context) {
      switch (element.name) {
        case _UNIT_TAG$1:
          this._unitMlString = null;
          var idAttr = element.attrs.find(function(attr) {
            return attr.name === 'id';
          });
          if (!idAttr) {
            this._addError(element, "<" + _UNIT_TAG$1 + "> misses the \"id\" attribute");
          } else {
            var id = idAttr.value;
            if (this._msgIdToHtml.hasOwnProperty(id)) {
              this._addError(element, "Duplicated translations for msg " + id);
            } else {
              visitAll(this, element.children, null);
              if (typeof this._unitMlString === 'string') {
                this._msgIdToHtml[id] = this._unitMlString;
              } else {
                this._addError(element, "Message " + id + " misses a translation");
              }
            }
          }
          break;
        case _SOURCE_TAG$1:
          break;
        case _TARGET_TAG$1:
          var innerTextStart = ((element.startSourceSpan)).end.offset;
          var innerTextEnd = ((element.endSourceSpan)).start.offset;
          var content = ((element.startSourceSpan)).start.file.content;
          var innerText = content.slice(innerTextStart, innerTextEnd);
          this._unitMlString = innerText;
          break;
        case _XLIFF_TAG:
          var localeAttr = element.attrs.find(function(attr) {
            return attr.name === 'trgLang';
          });
          if (localeAttr) {
            this._locale = localeAttr.value;
          }
          var versionAttr = element.attrs.find(function(attr) {
            return attr.name === 'version';
          });
          if (versionAttr) {
            var version = versionAttr.value;
            if (version !== '2.0') {
              this._addError(element, "The XLIFF file version " + version + " is not compatible with XLIFF 2.0 serializer");
            } else {
              visitAll(this, element.children, null);
            }
          }
          break;
        default:
          visitAll(this, element.children, null);
      }
    };
    Xliff2Parser.prototype.visitAttribute = function(attribute, context) {};
    Xliff2Parser.prototype.visitText = function(text, context) {};
    Xliff2Parser.prototype.visitComment = function(comment, context) {};
    Xliff2Parser.prototype.visitExpansion = function(expansion, context) {};
    Xliff2Parser.prototype.visitExpansionCase = function(expansionCase, context) {};
    Xliff2Parser.prototype._addError = function(node, message) {
      this._errors.push(new I18nError(node.sourceSpan, message));
    };
    return Xliff2Parser;
  }());
  var XmlToI18n$1 = (function() {
    function XmlToI18n$1() {}
    XmlToI18n$1.prototype.convert = function(message, url) {
      var xmlIcu = new XmlParser().parse(message, url, true);
      this._errors = xmlIcu.errors;
      var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : [].concat.apply([], visitAll(this, xmlIcu.rootNodes));
      return {
        i18nNodes: i18nNodes,
        errors: this._errors
      };
    };
    XmlToI18n$1.prototype.visitText = function(text, context) {
      return new Text$1(text.value, text.sourceSpan);
    };
    XmlToI18n$1.prototype.visitElement = function(el, context) {
      var _this = this;
      switch (el.name) {
        case _PLACEHOLDER_TAG$1:
          var nameAttr = el.attrs.find(function(attr) {
            return attr.name === 'equiv';
          });
          if (nameAttr) {
            return [new Placeholder('', nameAttr.value, el.sourceSpan)];
          }
          this._addError(el, "<" + _PLACEHOLDER_TAG$1 + "> misses the \"equiv\" attribute");
          break;
        case _PLACEHOLDER_SPANNING_TAG:
          var startAttr = el.attrs.find(function(attr) {
            return attr.name === 'equivStart';
          });
          var endAttr = el.attrs.find(function(attr) {
            return attr.name === 'equivEnd';
          });
          if (!startAttr) {
            this._addError(el, "<" + _PLACEHOLDER_TAG$1 + "> misses the \"equivStart\" attribute");
          } else if (!endAttr) {
            this._addError(el, "<" + _PLACEHOLDER_TAG$1 + "> misses the \"equivEnd\" attribute");
          } else {
            var startId = startAttr.value;
            var endId = endAttr.value;
            var nodes = [];
            return nodes.concat.apply(nodes, [new Placeholder('', startId, el.sourceSpan)].concat(el.children.map(function(node) {
              return node.visit(_this, null);
            }), [new Placeholder('', endId, el.sourceSpan)]));
          }
          break;
        default:
          this._addError(el, "Unexpected tag");
      }
      return null;
    };
    XmlToI18n$1.prototype.visitExpansion = function(icu, context) {
      var caseMap = {};
      visitAll(this, icu.cases).forEach(function(c) {
        caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
      });
      return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
    };
    XmlToI18n$1.prototype.visitExpansionCase = function(icuCase, context) {
      return {
        value: icuCase.value,
        nodes: [].concat.apply([], visitAll(this, icuCase.expression))
      };
    };
    XmlToI18n$1.prototype.visitComment = function(comment, context) {};
    XmlToI18n$1.prototype.visitAttribute = function(attribute, context) {};
    XmlToI18n$1.prototype._addError = function(node, message) {
      this._errors.push(new I18nError(node.sourceSpan, message));
    };
    return XmlToI18n$1;
  }());
  function getTypeForTag(tag) {
    switch (tag.toLowerCase()) {
      case 'br':
      case 'b':
      case 'i':
      case 'u':
        return 'fmt';
      case 'img':
        return 'image';
      case 'a':
        return 'link';
      default:
        return 'other';
    }
  }
  var _MESSAGES_TAG = 'messagebundle';
  var _MESSAGE_TAG = 'msg';
  var _PLACEHOLDER_TAG$2 = 'ph';
  var _EXEMPLE_TAG = 'ex';
  var _SOURCE_TAG$2 = 'source';
  var _DOCTYPE = "<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>";
  var Xmb = (function(_super) {
    __extends(Xmb, _super);
    function Xmb() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Xmb.prototype.write = function(messages, locale) {
      var exampleVisitor = new ExampleVisitor();
      var visitor = new _Visitor$2();
      var rootNode = new Tag(_MESSAGES_TAG);
      messages.forEach(function(message) {
        var attrs = {id: message.id};
        if (message.description) {
          attrs['desc'] = message.description;
        }
        if (message.meaning) {
          attrs['meaning'] = message.meaning;
        }
        var sourceTags = [];
        message.sources.forEach(function(source) {
          sourceTags.push(new Tag(_SOURCE_TAG$2, {}, [new Text$2(source.filePath + ":" + source.startLine + (source.endLine !== source.startLine ? ',' + source.endLine : ''))]));
        });
        rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, sourceTags.concat(visitor.serialize(message.nodes))));
      });
      rootNode.children.push(new CR());
      return serialize([new Declaration({
        version: '1.0',
        encoding: 'UTF-8'
      }), new CR(), new Doctype(_MESSAGES_TAG, _DOCTYPE), new CR(), exampleVisitor.addDefaultExamples(rootNode), new CR()]);
    };
    Xmb.prototype.load = function(content, url) {
      throw new Error('Unsupported');
    };
    Xmb.prototype.digest = function(message) {
      return digest$1(message);
    };
    Xmb.prototype.createNameMapper = function(message) {
      return new SimplePlaceholderMapper(message, toPublicName);
    };
    return Xmb;
  }(Serializer));
  var _Visitor$2 = (function() {
    function _Visitor$2() {}
    _Visitor$2.prototype.visitText = function(text, context) {
      return [new Text$2(text.value)];
    };
    _Visitor$2.prototype.visitContainer = function(container, context) {
      var _this = this;
      var nodes = [];
      container.children.forEach(function(node) {
        return nodes.push.apply(nodes, node.visit(_this));
      });
      return nodes;
    };
    _Visitor$2.prototype.visitIcu = function(icu, context) {
      var _this = this;
      var nodes = [new Text$2("{" + icu.expressionPlaceholder + ", " + icu.type + ", ")];
      Object.keys(icu.cases).forEach(function(c) {
        nodes.push.apply(nodes, [new Text$2(c + " {")].concat(icu.cases[c].visit(_this), [new Text$2("} ")]));
      });
      nodes.push(new Text$2("}"));
      return nodes;
    };
    _Visitor$2.prototype.visitTagPlaceholder = function(ph, context) {
      var startEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2("<" + ph.tag + ">")]);
      var startTagPh = new Tag(_PLACEHOLDER_TAG$2, {name: ph.startName}, [startEx]);
      if (ph.isVoid) {
        return [startTagPh];
      }
      var closeEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2("</" + ph.tag + ">")]);
      var closeTagPh = new Tag(_PLACEHOLDER_TAG$2, {name: ph.closeName}, [closeEx]);
      return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);
    };
    _Visitor$2.prototype.visitPlaceholder = function(ph, context) {
      return [new Tag(_PLACEHOLDER_TAG$2, {name: ph.name})];
    };
    _Visitor$2.prototype.visitIcuPlaceholder = function(ph, context) {
      return [new Tag(_PLACEHOLDER_TAG$2, {name: ph.name})];
    };
    _Visitor$2.prototype.serialize = function(nodes) {
      var _this = this;
      return [].concat.apply([], nodes.map(function(node) {
        return node.visit(_this);
      }));
    };
    return _Visitor$2;
  }());
  function digest$1(message) {
    return decimalDigest(message);
  }
  var ExampleVisitor = (function() {
    function ExampleVisitor() {}
    ExampleVisitor.prototype.addDefaultExamples = function(node) {
      node.visit(this);
      return node;
    };
    ExampleVisitor.prototype.visitTag = function(tag) {
      var _this = this;
      if (tag.name === _PLACEHOLDER_TAG$2) {
        if (!tag.children || tag.children.length == 0) {
          var exText = new Text$2(tag.attrs['name'] || '...');
          tag.children = [new Tag(_EXEMPLE_TAG, {}, [exText])];
        }
      } else if (tag.children) {
        tag.children.forEach(function(node) {
          return node.visit(_this);
        });
      }
    };
    ExampleVisitor.prototype.visitText = function(text) {};
    ExampleVisitor.prototype.visitDeclaration = function(decl) {};
    ExampleVisitor.prototype.visitDoctype = function(doctype) {};
    return ExampleVisitor;
  }());
  function toPublicName(internalName) {
    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');
  }
  var _TRANSLATIONS_TAG = 'translationbundle';
  var _TRANSLATION_TAG = 'translation';
  var _PLACEHOLDER_TAG$3 = 'ph';
  var Xtb = (function(_super) {
    __extends(Xtb, _super);
    function Xtb() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Xtb.prototype.write = function(messages, locale) {
      throw new Error('Unsupported');
    };
    Xtb.prototype.load = function(content, url) {
      var xtbParser = new XtbParser();
      var _a = xtbParser.parse(content, url),
          locale = _a.locale,
          msgIdToHtml = _a.msgIdToHtml,
          errors = _a.errors;
      var i18nNodesByMsgId = {};
      var converter = new XmlToI18n$2();
      Object.keys(msgIdToHtml).forEach(function(msgId) {
        var valueFn = function() {
          var _a = converter.convert(msgIdToHtml[msgId], url),
              i18nNodes = _a.i18nNodes,
              errors = _a.errors;
          if (errors.length) {
            throw new Error("xtb parse errors:\n" + errors.join('\n'));
          }
          return i18nNodes;
        };
        createLazyProperty(i18nNodesByMsgId, msgId, valueFn);
      });
      if (errors.length) {
        throw new Error("xtb parse errors:\n" + errors.join('\n'));
      }
      return {
        locale: ((locale)),
        i18nNodesByMsgId: i18nNodesByMsgId
      };
    };
    Xtb.prototype.digest = function(message) {
      return digest$1(message);
    };
    Xtb.prototype.createNameMapper = function(message) {
      return new SimplePlaceholderMapper(message, toPublicName);
    };
    return Xtb;
  }(Serializer));
  function createLazyProperty(messages, id, valueFn) {
    Object.defineProperty(messages, id, {
      configurable: true,
      enumerable: true,
      get: function() {
        var value = valueFn();
        Object.defineProperty(messages, id, {
          enumerable: true,
          value: value
        });
        return value;
      },
      set: function(_) {
        throw new Error('Could not overwrite an XTB translation');
      }
    });
  }
  var XtbParser = (function() {
    function XtbParser() {
      this._locale = null;
    }
    XtbParser.prototype.parse = function(xtb, url) {
      this._bundleDepth = 0;
      this._msgIdToHtml = {};
      var xml = new XmlParser().parse(xtb, url, false);
      this._errors = xml.errors;
      visitAll(this, xml.rootNodes);
      return {
        msgIdToHtml: this._msgIdToHtml,
        errors: this._errors,
        locale: this._locale
      };
    };
    XtbParser.prototype.visitElement = function(element, context) {
      switch (element.name) {
        case _TRANSLATIONS_TAG:
          this._bundleDepth++;
          if (this._bundleDepth > 1) {
            this._addError(element, "<" + _TRANSLATIONS_TAG + "> elements can not be nested");
          }
          var langAttr = element.attrs.find(function(attr) {
            return attr.name === 'lang';
          });
          if (langAttr) {
            this._locale = langAttr.value;
          }
          visitAll(this, element.children, null);
          this._bundleDepth--;
          break;
        case _TRANSLATION_TAG:
          var idAttr = element.attrs.find(function(attr) {
            return attr.name === 'id';
          });
          if (!idAttr) {
            this._addError(element, "<" + _TRANSLATION_TAG + "> misses the \"id\" attribute");
          } else {
            var id = idAttr.value;
            if (this._msgIdToHtml.hasOwnProperty(id)) {
              this._addError(element, "Duplicated translations for msg " + id);
            } else {
              var innerTextStart = ((element.startSourceSpan)).end.offset;
              var innerTextEnd = ((element.endSourceSpan)).start.offset;
              var content = ((element.startSourceSpan)).start.file.content;
              var innerText = content.slice(((innerTextStart)), ((innerTextEnd)));
              this._msgIdToHtml[id] = innerText;
            }
          }
          break;
        default:
          this._addError(element, 'Unexpected tag');
      }
    };
    XtbParser.prototype.visitAttribute = function(attribute, context) {};
    XtbParser.prototype.visitText = function(text, context) {};
    XtbParser.prototype.visitComment = function(comment, context) {};
    XtbParser.prototype.visitExpansion = function(expansion, context) {};
    XtbParser.prototype.visitExpansionCase = function(expansionCase, context) {};
    XtbParser.prototype._addError = function(node, message) {
      this._errors.push(new I18nError(((node.sourceSpan)), message));
    };
    return XtbParser;
  }());
  var XmlToI18n$2 = (function() {
    function XmlToI18n$2() {}
    XmlToI18n$2.prototype.convert = function(message, url) {
      var xmlIcu = new XmlParser().parse(message, url, true);
      this._errors = xmlIcu.errors;
      var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : visitAll(this, xmlIcu.rootNodes);
      return {
        i18nNodes: i18nNodes,
        errors: this._errors
      };
    };
    XmlToI18n$2.prototype.visitText = function(text, context) {
      return new Text$1(text.value, ((text.sourceSpan)));
    };
    XmlToI18n$2.prototype.visitExpansion = function(icu, context) {
      var caseMap = {};
      visitAll(this, icu.cases).forEach(function(c) {
        caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
      });
      return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
    };
    XmlToI18n$2.prototype.visitExpansionCase = function(icuCase, context) {
      return {
        value: icuCase.value,
        nodes: visitAll(this, icuCase.expression)
      };
    };
    XmlToI18n$2.prototype.visitElement = function(el, context) {
      if (el.name === _PLACEHOLDER_TAG$3) {
        var nameAttr = el.attrs.find(function(attr) {
          return attr.name === 'name';
        });
        if (nameAttr) {
          return new Placeholder('', nameAttr.value, ((el.sourceSpan)));
        }
        this._addError(el, "<" + _PLACEHOLDER_TAG$3 + "> misses the \"name\" attribute");
      } else {
        this._addError(el, "Unexpected tag");
      }
      return null;
    };
    XmlToI18n$2.prototype.visitComment = function(comment, context) {};
    XmlToI18n$2.prototype.visitAttribute = function(attribute, context) {};
    XmlToI18n$2.prototype._addError = function(node, message) {
      this._errors.push(new I18nError(((node.sourceSpan)), message));
    };
    return XmlToI18n$2;
  }());
  var HtmlParser = (function(_super) {
    __extends(HtmlParser, _super);
    function HtmlParser() {
      return _super.call(this, getHtmlTagDefinition) || this;
    }
    HtmlParser.prototype.parse = function(source, url, parseExpansionForms, interpolationConfig) {
      if (parseExpansionForms === void 0) {
        parseExpansionForms = false;
      }
      if (interpolationConfig === void 0) {
        interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;
      }
      return _super.prototype.parse.call(this, source, url, parseExpansionForms, interpolationConfig);
    };
    return HtmlParser;
  }(Parser$1));
  HtmlParser.decorators = [{type: CompilerInjectable}];
  HtmlParser.ctorParameters = function() {
    return [];
  };
  var TranslationBundle = (function() {
    function TranslationBundle(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console) {
      if (_i18nNodesByMsgId === void 0) {
        _i18nNodesByMsgId = {};
      }
      if (missingTranslationStrategy === void 0) {
        missingTranslationStrategy = _angular_core.MissingTranslationStrategy.Warning;
      }
      this._i18nNodesByMsgId = _i18nNodesByMsgId;
      this.digest = digest;
      this.mapperFactory = mapperFactory;
      this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);
    }
    TranslationBundle.load = function(content, url, serializer, missingTranslationStrategy, console) {
      var _a = serializer.load(content, url),
          locale = _a.locale,
          i18nNodesByMsgId = _a.i18nNodesByMsgId;
      var digestFn = function(m) {
        return serializer.digest(m);
      };
      var mapperFactory = function(m) {
        return ((serializer.createNameMapper(m)));
      };
      return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);
    };
    TranslationBundle.prototype.get = function(srcMsg) {
      var html = this._i18nToHtml.convert(srcMsg);
      if (html.errors.length) {
        throw new Error(html.errors.join('\n'));
      }
      return html.nodes;
    };
    TranslationBundle.prototype.has = function(srcMsg) {
      return this.digest(srcMsg) in this._i18nNodesByMsgId;
    };
    return TranslationBundle;
  }());
  var I18nToHtmlVisitor = (function() {
    function I18nToHtmlVisitor(_i18nNodesByMsgId, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {
      if (_i18nNodesByMsgId === void 0) {
        _i18nNodesByMsgId = {};
      }
      this._i18nNodesByMsgId = _i18nNodesByMsgId;
      this._locale = _locale;
      this._digest = _digest;
      this._mapperFactory = _mapperFactory;
      this._missingTranslationStrategy = _missingTranslationStrategy;
      this._console = _console;
      this._contextStack = [];
      this._errors = [];
    }
    I18nToHtmlVisitor.prototype.convert = function(srcMsg) {
      this._contextStack.length = 0;
      this._errors.length = 0;
      var text = this._convertToText(srcMsg);
      var url = srcMsg.nodes[0].sourceSpan.start.file.url;
      var html = new HtmlParser().parse(text, url, true);
      return {
        nodes: html.rootNodes,
        errors: this._errors.concat(html.errors)
      };
    };
    I18nToHtmlVisitor.prototype.visitText = function(text, context) {
      return text.value;
    };
    I18nToHtmlVisitor.prototype.visitContainer = function(container, context) {
      var _this = this;
      return container.children.map(function(n) {
        return n.visit(_this);
      }).join('');
    };
    I18nToHtmlVisitor.prototype.visitIcu = function(icu, context) {
      var _this = this;
      var cases = Object.keys(icu.cases).map(function(k) {
        return k + " {" + icu.cases[k].visit(_this) + "}";
      });
      var exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ? this._srcMsg.placeholders[icu.expression] : icu.expression;
      return "{" + exp + ", " + icu.type + ", " + cases.join(' ') + "}";
    };
    I18nToHtmlVisitor.prototype.visitPlaceholder = function(ph, context) {
      var phName = this._mapper(ph.name);
      if (this._srcMsg.placeholders.hasOwnProperty(phName)) {
        return this._srcMsg.placeholders[phName];
      }
      if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {
        return this._convertToText(this._srcMsg.placeholderToMessage[phName]);
      }
      this._addError(ph, "Unknown placeholder \"" + ph.name + "\"");
      return '';
    };
    I18nToHtmlVisitor.prototype.visitTagPlaceholder = function(ph, context) {
      var _this = this;
      var tag = "" + ph.tag;
      var attrs = Object.keys(ph.attrs).map(function(name) {
        return name + "=\"" + ph.attrs[name] + "\"";
      }).join(' ');
      if (ph.isVoid) {
        return "<" + tag + " " + attrs + "/>";
      }
      var children = ph.children.map(function(c) {
        return c.visit(_this);
      }).join('');
      return "<" + tag + " " + attrs + ">" + children + "</" + tag + ">";
    };
    I18nToHtmlVisitor.prototype.visitIcuPlaceholder = function(ph, context) {
      return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);
    };
    I18nToHtmlVisitor.prototype._convertToText = function(srcMsg) {
      var _this = this;
      var id = this._digest(srcMsg);
      var mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;
      var nodes;
      this._contextStack.push({
        msg: this._srcMsg,
        mapper: this._mapper
      });
      this._srcMsg = srcMsg;
      if (this._i18nNodesByMsgId.hasOwnProperty(id)) {
        nodes = this._i18nNodesByMsgId[id];
        this._mapper = function(name) {
          return mapper ? ((mapper.toInternalName(name))) : name;
        };
      } else {
        if (this._missingTranslationStrategy === _angular_core.MissingTranslationStrategy.Error) {
          var ctx = this._locale ? " for locale \"" + this._locale + "\"" : '';
          this._addError(srcMsg.nodes[0], "Missing translation for message \"" + id + "\"" + ctx);
        } else if (this._console && this._missingTranslationStrategy === _angular_core.MissingTranslationStrategy.Warning) {
          var ctx = this._locale ? " for locale \"" + this._locale + "\"" : '';
          this._console.warn("Missing translation for message \"" + id + "\"" + ctx);
        }
        nodes = srcMsg.nodes;
        this._mapper = function(name) {
          return name;
        };
      }
      var text = nodes.map(function(node) {
        return node.visit(_this);
      }).join('');
      var context = ((this._contextStack.pop()));
      this._srcMsg = context.msg;
      this._mapper = context.mapper;
      return text;
    };
    I18nToHtmlVisitor.prototype._addError = function(el, msg) {
      this._errors.push(new I18nError(el.sourceSpan, msg));
    };
    return I18nToHtmlVisitor;
  }());
  var I18NHtmlParser = (function() {
    function I18NHtmlParser(_htmlParser, translations, translationsFormat, missingTranslation, console) {
      if (missingTranslation === void 0) {
        missingTranslation = _angular_core.MissingTranslationStrategy.Warning;
      }
      this._htmlParser = _htmlParser;
      if (translations) {
        var serializer = createSerializer(translationsFormat);
        this._translationBundle = TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);
      } else {
        this._translationBundle = new TranslationBundle({}, null, digest, undefined, missingTranslation, console);
      }
    }
    I18NHtmlParser.prototype.parse = function(source, url, parseExpansionForms, interpolationConfig) {
      if (parseExpansionForms === void 0) {
        parseExpansionForms = false;
      }
      if (interpolationConfig === void 0) {
        interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;
      }
      var parseResult = this._htmlParser.parse(source, url, parseExpansionForms, interpolationConfig);
      if (parseResult.errors.length) {
        return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);
      }
      return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});
    };
    return I18NHtmlParser;
  }());
  function createSerializer(format) {
    format = (format || 'xlf').toLowerCase();
    switch (format) {
      case 'xmb':
        return new Xmb();
      case 'xtb':
        return new Xtb();
      case 'xliff2':
      case 'xlf2':
        return new Xliff2();
      case 'xliff':
      case 'xlf':
      default:
        return new Xliff();
    }
  }
  var CORE = '@angular/core';
  var Identifiers = (function() {
    function Identifiers() {}
    return Identifiers;
  }());
  Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {
    name: 'ANALYZE_FOR_ENTRY_COMPONENTS',
    moduleName: CORE,
    runtime: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS
  };
  Identifiers.ElementRef = {
    name: 'ElementRef',
    moduleName: CORE,
    runtime: _angular_core.ElementRef
  };
  Identifiers.NgModuleRef = {
    name: 'NgModuleRef',
    moduleName: CORE,
    runtime: _angular_core.NgModuleRef
  };
  Identifiers.ViewContainerRef = {
    name: 'ViewContainerRef',
    moduleName: CORE,
    runtime: _angular_core.ViewContainerRef
  };
  Identifiers.ChangeDetectorRef = {
    name: 'ChangeDetectorRef',
    moduleName: CORE,
    runtime: _angular_core.ChangeDetectorRef
  };
  Identifiers.QueryList = {
    name: 'QueryList',
    moduleName: CORE,
    runtime: _angular_core.QueryList
  };
  Identifiers.TemplateRef = {
    name: 'TemplateRef',
    moduleName: CORE,
    runtime: _angular_core.TemplateRef
  };
  Identifiers.CodegenComponentFactoryResolver = {
    name: 'ɵCodegenComponentFactoryResolver',
    moduleName: CORE,
    runtime: _angular_core.ɵCodegenComponentFactoryResolver
  };
  Identifiers.ComponentFactoryResolver = {
    name: 'ComponentFactoryResolver',
    moduleName: CORE,
    runtime: _angular_core.ComponentFactoryResolver
  };
  Identifiers.ComponentFactory = {
    name: 'ComponentFactory',
    moduleName: CORE,
    runtime: _angular_core.ComponentFactory
  };
  Identifiers.ComponentRef = {
    name: 'ComponentRef',
    moduleName: CORE,
    runtime: _angular_core.ComponentRef
  };
  Identifiers.NgModuleFactory = {
    name: 'NgModuleFactory',
    moduleName: CORE,
    runtime: _angular_core.NgModuleFactory
  };
  Identifiers.createModuleFactory = {
    name: 'ɵcmf',
    moduleName: CORE,
    runtime: _angular_core.ɵcmf
  };
  Identifiers.moduleDef = {
    name: 'ɵmod',
    moduleName: CORE,
    runtime: _angular_core.ɵmod
  };
  Identifiers.moduleProviderDef = {
    name: 'ɵmpd',
    moduleName: CORE,
    runtime: _angular_core.ɵmpd
  };
  Identifiers.RegisterModuleFactoryFn = {
    name: 'ɵregisterModuleFactory',
    moduleName: CORE,
    runtime: _angular_core.ɵregisterModuleFactory
  };
  Identifiers.Injector = {
    name: 'Injector',
    moduleName: CORE,
    runtime: _angular_core.Injector
  };
  Identifiers.ViewEncapsulation = {
    name: 'ViewEncapsulation',
    moduleName: CORE,
    runtime: _angular_core.ViewEncapsulation
  };
  Identifiers.ChangeDetectionStrategy = {
    name: 'ChangeDetectionStrategy',
    moduleName: CORE,
    runtime: _angular_core.ChangeDetectionStrategy
  };
  Identifiers.SecurityContext = {
    name: 'SecurityContext',
    moduleName: CORE,
    runtime: _angular_core.SecurityContext
  };
  Identifiers.LOCALE_ID = {
    name: 'LOCALE_ID',
    moduleName: CORE,
    runtime: _angular_core.LOCALE_ID
  };
  Identifiers.TRANSLATIONS_FORMAT = {
    name: 'TRANSLATIONS_FORMAT',
    moduleName: CORE,
    runtime: _angular_core.TRANSLATIONS_FORMAT
  };
  Identifiers.inlineInterpolate = {
    name: 'ɵinlineInterpolate',
    moduleName: CORE,
    runtime: _angular_core.ɵinlineInterpolate
  };
  Identifiers.interpolate = {
    name: 'ɵinterpolate',
    moduleName: CORE,
    runtime: _angular_core.ɵinterpolate
  };
  Identifiers.EMPTY_ARRAY = {
    name: 'ɵEMPTY_ARRAY',
    moduleName: CORE,
    runtime: _angular_core.ɵEMPTY_ARRAY
  };
  Identifiers.EMPTY_MAP = {
    name: 'ɵEMPTY_MAP',
    moduleName: CORE,
    runtime: _angular_core.ɵEMPTY_MAP
  };
  Identifiers.Renderer = {
    name: 'Renderer',
    moduleName: CORE,
    runtime: _angular_core.Renderer
  };
  Identifiers.viewDef = {
    name: 'ɵvid',
    moduleName: CORE,
    runtime: _angular_core.ɵvid
  };
  Identifiers.elementDef = {
    name: 'ɵeld',
    moduleName: CORE,
    runtime: _angular_core.ɵeld
  };
  Identifiers.anchorDef = {
    name: 'ɵand',
    moduleName: CORE,
    runtime: _angular_core.ɵand
  };
  Identifiers.textDef = {
    name: 'ɵted',
    moduleName: CORE,
    runtime: _angular_core.ɵted
  };
  Identifiers.directiveDef = {
    name: 'ɵdid',
    moduleName: CORE,
    runtime: _angular_core.ɵdid
  };
  Identifiers.providerDef = {
    name: 'ɵprd',
    moduleName: CORE,
    runtime: _angular_core.ɵprd
  };
  Identifiers.queryDef = {
    name: 'ɵqud',
    moduleName: CORE,
    runtime: _angular_core.ɵqud
  };
  Identifiers.pureArrayDef = {
    name: 'ɵpad',
    moduleName: CORE,
    runtime: _angular_core.ɵpad
  };
  Identifiers.pureObjectDef = {
    name: 'ɵpod',
    moduleName: CORE,
    runtime: _angular_core.ɵpod
  };
  Identifiers.purePipeDef = {
    name: 'ɵppd',
    moduleName: CORE,
    runtime: _angular_core.ɵppd
  };
  Identifiers.pipeDef = {
    name: 'ɵpid',
    moduleName: CORE,
    runtime: _angular_core.ɵpid
  };
  Identifiers.nodeValue = {
    name: 'ɵnov',
    moduleName: CORE,
    runtime: _angular_core.ɵnov
  };
  Identifiers.ngContentDef = {
    name: 'ɵncd',
    moduleName: CORE,
    runtime: _angular_core.ɵncd
  };
  Identifiers.unwrapValue = {
    name: 'ɵunv',
    moduleName: CORE,
    runtime: _angular_core.ɵunv
  };
  Identifiers.createRendererType2 = {
    name: 'ɵcrt',
    moduleName: CORE,
    runtime: _angular_core.ɵcrt
  };
  Identifiers.RendererType2 = {
    name: 'RendererType2',
    moduleName: CORE,
    runtime: null
  };
  Identifiers.ViewDefinition = {
    name: 'ɵViewDefinition',
    moduleName: CORE,
    runtime: null
  };
  Identifiers.createComponentFactory = {
    name: 'ɵccf',
    moduleName: CORE,
    runtime: _angular_core.ɵccf
  };
  function createTokenForReference(reference) {
    return {identifier: {reference: reference}};
  }
  function createTokenForExternalReference(reflector, reference) {
    return createTokenForReference(reflector.resolveExternalReference(reference));
  }
  var PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];
  function expandNodes(nodes) {
    var expander = new _Expander();
    return new ExpansionResult(visitAll(expander, nodes), expander.isExpanded, expander.errors);
  }
  var ExpansionResult = (function() {
    function ExpansionResult(nodes, expanded, errors) {
      this.nodes = nodes;
      this.expanded = expanded;
      this.errors = errors;
    }
    return ExpansionResult;
  }());
  var ExpansionError = (function(_super) {
    __extends(ExpansionError, _super);
    function ExpansionError(span, errorMsg) {
      return _super.call(this, span, errorMsg) || this;
    }
    return ExpansionError;
  }(ParseError));
  var _Expander = (function() {
    function _Expander() {
      this.isExpanded = false;
      this.errors = [];
    }
    _Expander.prototype.visitElement = function(element, context) {
      return new Element(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);
    };
    _Expander.prototype.visitAttribute = function(attribute, context) {
      return attribute;
    };
    _Expander.prototype.visitText = function(text, context) {
      return text;
    };
    _Expander.prototype.visitComment = function(comment, context) {
      return comment;
    };
    _Expander.prototype.visitExpansion = function(icu, context) {
      this.isExpanded = true;
      return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) : _expandDefaultForm(icu, this.errors);
    };
    _Expander.prototype.visitExpansionCase = function(icuCase, context) {
      throw new Error('Should not be reached');
    };
    return _Expander;
  }());
  function _expandPluralForm(ast, errors) {
    var children = ast.cases.map(function(c) {
      if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\d+$/)) {
        errors.push(new ExpansionError(c.valueSourceSpan, "Plural cases should be \"=<number>\" or one of " + PLURAL_CASES.join(", ")));
      }
      var expansionResult = expandNodes(c.expression);
      errors.push.apply(errors, expansionResult.errors);
      return new Element("ng-template", [new Attribute$1('ngPluralCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
    });
    var switchAttr = new Attribute$1('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);
    return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
  }
  function _expandDefaultForm(ast, errors) {
    var children = ast.cases.map(function(c) {
      var expansionResult = expandNodes(c.expression);
      errors.push.apply(errors, expansionResult.errors);
      if (c.value === 'other') {
        return new Element("ng-template", [new Attribute$1('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
      }
      return new Element("ng-template", [new Attribute$1('ngSwitchCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
    });
    var switchAttr = new Attribute$1('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);
    return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
  }
  var ProviderError = (function(_super) {
    __extends(ProviderError, _super);
    function ProviderError(message, span) {
      return _super.call(this, span, message) || this;
    }
    return ProviderError;
  }(ParseError));
  var ProviderViewContext = (function() {
    function ProviderViewContext(reflector, component) {
      var _this = this;
      this.reflector = reflector;
      this.component = component;
      this.errors = [];
      this.viewQueries = _getViewQueries(component);
      this.viewProviders = new Map();
      component.viewProviders.forEach(function(provider) {
        if (_this.viewProviders.get(tokenReference(provider.token)) == null) {
          _this.viewProviders.set(tokenReference(provider.token), true);
        }
      });
    }
    return ProviderViewContext;
  }());
  var ProviderElementContext = (function() {
    function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {
      var _this = this;
      this.viewContext = viewContext;
      this._parent = _parent;
      this._isViewRoot = _isViewRoot;
      this._directiveAsts = _directiveAsts;
      this._sourceSpan = _sourceSpan;
      this._transformedProviders = new Map();
      this._seenProviders = new Map();
      this._hasViewContainer = false;
      this._queriedTokens = new Map();
      this._attrs = {};
      attrs.forEach(function(attrAst) {
        return _this._attrs[attrAst.name] = attrAst.value;
      });
      var directivesMeta = _directiveAsts.map(function(directiveAst) {
        return directiveAst.directive;
      });
      this._allProviders = _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);
      this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);
      Array.from(this._allProviders.values()).forEach(function(provider) {
        _this._addQueryReadsTo(provider.token, provider.token, _this._queriedTokens);
      });
      if (isTemplate) {
        var templateRefId = createTokenForExternalReference(this.viewContext.reflector, Identifiers.TemplateRef);
        this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);
      }
      refs.forEach(function(refAst) {
        var defaultQueryValue = refAst.value || createTokenForExternalReference(_this.viewContext.reflector, Identifiers.ElementRef);
        _this._addQueryReadsTo({value: refAst.name}, defaultQueryValue, _this._queriedTokens);
      });
      if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef))) {
        this._hasViewContainer = true;
      }
      Array.from(this._allProviders.values()).forEach(function(provider) {
        var eager = provider.eager || _this._queriedTokens.get(tokenReference(provider.token));
        if (eager) {
          _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);
        }
      });
    }
    ProviderElementContext.prototype.afterElement = function() {
      var _this = this;
      Array.from(this._allProviders.values()).forEach(function(provider) {
        _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);
      });
    };
    Object.defineProperty(ProviderElementContext.prototype, "transformProviders", {
      get: function() {
        var lazyProviders = [];
        var eagerProviders = [];
        this._transformedProviders.forEach(function(provider) {
          if (provider.eager) {
            eagerProviders.push(provider);
          } else {
            lazyProviders.push(provider);
          }
        });
        return lazyProviders.concat(eagerProviders);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ProviderElementContext.prototype, "transformedDirectiveAsts", {
      get: function() {
        var sortedProviderTypes = this.transformProviders.map(function(provider) {
          return provider.token.identifier;
        });
        var sortedDirectives = this._directiveAsts.slice();
        sortedDirectives.sort(function(dir1, dir2) {
          return sortedProviderTypes.indexOf(dir1.directive.type) - sortedProviderTypes.indexOf(dir2.directive.type);
        });
        return sortedDirectives;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ProviderElementContext.prototype, "transformedHasViewContainer", {
      get: function() {
        return this._hasViewContainer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ProviderElementContext.prototype, "queryMatches", {
      get: function() {
        var allMatches = [];
        this._queriedTokens.forEach(function(matches) {
          allMatches.push.apply(allMatches, matches);
        });
        return allMatches;
      },
      enumerable: true,
      configurable: true
    });
    ProviderElementContext.prototype._addQueryReadsTo = function(token, defaultValue, queryReadTokens) {
      this._getQueriesFor(token).forEach(function(query) {
        var queryValue = query.meta.read || defaultValue;
        var tokenRef = tokenReference(queryValue);
        var queryMatches = queryReadTokens.get(tokenRef);
        if (!queryMatches) {
          queryMatches = [];
          queryReadTokens.set(tokenRef, queryMatches);
        }
        queryMatches.push({
          queryId: query.queryId,
          value: queryValue
        });
      });
    };
    ProviderElementContext.prototype._getQueriesFor = function(token) {
      var result = [];
      var currentEl = this;
      var distance = 0;
      var queries;
      while (currentEl !== null) {
        queries = currentEl._contentQueries.get(tokenReference(token));
        if (queries) {
          result.push.apply(result, queries.filter(function(query) {
            return query.meta.descendants || distance <= 1;
          }));
        }
        if (currentEl._directiveAsts.length > 0) {
          distance++;
        }
        currentEl = currentEl._parent;
      }
      queries = this.viewContext.viewQueries.get(tokenReference(token));
      if (queries) {
        result.push.apply(result, queries);
      }
      return result;
    };
    ProviderElementContext.prototype._getOrCreateLocalProvider = function(requestingProviderType, token, eager) {
      var _this = this;
      var resolvedProvider = this._allProviders.get(tokenReference(token));
      if (!resolvedProvider || ((requestingProviderType === ProviderAstType.Directive || requestingProviderType === ProviderAstType.PublicService) && resolvedProvider.providerType === ProviderAstType.PrivateService) || ((requestingProviderType === ProviderAstType.PrivateService || requestingProviderType === ProviderAstType.PublicService) && resolvedProvider.providerType === ProviderAstType.Builtin)) {
        return null;
      }
      var transformedProviderAst = this._transformedProviders.get(tokenReference(token));
      if (transformedProviderAst) {
        return transformedProviderAst;
      }
      if (this._seenProviders.get(tokenReference(token)) != null) {
        this.viewContext.errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + tokenName(token), this._sourceSpan));
        return null;
      }
      this._seenProviders.set(tokenReference(token), true);
      var transformedProviders = resolvedProvider.providers.map(function(provider) {
        var transformedUseValue = provider.useValue;
        var transformedUseExisting = ((provider.useExisting));
        var transformedDeps = ((undefined));
        if (provider.useExisting != null) {
          var existingDiDep = ((_this._getDependency(resolvedProvider.providerType, {token: provider.useExisting}, eager)));
          if (existingDiDep.token != null) {
            transformedUseExisting = existingDiDep.token;
          } else {
            transformedUseExisting = ((null));
            transformedUseValue = existingDiDep.value;
          }
        } else if (provider.useFactory) {
          var deps = provider.deps || provider.useFactory.diDeps;
          transformedDeps = deps.map(function(dep) {
            return ((_this._getDependency(resolvedProvider.providerType, dep, eager)));
          });
        } else if (provider.useClass) {
          var deps = provider.deps || provider.useClass.diDeps;
          transformedDeps = deps.map(function(dep) {
            return ((_this._getDependency(resolvedProvider.providerType, dep, eager)));
          });
        }
        return _transformProvider(provider, {
          useExisting: transformedUseExisting,
          useValue: transformedUseValue,
          deps: transformedDeps
        });
      });
      transformedProviderAst = _transformProviderAst(resolvedProvider, {
        eager: eager,
        providers: transformedProviders
      });
      this._transformedProviders.set(tokenReference(token), transformedProviderAst);
      return transformedProviderAst;
    };
    ProviderElementContext.prototype._getLocalDependency = function(requestingProviderType, dep, eager) {
      if (eager === void 0) {
        eager = false;
      }
      if (dep.isAttribute) {
        var attrValue = this._attrs[((dep.token)).value];
        return {
          isValue: true,
          value: attrValue == null ? null : attrValue
        };
      }
      if (dep.token != null) {
        if ((requestingProviderType === ProviderAstType.Directive || requestingProviderType === ProviderAstType.Component)) {
          if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.Renderer) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.ElementRef) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.ChangeDetectorRef) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.TemplateRef)) {
            return dep;
          }
          if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {
            this._hasViewContainer = true;
          }
        }
        if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.Injector)) {
          return dep;
        }
        if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {
          return dep;
        }
      }
      return null;
    };
    ProviderElementContext.prototype._getDependency = function(requestingProviderType, dep, eager) {
      if (eager === void 0) {
        eager = false;
      }
      var currElement = this;
      var currEager = eager;
      var result = null;
      if (!dep.isSkipSelf) {
        result = this._getLocalDependency(requestingProviderType, dep, eager);
      }
      if (dep.isSelf) {
        if (!result && dep.isOptional) {
          result = {
            isValue: true,
            value: null
          };
        }
      } else {
        while (!result && currElement._parent) {
          var prevElement = currElement;
          currElement = currElement._parent;
          if (prevElement._isViewRoot) {
            currEager = false;
          }
          result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);
        }
        if (!result) {
          if (!dep.isHost || this.viewContext.component.isHost || this.viewContext.component.type.reference === tokenReference(((dep.token))) || this.viewContext.viewProviders.get(tokenReference(((dep.token)))) != null) {
            result = dep;
          } else {
            result = dep.isOptional ? result = {
              isValue: true,
              value: null
            } : null;
          }
        }
      }
      if (!result) {
        this.viewContext.errors.push(new ProviderError("No provider for " + tokenName(((dep.token))), this._sourceSpan));
      }
      return result;
    };
    return ProviderElementContext;
  }());
  var NgModuleProviderAnalyzer = (function() {
    function NgModuleProviderAnalyzer(reflector, ngModule, extraProviders, sourceSpan) {
      var _this = this;
      this.reflector = reflector;
      this._transformedProviders = new Map();
      this._seenProviders = new Map();
      this._errors = [];
      this._allProviders = new Map();
      ngModule.transitiveModule.modules.forEach(function(ngModuleType) {
        var ngModuleProvider = {
          token: {identifier: ngModuleType},
          useClass: ngModuleType
        };
        _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders);
      });
      _resolveProviders(ngModule.transitiveModule.providers.map(function(entry) {
        return entry.provider;
      }).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);
    }
    NgModuleProviderAnalyzer.prototype.parse = function() {
      var _this = this;
      Array.from(this._allProviders.values()).forEach(function(provider) {
        _this._getOrCreateLocalProvider(provider.token, provider.eager);
      });
      if (this._errors.length > 0) {
        var errorString = this._errors.join('\n');
        throw new Error("Provider parse errors:\n" + errorString);
      }
      var lazyProviders = [];
      var eagerProviders = [];
      this._transformedProviders.forEach(function(provider) {
        if (provider.eager) {
          eagerProviders.push(provider);
        } else {
          lazyProviders.push(provider);
        }
      });
      return lazyProviders.concat(eagerProviders);
    };
    NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function(token, eager) {
      var _this = this;
      var resolvedProvider = this._allProviders.get(tokenReference(token));
      if (!resolvedProvider) {
        return null;
      }
      var transformedProviderAst = this._transformedProviders.get(tokenReference(token));
      if (transformedProviderAst) {
        return transformedProviderAst;
      }
      if (this._seenProviders.get(tokenReference(token)) != null) {
        this._errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + tokenName(token), resolvedProvider.sourceSpan));
        return null;
      }
      this._seenProviders.set(tokenReference(token), true);
      var transformedProviders = resolvedProvider.providers.map(function(provider) {
        var transformedUseValue = provider.useValue;
        var transformedUseExisting = ((provider.useExisting));
        var transformedDeps = ((undefined));
        if (provider.useExisting != null) {
          var existingDiDep = _this._getDependency({token: provider.useExisting}, eager, resolvedProvider.sourceSpan);
          if (existingDiDep.token != null) {
            transformedUseExisting = existingDiDep.token;
          } else {
            transformedUseExisting = ((null));
            transformedUseValue = existingDiDep.value;
          }
        } else if (provider.useFactory) {
          var deps = provider.deps || provider.useFactory.diDeps;
          transformedDeps = deps.map(function(dep) {
            return _this._getDependency(dep, eager, resolvedProvider.sourceSpan);
          });
        } else if (provider.useClass) {
          var deps = provider.deps || provider.useClass.diDeps;
          transformedDeps = deps.map(function(dep) {
            return _this._getDependency(dep, eager, resolvedProvider.sourceSpan);
          });
        }
        return _transformProvider(provider, {
          useExisting: transformedUseExisting,
          useValue: transformedUseValue,
          deps: transformedDeps
        });
      });
      transformedProviderAst = _transformProviderAst(resolvedProvider, {
        eager: eager,
        providers: transformedProviders
      });
      this._transformedProviders.set(tokenReference(token), transformedProviderAst);
      return transformedProviderAst;
    };
    NgModuleProviderAnalyzer.prototype._getDependency = function(dep, eager, requestorSourceSpan) {
      if (eager === void 0) {
        eager = false;
      }
      var foundLocal = false;
      if (!dep.isSkipSelf && dep.token != null) {
        if (tokenReference(dep.token) === this.reflector.resolveExternalReference(Identifiers.Injector) || tokenReference(dep.token) === this.reflector.resolveExternalReference(Identifiers.ComponentFactoryResolver)) {
          foundLocal = true;
        } else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {
          foundLocal = true;
        }
      }
      var result = dep;
      if (dep.isSelf && !foundLocal) {
        if (dep.isOptional) {
          result = {
            isValue: true,
            value: null
          };
        } else {
          this._errors.push(new ProviderError("No provider for " + tokenName(((dep.token))), requestorSourceSpan));
        }
      }
      return result;
    };
    return NgModuleProviderAnalyzer;
  }());
  function _transformProvider(provider, _a) {
    var useExisting = _a.useExisting,
        useValue = _a.useValue,
        deps = _a.deps;
    return {
      token: provider.token,
      useClass: provider.useClass,
      useExisting: useExisting,
      useFactory: provider.useFactory,
      useValue: useValue,
      deps: deps,
      multi: provider.multi
    };
  }
  function _transformProviderAst(provider, _a) {
    var eager = _a.eager,
        providers = _a.providers;
    return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);
  }
  function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
    var providersByToken = new Map();
    directives.forEach(function(directive) {
      var dirProvider = {
        token: {identifier: directive.type},
        useClass: directive.type
      };
      _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);
    });
    var directivesWithComponentFirst = directives.filter(function(dir) {
      return dir.isComponent;
    }).concat(directives.filter(function(dir) {
      return !dir.isComponent;
    }));
    directivesWithComponentFirst.forEach(function(directive) {
      _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);
      _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);
    });
    return providersByToken;
  }
  function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {
    providers.forEach(function(provider) {
      var resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));
      if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {
        targetErrors.push(new ProviderError("Mixing multi and non multi provider is not possible for token " + tokenName(resolvedProvider.token), sourceSpan));
      }
      if (!resolvedProvider) {
        var lifecycleHooks = provider.token.identifier && ((provider.token.identifier)).lifecycleHooks ? ((provider.token.identifier)).lifecycleHooks : [];
        var isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);
        resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan);
        targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);
      } else {
        if (!provider.multi) {
          resolvedProvider.providers.length = 0;
        }
        resolvedProvider.providers.push(provider);
      }
    });
  }
  function _getViewQueries(component) {
    var viewQueryId = 1;
    var viewQueries = new Map();
    if (component.viewQueries) {
      component.viewQueries.forEach(function(query) {
        return _addQueryToTokenMap(viewQueries, {
          meta: query,
          queryId: viewQueryId++
        });
      });
    }
    return viewQueries;
  }
  function _getContentQueries(contentQueryStartId, directives) {
    var contentQueryId = contentQueryStartId;
    var contentQueries = new Map();
    directives.forEach(function(directive, directiveIndex) {
      if (directive.queries) {
        directive.queries.forEach(function(query) {
          return _addQueryToTokenMap(contentQueries, {
            meta: query,
            queryId: contentQueryId++
          });
        });
      }
    });
    return contentQueries;
  }
  function _addQueryToTokenMap(map, query) {
    query.meta.selectors.forEach(function(token) {
      var entry = map.get(tokenReference(token));
      if (!entry) {
        entry = [];
        map.set(tokenReference(token), entry);
      }
      entry.push(query);
    });
  }
  var ElementSchemaRegistry = (function() {
    function ElementSchemaRegistry() {}
    ElementSchemaRegistry.prototype.hasProperty = function(tagName, propName, schemaMetas) {};
    ElementSchemaRegistry.prototype.hasElement = function(tagName, schemaMetas) {};
    ElementSchemaRegistry.prototype.securityContext = function(elementName, propName, isAttribute) {};
    ElementSchemaRegistry.prototype.allKnownElementNames = function() {};
    ElementSchemaRegistry.prototype.getMappedPropName = function(propName) {};
    ElementSchemaRegistry.prototype.getDefaultComponentElementName = function() {};
    ElementSchemaRegistry.prototype.validateProperty = function(name) {};
    ElementSchemaRegistry.prototype.validateAttribute = function(name) {};
    ElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function(propName) {};
    ElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function(camelCaseProp, userProvidedProp, val) {};
    return ElementSchemaRegistry;
  }());
  var StyleWithImports = (function() {
    function StyleWithImports(style$$1, styleUrls) {
      this.style = style$$1;
      this.styleUrls = styleUrls;
    }
    return StyleWithImports;
  }());
  function isStyleUrlResolvable(url) {
    if (url == null || url.length === 0 || url[0] == '/')
      return false;
    var schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);
    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
  }
  function extractStyleUrls(resolver, baseUrl, cssText) {
    var foundUrls = [];
    var modifiedCssText = cssText.replace(CSS_COMMENT_REGEXP, '').replace(CSS_IMPORT_REGEXP, function() {
      var m = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        m[_i] = arguments[_i];
      }
      var url = m[1] || m[2];
      if (!isStyleUrlResolvable(url)) {
        return m[0];
      }
      foundUrls.push(resolver.resolve(baseUrl, url));
      return '';
    });
    return new StyleWithImports(modifiedCssText, foundUrls);
  }
  var CSS_IMPORT_REGEXP = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
  var CSS_COMMENT_REGEXP = /\/\*[\s\S]+?\*\//g;
  var URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;
  var PROPERTY_PARTS_SEPARATOR = '.';
  var ATTRIBUTE_PREFIX = 'attr';
  var CLASS_PREFIX = 'class';
  var STYLE_PREFIX = 'style';
  var ANIMATE_PROP_PREFIX = 'animate-';
  var BoundPropertyType = {};
  BoundPropertyType.DEFAULT = 0;
  BoundPropertyType.LITERAL_ATTR = 1;
  BoundPropertyType.ANIMATION = 2;
  BoundPropertyType[BoundPropertyType.DEFAULT] = "DEFAULT";
  BoundPropertyType[BoundPropertyType.LITERAL_ATTR] = "LITERAL_ATTR";
  BoundPropertyType[BoundPropertyType.ANIMATION] = "ANIMATION";
  var BoundProperty = (function() {
    function BoundProperty(name, expression, type, sourceSpan) {
      this.name = name;
      this.expression = expression;
      this.type = type;
      this.sourceSpan = sourceSpan;
    }
    Object.defineProperty(BoundProperty.prototype, "isLiteral", {
      get: function() {
        return this.type === BoundPropertyType.LITERAL_ATTR;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BoundProperty.prototype, "isAnimation", {
      get: function() {
        return this.type === BoundPropertyType.ANIMATION;
      },
      enumerable: true,
      configurable: true
    });
    return BoundProperty;
  }());
  var BindingParser = (function() {
    function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, _targetErrors) {
      var _this = this;
      this._exprParser = _exprParser;
      this._interpolationConfig = _interpolationConfig;
      this._schemaRegistry = _schemaRegistry;
      this._targetErrors = _targetErrors;
      this.pipesByName = new Map();
      this._usedPipes = new Map();
      pipes.forEach(function(pipe) {
        return _this.pipesByName.set(pipe.name, pipe);
      });
    }
    BindingParser.prototype.getUsedPipes = function() {
      return Array.from(this._usedPipes.values());
    };
    BindingParser.prototype.createDirectiveHostPropertyAsts = function(dirMeta, elementSelector, sourceSpan) {
      var _this = this;
      if (dirMeta.hostProperties) {
        var boundProps_1 = [];
        Object.keys(dirMeta.hostProperties).forEach(function(propName) {
          var expression = dirMeta.hostProperties[propName];
          if (typeof expression === 'string') {
            _this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps_1);
          } else {
            _this._reportError("Value of the host property binding \"" + propName + "\" needs to be a string representing an expression but got \"" + expression + "\" (" + typeof expression + ")", sourceSpan);
          }
        });
        return boundProps_1.map(function(prop) {
          return _this.createElementPropertyAst(elementSelector, prop);
        });
      }
      return null;
    };
    BindingParser.prototype.createDirectiveHostEventAsts = function(dirMeta, sourceSpan) {
      var _this = this;
      if (dirMeta.hostListeners) {
        var targetEventAsts_1 = [];
        Object.keys(dirMeta.hostListeners).forEach(function(propName) {
          var expression = dirMeta.hostListeners[propName];
          if (typeof expression === 'string') {
            _this.parseEvent(propName, expression, sourceSpan, [], targetEventAsts_1);
          } else {
            _this._reportError("Value of the host listener \"" + propName + "\" needs to be a string representing an expression but got \"" + expression + "\" (" + typeof expression + ")", sourceSpan);
          }
        });
        return targetEventAsts_1;
      }
      return null;
    };
    BindingParser.prototype.parseInterpolation = function(value, sourceSpan) {
      var sourceInfo = sourceSpan.start.toString();
      try {
        var ast = ((this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig)));
        if (ast)
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        this._checkPipes(ast, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
      }
    };
    BindingParser.prototype.parseInlineTemplateBinding = function(prefixToken, value, sourceSpan, targetMatchableAttrs, targetProps, targetVars) {
      var bindings = this._parseTemplateBindings(prefixToken, value, sourceSpan);
      for (var i = 0; i < bindings.length; i++) {
        var binding = bindings[i];
        if (binding.keyIsVar) {
          targetVars.push(new VariableAst(binding.key, binding.name, sourceSpan));
        } else if (binding.expression) {
          this._parsePropertyAst(binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);
        } else {
          targetMatchableAttrs.push([binding.key, '']);
          this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);
        }
      }
    };
    BindingParser.prototype._parseTemplateBindings = function(prefixToken, value, sourceSpan) {
      var _this = this;
      var sourceInfo = sourceSpan.start.toString();
      try {
        var bindingsResult = this._exprParser.parseTemplateBindings(prefixToken, value, sourceInfo);
        this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);
        bindingsResult.templateBindings.forEach(function(binding) {
          if (binding.expression) {
            _this._checkPipes(binding.expression, sourceSpan);
          }
        });
        bindingsResult.warnings.forEach(function(warning) {
          _this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);
        });
        return bindingsResult.templateBindings;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return [];
      }
    };
    BindingParser.prototype.parseLiteralAttr = function(name, value, sourceSpan, targetMatchableAttrs, targetProps) {
      if (_isAnimationLabel(name)) {
        name = name.substring(1);
        if (value) {
          this._reportError("Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid." + " Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.", sourceSpan, ParseErrorLevel.ERROR);
        }
        this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);
      } else {
        targetProps.push(new BoundProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), BoundPropertyType.LITERAL_ATTR, sourceSpan));
      }
    };
    BindingParser.prototype.parsePropertyBinding = function(name, expression, isHost, sourceSpan, targetMatchableAttrs, targetProps) {
      var isAnimationProp = false;
      if (name.startsWith(ANIMATE_PROP_PREFIX)) {
        isAnimationProp = true;
        name = name.substring(ANIMATE_PROP_PREFIX.length);
      } else if (_isAnimationLabel(name)) {
        isAnimationProp = true;
        name = name.substring(1);
      }
      if (isAnimationProp) {
        this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);
      } else {
        this._parsePropertyAst(name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);
      }
    };
    BindingParser.prototype.parsePropertyInterpolation = function(name, value, sourceSpan, targetMatchableAttrs, targetProps) {
      var expr = this.parseInterpolation(value, sourceSpan);
      if (expr) {
        this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);
        return true;
      }
      return false;
    };
    BindingParser.prototype._parsePropertyAst = function(name, ast, sourceSpan, targetMatchableAttrs, targetProps) {
      targetMatchableAttrs.push([name, ((ast.source))]);
      targetProps.push(new BoundProperty(name, ast, BoundPropertyType.DEFAULT, sourceSpan));
    };
    BindingParser.prototype._parseAnimation = function(name, expression, sourceSpan, targetMatchableAttrs, targetProps) {
      var ast = this._parseBinding(expression || 'null', false, sourceSpan);
      targetMatchableAttrs.push([name, ((ast.source))]);
      targetProps.push(new BoundProperty(name, ast, BoundPropertyType.ANIMATION, sourceSpan));
    };
    BindingParser.prototype._parseBinding = function(value, isHostBinding, sourceSpan) {
      var sourceInfo = sourceSpan.start.toString();
      try {
        var ast = isHostBinding ? this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) : this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);
        if (ast)
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        this._checkPipes(ast, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
      }
    };
    BindingParser.prototype.createElementPropertyAst = function(elementSelector, boundProp) {
      if (boundProp.isAnimation) {
        return new BoundElementPropertyAst(boundProp.name, PropertyBindingType.Animation, _angular_core.SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan);
      }
      var unit = null;
      var bindingType = ((undefined));
      var boundPropertyName = null;
      var parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
      var securityContexts = ((undefined));
      if (parts.length > 1) {
        if (parts[0] == ATTRIBUTE_PREFIX) {
          boundPropertyName = parts[1];
          this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
          securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
          var nsSeparatorIdx = boundPropertyName.indexOf(':');
          if (nsSeparatorIdx > -1) {
            var ns = boundPropertyName.substring(0, nsSeparatorIdx);
            var name = boundPropertyName.substring(nsSeparatorIdx + 1);
            boundPropertyName = mergeNsAndName(ns, name);
          }
          bindingType = PropertyBindingType.Attribute;
        } else if (parts[0] == CLASS_PREFIX) {
          boundPropertyName = parts[1];
          bindingType = PropertyBindingType.Class;
          securityContexts = [_angular_core.SecurityContext.NONE];
        } else if (parts[0] == STYLE_PREFIX) {
          unit = parts.length > 2 ? parts[2] : null;
          boundPropertyName = parts[1];
          bindingType = PropertyBindingType.Style;
          securityContexts = [_angular_core.SecurityContext.STYLE];
        }
      }
      if (boundPropertyName === null) {
        boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);
        securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, false);
        bindingType = PropertyBindingType.Property;
        this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);
      }
      return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan);
    };
    BindingParser.prototype.parseEvent = function(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
      if (_isAnimationLabel(name)) {
        name = name.substr(1);
        this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);
      } else {
        this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);
      }
    };
    BindingParser.prototype._parseAnimationEvent = function(name, expression, sourceSpan, targetEvents) {
      var matches = splitAtPeriod(name, [name, '']);
      var eventName = matches[0];
      var phase = matches[1].toLowerCase();
      if (phase) {
        switch (phase) {
          case 'start':
          case 'done':
            var ast = this._parseAction(expression, sourceSpan);
            targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));
            break;
          default:
            this._reportError("The provided animation output phase value \"" + phase + "\" for \"@" + eventName + "\" is not supported (use start or done)", sourceSpan);
            break;
        }
      } else {
        this._reportError("The animation trigger output event (@" + eventName + ") is missing its phase value name (start or done are currently supported)", sourceSpan);
      }
    };
    BindingParser.prototype._parseEvent = function(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
      var _a = splitAtColon(name, [((null)), name]),
          target = _a[0],
          eventName = _a[1];
      var ast = this._parseAction(expression, sourceSpan);
      targetMatchableAttrs.push([((name)), ((ast.source))]);
      targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));
    };
    BindingParser.prototype._parseAction = function(value, sourceSpan) {
      var sourceInfo = sourceSpan.start.toString();
      try {
        var ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);
        if (ast) {
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        }
        if (!ast || ast.ast instanceof EmptyExpr) {
          this._reportError("Empty expressions are not allowed", sourceSpan);
          return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
        }
        this._checkPipes(ast, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
      }
    };
    BindingParser.prototype._reportError = function(message, sourceSpan, level) {
      if (level === void 0) {
        level = ParseErrorLevel.ERROR;
      }
      this._targetErrors.push(new ParseError(sourceSpan, message, level));
    };
    BindingParser.prototype._reportExpressionParserErrors = function(errors, sourceSpan) {
      for (var _i = 0,
          errors_1 = errors; _i < errors_1.length; _i++) {
        var error = errors_1[_i];
        this._reportError(error.message, sourceSpan);
      }
    };
    BindingParser.prototype._checkPipes = function(ast, sourceSpan) {
      var _this = this;
      if (ast) {
        var collector = new PipeCollector();
        ast.visit(collector);
        collector.pipes.forEach(function(ast, pipeName) {
          var pipeMeta = _this.pipesByName.get(pipeName);
          if (!pipeMeta) {
            _this._reportError("The pipe '" + pipeName + "' could not be found", new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));
          } else {
            _this._usedPipes.set(pipeName, pipeMeta);
          }
        });
      }
    };
    BindingParser.prototype._validatePropertyOrAttributeName = function(propName, sourceSpan, isAttr) {
      var report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);
      if (report.error) {
        this._reportError(((report.msg)), sourceSpan, ParseErrorLevel.ERROR);
      }
    };
    return BindingParser;
  }());
  var PipeCollector = (function(_super) {
    __extends(PipeCollector, _super);
    function PipeCollector() {
      var _this = _super.apply(this, arguments) || this;
      _this.pipes = new Map();
      return _this;
    }
    PipeCollector.prototype.visitPipe = function(ast, context) {
      this.pipes.set(ast.name, ast);
      ast.exp.visit(this);
      this.visitAll(ast.args, context);
      return null;
    };
    return PipeCollector;
  }(RecursiveAstVisitor));
  function _isAnimationLabel(name) {
    return name[0] == '@';
  }
  function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
    var ctxs = [];
    CssSelector.parse(selector).forEach(function(selector) {
      var elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();
      var notElementNames = new Set(selector.notSelectors.filter(function(selector) {
        return selector.isElementSelector();
      }).map(function(selector) {
        return selector.element;
      }));
      var possibleElementNames = elementNames.filter(function(elementName) {
        return !notElementNames.has(elementName);
      });
      ctxs.push.apply(ctxs, possibleElementNames.map(function(elementName) {
        return registry.securityContext(elementName, propName, isAttribute);
      }));
    });
    return ctxs.length === 0 ? [_angular_core.SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();
  }
  var NG_CONTENT_SELECT_ATTR = 'select';
  var LINK_ELEMENT = 'link';
  var LINK_STYLE_REL_ATTR = 'rel';
  var LINK_STYLE_HREF_ATTR = 'href';
  var LINK_STYLE_REL_VALUE = 'stylesheet';
  var STYLE_ELEMENT = 'style';
  var SCRIPT_ELEMENT = 'script';
  var NG_NON_BINDABLE_ATTR = 'ngNonBindable';
  var NG_PROJECT_AS = 'ngProjectAs';
  function preparseElement(ast) {
    var selectAttr = ((null));
    var hrefAttr = ((null));
    var relAttr = ((null));
    var nonBindable = false;
    var projectAs = ((null));
    ast.attrs.forEach(function(attr) {
      var lcAttrName = attr.name.toLowerCase();
      if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
        selectAttr = attr.value;
      } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
        hrefAttr = attr.value;
      } else if (lcAttrName == LINK_STYLE_REL_ATTR) {
        relAttr = attr.value;
      } else if (attr.name == NG_NON_BINDABLE_ATTR) {
        nonBindable = true;
      } else if (attr.name == NG_PROJECT_AS) {
        if (attr.value.length > 0) {
          projectAs = attr.value;
        }
      }
    });
    selectAttr = normalizeNgContentSelect(selectAttr);
    var nodeName = ast.name.toLowerCase();
    var type = PreparsedElementType.OTHER;
    if (isNgContent(nodeName)) {
      type = PreparsedElementType.NG_CONTENT;
    } else if (nodeName == STYLE_ELEMENT) {
      type = PreparsedElementType.STYLE;
    } else if (nodeName == SCRIPT_ELEMENT) {
      type = PreparsedElementType.SCRIPT;
    } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
      type = PreparsedElementType.STYLESHEET;
    }
    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
  }
  var PreparsedElementType = {};
  PreparsedElementType.NG_CONTENT = 0;
  PreparsedElementType.STYLE = 1;
  PreparsedElementType.STYLESHEET = 2;
  PreparsedElementType.SCRIPT = 3;
  PreparsedElementType.OTHER = 4;
  PreparsedElementType[PreparsedElementType.NG_CONTENT] = "NG_CONTENT";
  PreparsedElementType[PreparsedElementType.STYLE] = "STYLE";
  PreparsedElementType[PreparsedElementType.STYLESHEET] = "STYLESHEET";
  PreparsedElementType[PreparsedElementType.SCRIPT] = "SCRIPT";
  PreparsedElementType[PreparsedElementType.OTHER] = "OTHER";
  var PreparsedElement = (function() {
    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {
      this.type = type;
      this.selectAttr = selectAttr;
      this.hrefAttr = hrefAttr;
      this.nonBindable = nonBindable;
      this.projectAs = projectAs;
    }
    return PreparsedElement;
  }());
  function normalizeNgContentSelect(selectAttr) {
    if (selectAttr === null || selectAttr.length === 0) {
      return '*';
    }
    return selectAttr;
  }
  var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;
  var KW_BIND_IDX = 1;
  var KW_LET_IDX = 2;
  var KW_REF_IDX = 3;
  var KW_ON_IDX = 4;
  var KW_BINDON_IDX = 5;
  var KW_AT_IDX = 6;
  var IDENT_KW_IDX = 7;
  var IDENT_BANANA_BOX_IDX = 8;
  var IDENT_PROPERTY_IDX = 9;
  var IDENT_EVENT_IDX = 10;
  var TEMPLATE_ELEMENT = 'template';
  var TEMPLATE_ATTR = 'template';
  var TEMPLATE_ATTR_PREFIX = '*';
  var CLASS_ATTR = 'class';
  var TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];
  var TEMPLATE_ELEMENT_DEPRECATION_WARNING = 'The <template> element is deprecated. Use <ng-template> instead';
  var TEMPLATE_ATTR_DEPRECATION_WARNING = 'The template attribute is deprecated. Use an ng-template element instead.';
  var warningCounts = {};
  function warnOnlyOnce(warnings) {
    return function(error) {
      if (warnings.indexOf(error.msg) !== -1) {
        warningCounts[error.msg] = (warningCounts[error.msg] || 0) + 1;
        return warningCounts[error.msg] <= 1;
      }
      return true;
    };
  }
  var TEMPLATE_TRANSFORMS = new _angular_core.InjectionToken('TemplateTransforms');
  var TemplateParseError = (function(_super) {
    __extends(TemplateParseError, _super);
    function TemplateParseError(message, span, level) {
      return _super.call(this, span, message, level) || this;
    }
    return TemplateParseError;
  }(ParseError));
  var TemplateParseResult = (function() {
    function TemplateParseResult(templateAst, usedPipes, errors) {
      this.templateAst = templateAst;
      this.usedPipes = usedPipes;
      this.errors = errors;
    }
    return TemplateParseResult;
  }());
  var TemplateParser = (function() {
    function TemplateParser(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
      this._config = _config;
      this._reflector = _reflector;
      this._exprParser = _exprParser;
      this._schemaRegistry = _schemaRegistry;
      this._htmlParser = _htmlParser;
      this._console = _console;
      this.transforms = transforms;
    }
    TemplateParser.prototype.parse = function(component, template, directives, pipes, schemas, templateUrl) {
      var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl);
      var warnings = ((result.errors)).filter(function(error) {
        return error.level === ParseErrorLevel.WARNING;
      }).filter(warnOnlyOnce([TEMPLATE_ATTR_DEPRECATION_WARNING, TEMPLATE_ELEMENT_DEPRECATION_WARNING]));
      var errors = ((result.errors)).filter(function(error) {
        return error.level === ParseErrorLevel.ERROR;
      });
      if (warnings.length > 0) {
        this._console.warn("Template parse warnings:\n" + warnings.join('\n'));
      }
      if (errors.length > 0) {
        var errorString = errors.join('\n');
        throw syntaxError("Template parse errors:\n" + errorString, errors);
      }
      return {
        template: ((result.templateAst)),
        pipes: ((result.usedPipes))
      };
    };
    TemplateParser.prototype.tryParse = function(component, template, directives, pipes, schemas, templateUrl) {
      return this.tryParseHtml(this.expandHtml(((this._htmlParser)).parse(template, templateUrl, true, this.getInterpolationConfig(component))), component, directives, pipes, schemas);
    };
    TemplateParser.prototype.tryParseHtml = function(htmlAstWithErrors, component, directives, pipes, schemas) {
      var result;
      var errors = htmlAstWithErrors.errors;
      var usedPipes = [];
      if (htmlAstWithErrors.rootNodes.length > 0) {
        var uniqDirectives = removeSummaryDuplicates(directives);
        var uniqPipes = removeSummaryDuplicates(pipes);
        var providerViewContext = new ProviderViewContext(this._reflector, component);
        var interpolationConfig = ((undefined));
        if (component.template && component.template.interpolation) {
          interpolationConfig = {
            start: component.template.interpolation[0],
            end: component.template.interpolation[1]
          };
        }
        var bindingParser = new BindingParser(this._exprParser, ((interpolationConfig)), this._schemaRegistry, uniqPipes, errors);
        var parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);
        result = visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
        errors.push.apply(errors, providerViewContext.errors);
        usedPipes.push.apply(usedPipes, bindingParser.getUsedPipes());
      } else {
        result = [];
      }
      this._assertNoReferenceDuplicationOnTemplate(result, errors);
      if (errors.length > 0) {
        return new TemplateParseResult(result, usedPipes, errors);
      }
      if (this.transforms) {
        this.transforms.forEach(function(transform) {
          result = templateVisitAll(transform, result);
        });
      }
      return new TemplateParseResult(result, usedPipes, errors);
    };
    TemplateParser.prototype.expandHtml = function(htmlAstWithErrors, forced) {
      if (forced === void 0) {
        forced = false;
      }
      var errors = htmlAstWithErrors.errors;
      if (errors.length == 0 || forced) {
        var expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);
        errors.push.apply(errors, expandedHtmlAst.errors);
        htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);
      }
      return htmlAstWithErrors;
    };
    TemplateParser.prototype.getInterpolationConfig = function(component) {
      if (component.template) {
        return InterpolationConfig.fromArray(component.template.interpolation);
      }
      return undefined;
    };
    TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function(result, errors) {
      var existingReferences = [];
      result.filter(function(element) {
        return !!((element)).references;
      }).forEach(function(element) {
        return ((element)).references.forEach(function(reference) {
          var name = reference.name;
          if (existingReferences.indexOf(name) < 0) {
            existingReferences.push(name);
          } else {
            var error = new TemplateParseError("Reference \"#" + name + "\" is defined several times", reference.sourceSpan, ParseErrorLevel.ERROR);
            errors.push(error);
          }
        });
      });
    };
    return TemplateParser;
  }());
  TemplateParser.decorators = [{type: CompilerInjectable}];
  TemplateParser.ctorParameters = function() {
    return [{type: CompilerConfig}, {type: CompileReflector}, {type: Parser}, {type: ElementSchemaRegistry}, {type: I18NHtmlParser}, {type: _angular_core.ɵConsole}, {
      type: Array,
      decorators: [{type: _angular_core.Optional}, {
        type: _angular_core.Inject,
        args: [TEMPLATE_TRANSFORMS]
      }]
    }];
  };
  var TemplateParseVisitor = (function() {
    function TemplateParseVisitor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {
      var _this = this;
      this.reflector = reflector;
      this.config = config;
      this.providerViewContext = providerViewContext;
      this._bindingParser = _bindingParser;
      this._schemaRegistry = _schemaRegistry;
      this._schemas = _schemas;
      this._targetErrors = _targetErrors;
      this.selectorMatcher = new SelectorMatcher();
      this.directivesIndex = new Map();
      this.ngContentCount = 0;
      this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;
      directives.forEach(function(directive, index) {
        var selector = CssSelector.parse(directive.selector);
        _this.selectorMatcher.addSelectables(selector, directive);
        _this.directivesIndex.set(directive, index);
      });
    }
    TemplateParseVisitor.prototype.visitExpansion = function(expansion, context) {
      return null;
    };
    TemplateParseVisitor.prototype.visitExpansionCase = function(expansionCase, context) {
      return null;
    };
    TemplateParseVisitor.prototype.visitText = function(text, parent) {
      var ngContentIndex = ((parent.findNgContentIndex(TEXT_CSS_SELECTOR)));
      var expr = this._bindingParser.parseInterpolation(text.value, ((text.sourceSpan)));
      return expr ? new BoundTextAst(expr, ngContentIndex, ((text.sourceSpan))) : new TextAst(text.value, ngContentIndex, ((text.sourceSpan)));
    };
    TemplateParseVisitor.prototype.visitAttribute = function(attribute, context) {
      return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
    };
    TemplateParseVisitor.prototype.visitComment = function(comment, context) {
      return null;
    };
    TemplateParseVisitor.prototype.visitElement = function(element, parent) {
      var _this = this;
      var queryStartIndex = this.contentQueryStartId;
      var nodeName = element.name;
      var preparsedElement = preparseElement(element);
      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE) {
        return null;
      }
      if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {
        return null;
      }
      var matchableAttrs = [];
      var elementOrDirectiveProps = [];
      var elementOrDirectiveRefs = [];
      var elementVars = [];
      var events = [];
      var templateElementOrDirectiveProps = [];
      var templateMatchableAttrs = [];
      var templateElementVars = [];
      var hasInlineTemplates = false;
      var attrs = [];
      var isTemplateElement = isTemplate(element, this.config.enableLegacyTemplate, function(m, span) {
        return _this._reportError(m, span, ParseErrorLevel.WARNING);
      });
      element.attrs.forEach(function(attr) {
        var hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);
        var templateBindingsSource;
        var prefixToken;
        var normalizedName = _this._normalizeAttributeName(attr.name);
        if (_this.config.enableLegacyTemplate && normalizedName == TEMPLATE_ATTR) {
          _this._reportError(TEMPLATE_ATTR_DEPRECATION_WARNING, attr.sourceSpan, ParseErrorLevel.WARNING);
          templateBindingsSource = attr.value;
        } else if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {
          templateBindingsSource = attr.value;
          prefixToken = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length) + ':';
        }
        var hasTemplateBinding = templateBindingsSource != null;
        if (hasTemplateBinding) {
          if (hasInlineTemplates) {
            _this._reportError("Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *", attr.sourceSpan);
          }
          hasInlineTemplates = true;
          _this._bindingParser.parseInlineTemplateBinding(((prefixToken)), ((templateBindingsSource)), attr.sourceSpan, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);
        }
        if (!hasBinding && !hasTemplateBinding) {
          attrs.push(_this.visitAttribute(attr, null));
          matchableAttrs.push([attr.name, attr.value]);
        }
      });
      var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);
      var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector),
          directiveMetas = _a.directives,
          matchElement = _a.matchElement;
      var references = [];
      var boundDirectivePropNames = new Set();
      var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, ((element.sourceSpan)), references, boundDirectivePropNames);
      var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);
      var isViewRoot = parent.isTemplateElement || hasInlineTemplates;
      var providerContext = new ProviderElementContext(this.providerViewContext, ((parent.providerContext)), isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, ((element.sourceSpan)));
      var children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? ((parent.providerContext)) : providerContext));
      providerContext.afterElement();
      var projectionSelector = preparsedElement.projectAs != null ? CssSelector.parse(preparsedElement.projectAs)[0] : elementCssSelector;
      var ngContentIndex = ((parent.findNgContentIndex(projectionSelector)));
      var parsedElement;
      if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
        if (element.children && !element.children.every(_isEmptyTextNode)) {
          this._reportError("<ng-content> element cannot have content.", ((element.sourceSpan)));
        }
        parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? ((null)) : ngContentIndex, ((element.sourceSpan)));
      } else if (isTemplateElement) {
        this._assertAllEventsPublishedByDirectives(directiveAsts, events);
        this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, ((element.sourceSpan)));
        parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? ((null)) : ngContentIndex, ((element.sourceSpan)));
      } else {
        this._assertElementExists(matchElement, element);
        this._assertOnlyOneComponent(directiveAsts, ((element.sourceSpan)));
        var ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);
        parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan || null);
      }
      if (hasInlineTemplates) {
        var templateQueryStartIndex = this.contentQueryStartId;
        var templateSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);
        var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateSelector).directives;
        var templateBoundDirectivePropNames = new Set();
        var templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], ((element.sourceSpan)), [], templateBoundDirectivePropNames);
        var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateBoundDirectivePropNames);
        this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, ((element.sourceSpan)));
        var templateProviderContext = new ProviderElementContext(this.providerViewContext, ((parent.providerContext)), parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, ((element.sourceSpan)));
        templateProviderContext.afterElement();
        parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, ((element.sourceSpan)));
      }
      return parsedElement;
    };
    TemplateParseVisitor.prototype._parseAttr = function(isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {
      var name = this._normalizeAttributeName(attr.name);
      var value = attr.value;
      var srcSpan = attr.sourceSpan;
      var bindParts = name.match(BIND_NAME_REGEXP);
      var hasBinding = false;
      if (bindParts !== null) {
        hasBinding = true;
        if (bindParts[KW_BIND_IDX] != null) {
          this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
        } else if (bindParts[KW_LET_IDX]) {
          if (isTemplateElement) {
            var identifier = bindParts[IDENT_KW_IDX];
            this._parseVariable(identifier, value, srcSpan, targetVars);
          } else {
            this._reportError("\"let-\" is only supported on template elements.", srcSpan);
          }
        } else if (bindParts[KW_REF_IDX]) {
          var identifier = bindParts[IDENT_KW_IDX];
          this._parseReference(identifier, value, srcSpan, targetRefs);
        } else if (bindParts[KW_ON_IDX]) {
          this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
        } else if (bindParts[KW_BINDON_IDX]) {
          this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
          this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
        } else if (bindParts[KW_AT_IDX]) {
          this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);
        } else if (bindParts[IDENT_BANANA_BOX_IDX]) {
          this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
          this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
        } else if (bindParts[IDENT_PROPERTY_IDX]) {
          this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);
        } else if (bindParts[IDENT_EVENT_IDX]) {
          this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
        }
      } else {
        hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);
      }
      if (!hasBinding) {
        this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);
      }
      return hasBinding;
    };
    TemplateParseVisitor.prototype._normalizeAttributeName = function(attrName) {
      return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
    };
    TemplateParseVisitor.prototype._parseVariable = function(identifier, value, sourceSpan, targetVars) {
      if (identifier.indexOf('-') > -1) {
        this._reportError("\"-\" is not allowed in variable names", sourceSpan);
      }
      targetVars.push(new VariableAst(identifier, value, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseReference = function(identifier, value, sourceSpan, targetRefs) {
      if (identifier.indexOf('-') > -1) {
        this._reportError("\"-\" is not allowed in reference names", sourceSpan);
      }
      targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseAssignmentEvent = function(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
      this._bindingParser.parseEvent(name + "Change", expression + "=$event", sourceSpan, targetMatchableAttrs, targetEvents);
    };
    TemplateParseVisitor.prototype._parseDirectives = function(selectorMatcher, elementCssSelector) {
      var _this = this;
      var directives = new Array(this.directivesIndex.size);
      var matchElement = false;
      selectorMatcher.match(elementCssSelector, function(selector, directive) {
        directives[((_this.directivesIndex.get(directive)))] = directive;
        matchElement = matchElement || selector.hasElementSelector();
      });
      return {
        directives: directives.filter(function(dir) {
          return !!dir;
        }),
        matchElement: matchElement
      };
    };
    TemplateParseVisitor.prototype._createDirectiveAsts = function(isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {
      var _this = this;
      var matchedReferences = new Set();
      var component = ((null));
      var directiveAsts = directives.map(function(directive) {
        var sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, "Directive " + identifierName(directive.type));
        if (directive.isComponent) {
          component = directive;
        }
        var directiveProperties = [];
        var hostProperties = ((_this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan)));
        hostProperties = _this._checkPropertiesInSchema(elementName, hostProperties);
        var hostEvents = ((_this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan)));
        _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);
        elementOrDirectiveRefs.forEach(function(elOrDirRef) {
          if ((elOrDirRef.value.length === 0 && directive.isComponent) || (directive.exportAs == elOrDirRef.value)) {
            targetReferences.push(new ReferenceAst(elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.sourceSpan));
            matchedReferences.add(elOrDirRef.name);
          }
        });
        var contentQueryStartId = _this.contentQueryStartId;
        _this.contentQueryStartId += directive.queries.length;
        return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);
      });
      elementOrDirectiveRefs.forEach(function(elOrDirRef) {
        if (elOrDirRef.value.length > 0) {
          if (!matchedReferences.has(elOrDirRef.name)) {
            _this._reportError("There is no directive with \"exportAs\" set to \"" + elOrDirRef.value + "\"", elOrDirRef.sourceSpan);
          }
        } else if (!component) {
          var refToken = ((null));
          if (isTemplateElement) {
            refToken = createTokenForExternalReference(_this.reflector, Identifiers.TemplateRef);
          }
          targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));
        }
      });
      return directiveAsts;
    };
    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function(directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {
      if (directiveProperties) {
        var boundPropsByName_1 = new Map();
        boundProps.forEach(function(boundProp) {
          var prevValue = boundPropsByName_1.get(boundProp.name);
          if (!prevValue || prevValue.isLiteral) {
            boundPropsByName_1.set(boundProp.name, boundProp);
          }
        });
        Object.keys(directiveProperties).forEach(function(dirProp) {
          var elProp = directiveProperties[dirProp];
          var boundProp = boundPropsByName_1.get(elProp);
          if (boundProp) {
            targetBoundDirectivePropNames.add(boundProp.name);
            if (!isEmptyExpression(boundProp.expression)) {
              targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
            }
          }
        });
      }
    };
    TemplateParseVisitor.prototype._createElementPropertyAsts = function(elementName, props, boundDirectivePropNames) {
      var _this = this;
      var boundElementProps = [];
      props.forEach(function(prop) {
        if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {
          boundElementProps.push(_this._bindingParser.createElementPropertyAst(elementName, prop));
        }
      });
      return this._checkPropertiesInSchema(elementName, boundElementProps);
    };
    TemplateParseVisitor.prototype._findComponentDirectives = function(directives) {
      return directives.filter(function(directive) {
        return directive.directive.isComponent;
      });
    };
    TemplateParseVisitor.prototype._findComponentDirectiveNames = function(directives) {
      return this._findComponentDirectives(directives).map(function(directive) {
        return ((identifierName(directive.directive.type)));
      });
    };
    TemplateParseVisitor.prototype._assertOnlyOneComponent = function(directives, sourceSpan) {
      var componentTypeNames = this._findComponentDirectiveNames(directives);
      if (componentTypeNames.length > 1) {
        this._reportError("More than one component matched on this element.\n" + "Make sure that only one component's selector can match a given element.\n" + ("Conflicting components: " + componentTypeNames.join(',')), sourceSpan);
      }
    };
    TemplateParseVisitor.prototype._assertElementExists = function(matchElement, element) {
      var elName = element.name.replace(/^:xhtml:/, '');
      if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {
        var errorMsg = "'" + elName + "' is not a known element:\n";
        errorMsg += "1. If '" + elName + "' is an Angular component, then verify that it is part of this module.\n";
        if (elName.indexOf('-') > -1) {
          errorMsg += "2. If '" + elName + "' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.";
        } else {
          errorMsg += "2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.";
        }
        this._reportError(errorMsg, ((element.sourceSpan)));
      }
    };
    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function(directives, elementProps, sourceSpan) {
      var _this = this;
      var componentTypeNames = this._findComponentDirectiveNames(directives);
      if (componentTypeNames.length > 0) {
        this._reportError("Components on an embedded template: " + componentTypeNames.join(','), sourceSpan);
      }
      elementProps.forEach(function(prop) {
        _this._reportError("Property binding " + prop.name + " not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".", sourceSpan);
      });
    };
    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function(directives, events) {
      var _this = this;
      var allDirectiveEvents = new Set();
      directives.forEach(function(directive) {
        Object.keys(directive.directive.outputs).forEach(function(k) {
          var eventName = directive.directive.outputs[k];
          allDirectiveEvents.add(eventName);
        });
      });
      events.forEach(function(event) {
        if (event.target != null || !allDirectiveEvents.has(event.name)) {
          _this._reportError("Event binding " + event.fullName + " not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".", event.sourceSpan);
        }
      });
    };
    TemplateParseVisitor.prototype._checkPropertiesInSchema = function(elementName, boundProps) {
      var _this = this;
      return boundProps.filter(function(boundProp) {
        if (boundProp.type === PropertyBindingType.Property && !_this._schemaRegistry.hasProperty(elementName, boundProp.name, _this._schemas)) {
          var errorMsg = "Can't bind to '" + boundProp.name + "' since it isn't a known property of '" + elementName + "'.";
          if (elementName.startsWith('ng-')) {
            errorMsg += "\n1. If '" + boundProp.name + "' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component." + "\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.";
          } else if (elementName.indexOf('-') > -1) {
            errorMsg += "\n1. If '" + elementName + "' is an Angular component and it has '" + boundProp.name + "' input, then verify that it is part of this module." + ("\n2. If '" + elementName + "' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.") + "\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.";
          }
          _this._reportError(errorMsg, boundProp.sourceSpan);
        }
        return !isEmptyExpression(boundProp.value);
      });
    };
    TemplateParseVisitor.prototype._reportError = function(message, sourceSpan, level) {
      if (level === void 0) {
        level = ParseErrorLevel.ERROR;
      }
      this._targetErrors.push(new ParseError(sourceSpan, message, level));
    };
    return TemplateParseVisitor;
  }());
  var NonBindableVisitor = (function() {
    function NonBindableVisitor() {}
    NonBindableVisitor.prototype.visitElement = function(ast, parent) {
      var preparsedElement = preparseElement(ast);
      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {
        return null;
      }
      var attrNameAndValues = ast.attrs.map(function(attr) {
        return [attr.name, attr.value];
      });
      var selector = createElementCssSelector(ast.name, attrNameAndValues);
      var ngContentIndex = parent.findNgContentIndex(selector);
      var children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);
      return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);
    };
    NonBindableVisitor.prototype.visitComment = function(comment, context) {
      return null;
    };
    NonBindableVisitor.prototype.visitAttribute = function(attribute, context) {
      return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
    };
    NonBindableVisitor.prototype.visitText = function(text, parent) {
      var ngContentIndex = ((parent.findNgContentIndex(TEXT_CSS_SELECTOR)));
      return new TextAst(text.value, ngContentIndex, ((text.sourceSpan)));
    };
    NonBindableVisitor.prototype.visitExpansion = function(expansion, context) {
      return expansion;
    };
    NonBindableVisitor.prototype.visitExpansionCase = function(expansionCase, context) {
      return expansionCase;
    };
    return NonBindableVisitor;
  }());
  var ElementOrDirectiveRef = (function() {
    function ElementOrDirectiveRef(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    return ElementOrDirectiveRef;
  }());
  function splitClasses(classAttrValue) {
    return classAttrValue.trim().split(/\s+/g);
  }
  var ElementContext = (function() {
    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
      this.isTemplateElement = isTemplateElement;
      this._ngContentIndexMatcher = _ngContentIndexMatcher;
      this._wildcardNgContentIndex = _wildcardNgContentIndex;
      this.providerContext = providerContext;
    }
    ElementContext.create = function(isTemplateElement, directives, providerContext) {
      var matcher = new SelectorMatcher();
      var wildcardNgContentIndex = ((null));
      var component = directives.find(function(directive) {
        return directive.directive.isComponent;
      });
      if (component) {
        var ngContentSelectors = ((component.directive.template)).ngContentSelectors;
        for (var i = 0; i < ngContentSelectors.length; i++) {
          var selector = ngContentSelectors[i];
          if (selector === '*') {
            wildcardNgContentIndex = i;
          } else {
            matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);
          }
        }
      }
      return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
    };
    ElementContext.prototype.findNgContentIndex = function(selector) {
      var ngContentIndices = [];
      this._ngContentIndexMatcher.match(selector, function(selector, ngContentIndex) {
        ngContentIndices.push(ngContentIndex);
      });
      ngContentIndices.sort();
      if (this._wildcardNgContentIndex != null) {
        ngContentIndices.push(this._wildcardNgContentIndex);
      }
      return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
    };
    return ElementContext;
  }());
  function createElementCssSelector(elementName, attributes) {
    var cssSelector = new CssSelector();
    var elNameNoNs = splitNsName(elementName)[1];
    cssSelector.setElement(elNameNoNs);
    for (var i = 0; i < attributes.length; i++) {
      var attrName = attributes[i][0];
      var attrNameNoNs = splitNsName(attrName)[1];
      var attrValue = attributes[i][1];
      cssSelector.addAttribute(attrNameNoNs, attrValue);
      if (attrName.toLowerCase() == CLASS_ATTR) {
        var classes = splitClasses(attrValue);
        classes.forEach(function(className) {
          return cssSelector.addClassName(className);
        });
      }
    }
    return cssSelector;
  }
  var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);
  var NON_BINDABLE_VISITOR = new NonBindableVisitor();
  function _isEmptyTextNode(node) {
    return node instanceof Text && node.value.trim().length == 0;
  }
  function removeSummaryDuplicates(items) {
    var map = new Map();
    items.forEach(function(item) {
      if (!map.get(item.type.reference)) {
        map.set(item.type.reference, item);
      }
    });
    return Array.from(map.values());
  }
  function isEmptyExpression(ast) {
    if (ast instanceof ASTWithSource) {
      ast = ast.ast;
    }
    return ast instanceof EmptyExpr;
  }
  function isTemplate(el, enableLegacyTemplate, reportDeprecation) {
    if (isNgTemplate(el.name))
      return true;
    var tagNoNs = splitNsName(el.name)[1];
    if (tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {
      if (enableLegacyTemplate && tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {
        reportDeprecation(TEMPLATE_ELEMENT_DEPRECATION_WARNING, ((el.sourceSpan)));
        return true;
      }
    }
    return false;
  }
  var ResourceLoader = (function() {
    function ResourceLoader() {}
    ResourceLoader.prototype.get = function(url) {
      return '';
    };
    return ResourceLoader;
  }());
  function createUrlResolverWithoutPackagePrefix() {
    return new UrlResolver();
  }
  function createOfflineCompileUrlResolver() {
    return new UrlResolver('.');
  }
  var DEFAULT_PACKAGE_URL_PROVIDER = {
    provide: _angular_core.PACKAGE_ROOT_URL,
    useValue: '/'
  };
  var UrlResolver = (function() {
    function UrlResolver(_packagePrefix) {
      if (_packagePrefix === void 0) {
        _packagePrefix = null;
      }
      this._packagePrefix = _packagePrefix;
    }
    UrlResolver.prototype.resolve = function(baseUrl, url) {
      var resolvedUrl = url;
      if (baseUrl != null && baseUrl.length > 0) {
        resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);
      }
      var resolvedParts = _split(resolvedUrl);
      var prefix = this._packagePrefix;
      if (prefix != null && resolvedParts != null && resolvedParts[_ComponentIndex.Scheme] == 'package') {
        var path = resolvedParts[_ComponentIndex.Path];
        prefix = prefix.replace(/\/+$/, '');
        path = path.replace(/^\/+/, '');
        return prefix + "/" + path;
      }
      return resolvedUrl;
    };
    return UrlResolver;
  }());
  UrlResolver.decorators = [{type: CompilerInjectable}];
  UrlResolver.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [_angular_core.PACKAGE_ROOT_URL]
      }]
    }];
  };
  function getUrlScheme(url) {
    var match = _split(url);
    return (match && match[_ComponentIndex.Scheme]) || '';
  }
  function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (opt_scheme != null) {
      out.push(opt_scheme + ':');
    }
    if (opt_domain != null) {
      out.push('//');
      if (opt_userInfo != null) {
        out.push(opt_userInfo + '@');
      }
      out.push(opt_domain);
      if (opt_port != null) {
        out.push(':' + opt_port);
      }
    }
    if (opt_path != null) {
      out.push(opt_path);
    }
    if (opt_queryData != null) {
      out.push('?' + opt_queryData);
    }
    if (opt_fragment != null) {
      out.push('#' + opt_fragment);
    }
    return out.join('');
  }
  var _splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
  var _ComponentIndex = {};
  _ComponentIndex.Scheme = 1;
  _ComponentIndex.UserInfo = 2;
  _ComponentIndex.Domain = 3;
  _ComponentIndex.Port = 4;
  _ComponentIndex.Path = 5;
  _ComponentIndex.QueryData = 6;
  _ComponentIndex.Fragment = 7;
  _ComponentIndex[_ComponentIndex.Scheme] = "Scheme";
  _ComponentIndex[_ComponentIndex.UserInfo] = "UserInfo";
  _ComponentIndex[_ComponentIndex.Domain] = "Domain";
  _ComponentIndex[_ComponentIndex.Port] = "Port";
  _ComponentIndex[_ComponentIndex.Path] = "Path";
  _ComponentIndex[_ComponentIndex.QueryData] = "QueryData";
  _ComponentIndex[_ComponentIndex.Fragment] = "Fragment";
  function _split(uri) {
    return ((uri.match(_splitRe)));
  }
  function _removeDotSegments(path) {
    if (path == '/')
      return '/';
    var leadingSlash = path[0] == '/' ? '/' : '';
    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length > 0) {
            out.pop();
          } else {
            up++;
          }
          break;
        default:
          out.push(segment);
      }
    }
    if (leadingSlash == '') {
      while (up-- > 0) {
        out.unshift('..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function _joinAndCanonicalizePath(parts) {
    var path = parts[_ComponentIndex.Path];
    path = path == null ? '' : _removeDotSegments(path);
    parts[_ComponentIndex.Path] = path;
    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
  }
  function _resolveUrl(base, url) {
    var parts = _split(encodeURI(url));
    var baseParts = _split(base);
    if (parts[_ComponentIndex.Scheme] != null) {
      return _joinAndCanonicalizePath(parts);
    } else {
      parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
    }
    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
      if (parts[i] == null) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[_ComponentIndex.Path][0] == '/') {
      return _joinAndCanonicalizePath(parts);
    }
    var path = baseParts[_ComponentIndex.Path];
    if (path == null)
      path = '/';
    var index = path.lastIndexOf('/');
    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
    parts[_ComponentIndex.Path] = path;
    return _joinAndCanonicalizePath(parts);
  }
  var DirectiveNormalizer = (function() {
    function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {
      this._resourceLoader = _resourceLoader;
      this._urlResolver = _urlResolver;
      this._htmlParser = _htmlParser;
      this._config = _config;
      this._resourceLoaderCache = new Map();
    }
    DirectiveNormalizer.prototype.clearCache = function() {
      this._resourceLoaderCache.clear();
    };
    DirectiveNormalizer.prototype.clearCacheFor = function(normalizedDirective) {
      var _this = this;
      if (!normalizedDirective.isComponent) {
        return;
      }
      var template = ((normalizedDirective.template));
      this._resourceLoaderCache.delete(((template.templateUrl)));
      template.externalStylesheets.forEach(function(stylesheet) {
        _this._resourceLoaderCache.delete(((stylesheet.moduleUrl)));
      });
    };
    DirectiveNormalizer.prototype._fetch = function(url) {
      var result = this._resourceLoaderCache.get(url);
      if (!result) {
        result = this._resourceLoader.get(url);
        this._resourceLoaderCache.set(url, result);
      }
      return result;
    };
    DirectiveNormalizer.prototype.normalizeTemplate = function(prenormData) {
      var _this = this;
      if (isDefined(prenormData.template)) {
        if (isDefined(prenormData.templateUrl)) {
          throw syntaxError("'" + _angular_core.ɵstringify(prenormData.componentType) + "' component cannot define both template and templateUrl");
        }
        if (typeof prenormData.template !== 'string') {
          throw syntaxError("The template specified for component " + _angular_core.ɵstringify(prenormData.componentType) + " is not a string");
        }
      } else if (isDefined(prenormData.templateUrl)) {
        if (typeof prenormData.templateUrl !== 'string') {
          throw syntaxError("The templateUrl specified for component " + _angular_core.ɵstringify(prenormData.componentType) + " is not a string");
        }
      } else {
        throw syntaxError("No template specified for component " + _angular_core.ɵstringify(prenormData.componentType));
      }
      return SyncAsync.then(this.normalizeTemplateOnly(prenormData), function(result) {
        return _this.normalizeExternalStylesheets(result);
      });
    };
    DirectiveNormalizer.prototype.normalizeTemplateOnly = function(prenomData) {
      var _this = this;
      var template;
      var templateUrl;
      if (prenomData.template != null) {
        template = prenomData.template;
        templateUrl = prenomData.moduleUrl;
      } else {
        templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, ((prenomData.templateUrl)));
        template = this._fetch(templateUrl);
      }
      return SyncAsync.then(template, function(template) {
        return _this.normalizeLoadedTemplate(prenomData, template, templateUrl);
      });
    };
    DirectiveNormalizer.prototype.normalizeLoadedTemplate = function(prenormData, template, templateAbsUrl) {
      var isInline = !!prenormData.template;
      var interpolationConfig = InterpolationConfig.fromArray(((prenormData.interpolation)));
      var rootNodesAndErrors = this._htmlParser.parse(template, templateSourceUrl({reference: prenormData.ngModuleType}, {type: {reference: prenormData.componentType}}, {
        isInline: isInline,
        templateUrl: templateAbsUrl
      }), true, interpolationConfig);
      if (rootNodesAndErrors.errors.length > 0) {
        var errorString = rootNodesAndErrors.errors.join('\n');
        throw syntaxError("Template parse errors:\n" + errorString);
      }
      var templateMetadataStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({
        styles: prenormData.styles,
        styleUrls: prenormData.styleUrls,
        moduleUrl: prenormData.moduleUrl
      }));
      var visitor = new TemplatePreparseVisitor();
      visitAll(visitor, rootNodesAndErrors.rootNodes);
      var templateStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({
        styles: visitor.styles,
        styleUrls: visitor.styleUrls,
        moduleUrl: templateAbsUrl
      }));
      var encapsulation = prenormData.encapsulation;
      if (encapsulation == null) {
        encapsulation = this._config.defaultEncapsulation;
      }
      var styles = templateMetadataStyles.styles.concat(templateStyles.styles);
      var styleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);
      if (encapsulation === _angular_core.ViewEncapsulation.Emulated && styles.length === 0 && styleUrls.length === 0) {
        encapsulation = _angular_core.ViewEncapsulation.None;
      }
      return new CompileTemplateMetadata({
        encapsulation: encapsulation,
        template: template,
        templateUrl: templateAbsUrl,
        styles: styles,
        styleUrls: styleUrls,
        ngContentSelectors: visitor.ngContentSelectors,
        animations: prenormData.animations,
        interpolation: prenormData.interpolation,
        isInline: isInline,
        externalStylesheets: []
      });
    };
    DirectiveNormalizer.prototype.normalizeExternalStylesheets = function(templateMeta) {
      return SyncAsync.then(this._loadMissingExternalStylesheets(templateMeta.styleUrls), function(externalStylesheets) {
        return new CompileTemplateMetadata({
          encapsulation: templateMeta.encapsulation,
          template: templateMeta.template,
          templateUrl: templateMeta.templateUrl,
          styles: templateMeta.styles,
          styleUrls: templateMeta.styleUrls,
          externalStylesheets: externalStylesheets,
          ngContentSelectors: templateMeta.ngContentSelectors,
          animations: templateMeta.animations,
          interpolation: templateMeta.interpolation,
          isInline: templateMeta.isInline
        });
      });
    };
    DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function(styleUrls, loadedStylesheets) {
      var _this = this;
      if (loadedStylesheets === void 0) {
        loadedStylesheets = new Map();
      }
      return SyncAsync.then(SyncAsync.all(styleUrls.filter(function(styleUrl) {
        return !loadedStylesheets.has(styleUrl);
      }).map(function(styleUrl) {
        return SyncAsync.then(_this._fetch(styleUrl), function(loadedStyle) {
          var stylesheet = _this.normalizeStylesheet(new CompileStylesheetMetadata({
            styles: [loadedStyle],
            moduleUrl: styleUrl
          }));
          loadedStylesheets.set(styleUrl, stylesheet);
          return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);
        });
      })), function(_) {
        return Array.from(loadedStylesheets.values());
      });
    };
    DirectiveNormalizer.prototype.normalizeStylesheet = function(stylesheet) {
      var _this = this;
      var moduleUrl = ((stylesheet.moduleUrl));
      var allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable).map(function(url) {
        return _this._urlResolver.resolve(moduleUrl, url);
      });
      var allStyles = stylesheet.styles.map(function(style$$1) {
        var styleWithImports = extractStyleUrls(_this._urlResolver, moduleUrl, style$$1);
        allStyleUrls.push.apply(allStyleUrls, styleWithImports.styleUrls);
        return styleWithImports.style;
      });
      return new CompileStylesheetMetadata({
        styles: allStyles,
        styleUrls: allStyleUrls,
        moduleUrl: moduleUrl
      });
    };
    return DirectiveNormalizer;
  }());
  DirectiveNormalizer.decorators = [{type: CompilerInjectable}];
  DirectiveNormalizer.ctorParameters = function() {
    return [{type: ResourceLoader}, {type: UrlResolver}, {type: HtmlParser}, {type: CompilerConfig}];
  };
  var TemplatePreparseVisitor = (function() {
    function TemplatePreparseVisitor() {
      this.ngContentSelectors = [];
      this.styles = [];
      this.styleUrls = [];
      this.ngNonBindableStackCount = 0;
    }
    TemplatePreparseVisitor.prototype.visitElement = function(ast, context) {
      var preparsedElement = preparseElement(ast);
      switch (preparsedElement.type) {
        case PreparsedElementType.NG_CONTENT:
          if (this.ngNonBindableStackCount === 0) {
            this.ngContentSelectors.push(preparsedElement.selectAttr);
          }
          break;
        case PreparsedElementType.STYLE:
          var textContent_1 = '';
          ast.children.forEach(function(child) {
            if (child instanceof Text) {
              textContent_1 += child.value;
            }
          });
          this.styles.push(textContent_1);
          break;
        case PreparsedElementType.STYLESHEET:
          this.styleUrls.push(preparsedElement.hrefAttr);
          break;
        default:
          break;
      }
      if (preparsedElement.nonBindable) {
        this.ngNonBindableStackCount++;
      }
      visitAll(this, ast.children);
      if (preparsedElement.nonBindable) {
        this.ngNonBindableStackCount--;
      }
      return null;
    };
    TemplatePreparseVisitor.prototype.visitExpansion = function(ast, context) {
      visitAll(this, ast.cases);
    };
    TemplatePreparseVisitor.prototype.visitExpansionCase = function(ast, context) {
      visitAll(this, ast.expression);
    };
    TemplatePreparseVisitor.prototype.visitComment = function(ast, context) {
      return null;
    };
    TemplatePreparseVisitor.prototype.visitAttribute = function(ast, context) {
      return null;
    };
    TemplatePreparseVisitor.prototype.visitText = function(ast, context) {
      return null;
    };
    return TemplatePreparseVisitor;
  }());
  var DirectiveResolver = (function() {
    function DirectiveResolver(_reflector) {
      this._reflector = _reflector;
    }
    DirectiveResolver.prototype.isDirective = function(type) {
      var typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));
      return typeMetadata && typeMetadata.some(isDirectiveMetadata);
    };
    DirectiveResolver.prototype.resolve = function(type, throwIfNotFound) {
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      var typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));
      if (typeMetadata) {
        var metadata = findLast(typeMetadata, isDirectiveMetadata);
        if (metadata) {
          var propertyMetadata = this._reflector.propMetadata(type);
          return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);
        }
      }
      if (throwIfNotFound) {
        throw new Error("No Directive annotation found on " + _angular_core.ɵstringify(type));
      }
      return null;
    };
    DirectiveResolver.prototype._mergeWithPropertyMetadata = function(dm, propertyMetadata, directiveType) {
      var inputs = [];
      var outputs = [];
      var host = {};
      var queries = {};
      Object.keys(propertyMetadata).forEach(function(propName) {
        var input = findLast(propertyMetadata[propName], function(a) {
          return a instanceof _angular_core.Input;
        });
        if (input) {
          if (input.bindingPropertyName) {
            inputs.push(propName + ": " + input.bindingPropertyName);
          } else {
            inputs.push(propName);
          }
        }
        var output = findLast(propertyMetadata[propName], function(a) {
          return a instanceof _angular_core.Output;
        });
        if (output) {
          if (output.bindingPropertyName) {
            outputs.push(propName + ": " + output.bindingPropertyName);
          } else {
            outputs.push(propName);
          }
        }
        var hostBindings = propertyMetadata[propName].filter(function(a) {
          return a && a instanceof _angular_core.HostBinding;
        });
        hostBindings.forEach(function(hostBinding) {
          if (hostBinding.hostPropertyName) {
            var startWith = hostBinding.hostPropertyName[0];
            if (startWith === '(') {
              throw new Error("@HostBinding can not bind to events. Use @HostListener instead.");
            } else if (startWith === '[') {
              throw new Error("@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.");
            }
            host["[" + hostBinding.hostPropertyName + "]"] = propName;
          } else {
            host["[" + propName + "]"] = propName;
          }
        });
        var hostListeners = propertyMetadata[propName].filter(function(a) {
          return a && a instanceof _angular_core.HostListener;
        });
        hostListeners.forEach(function(hostListener) {
          var args = hostListener.args || [];
          host["(" + hostListener.eventName + ")"] = propName + "(" + args.join(',') + ")";
        });
        var query = findLast(propertyMetadata[propName], function(a) {
          return a instanceof _angular_core.Query;
        });
        if (query) {
          queries[propName] = query;
        }
      });
      return this._merge(dm, inputs, outputs, host, queries, directiveType);
    };
    DirectiveResolver.prototype._extractPublicName = function(def) {
      return splitAtColon(def, [((null)), def])[1].trim();
    };
    DirectiveResolver.prototype._dedupeBindings = function(bindings) {
      var names = new Set();
      var reversedResult = [];
      for (var i = bindings.length - 1; i >= 0; i--) {
        var binding = bindings[i];
        var name = this._extractPublicName(binding);
        if (!names.has(name)) {
          names.add(name);
          reversedResult.push(binding);
        }
      }
      return reversedResult.reverse();
    };
    DirectiveResolver.prototype._merge = function(directive, inputs, outputs, host, queries, directiveType) {
      var mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);
      var mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);
      var mergedHost = directive.host ? Object.assign({}, directive.host, host) : host;
      var mergedQueries = directive.queries ? Object.assign({}, directive.queries, queries) : queries;
      if (directive instanceof _angular_core.Component) {
        return new _angular_core.Component({
          selector: directive.selector,
          inputs: mergedInputs,
          outputs: mergedOutputs,
          host: mergedHost,
          exportAs: directive.exportAs,
          moduleId: directive.moduleId,
          queries: mergedQueries,
          changeDetection: directive.changeDetection,
          providers: directive.providers,
          viewProviders: directive.viewProviders,
          entryComponents: directive.entryComponents,
          template: directive.template,
          templateUrl: directive.templateUrl,
          styles: directive.styles,
          styleUrls: directive.styleUrls,
          encapsulation: directive.encapsulation,
          animations: directive.animations,
          interpolation: directive.interpolation
        });
      } else {
        return new _angular_core.Directive({
          selector: directive.selector,
          inputs: mergedInputs,
          outputs: mergedOutputs,
          host: mergedHost,
          exportAs: directive.exportAs,
          queries: mergedQueries,
          providers: directive.providers
        });
      }
    };
    return DirectiveResolver;
  }());
  DirectiveResolver.decorators = [{type: CompilerInjectable}];
  DirectiveResolver.ctorParameters = function() {
    return [{type: CompileReflector}];
  };
  function isDirectiveMetadata(type) {
    return type instanceof _angular_core.Directive;
  }
  function findLast(arr, condition) {
    for (var i = arr.length - 1; i >= 0; i--) {
      if (condition(arr[i])) {
        return arr[i];
      }
    }
    return null;
  }
  var STRIP_SRC_FILE_SUFFIXES = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
  var GENERATED_FILE = /\.ngfactory\.|\.ngsummary\./;
  var JIT_SUMMARY_FILE = /\.ngsummary\./;
  var JIT_SUMMARY_NAME = /NgSummary$/;
  function ngfactoryFilePath(filePath, forceSourceFile) {
    if (forceSourceFile === void 0) {
      forceSourceFile = false;
    }
    var urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);
    return urlWithSuffix[0] + ".ngfactory" + urlWithSuffix[1];
  }
  function stripGeneratedFileSuffix(filePath) {
    return filePath.replace(GENERATED_FILE, '.');
  }
  function isGeneratedFile(filePath) {
    return GENERATED_FILE.test(filePath);
  }
  function splitTypescriptSuffix(path, forceSourceFile) {
    if (forceSourceFile === void 0) {
      forceSourceFile = false;
    }
    if (path.endsWith('.d.ts')) {
      return [path.slice(0, -5), forceSourceFile ? '.ts' : '.d.ts'];
    }
    var lastDot = path.lastIndexOf('.');
    if (lastDot !== -1) {
      return [path.substring(0, lastDot), path.substring(lastDot)];
    }
    return [path, ''];
  }
  function summaryFileName(fileName) {
    var fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');
    return fileNameWithoutSuffix + ".ngsummary.json";
  }
  function summaryForJitFileName(fileName, forceSourceFile) {
    if (forceSourceFile === void 0) {
      forceSourceFile = false;
    }
    var urlWithSuffix = splitTypescriptSuffix(stripGeneratedFileSuffix(fileName), forceSourceFile);
    return urlWithSuffix[0] + ".ngsummary" + urlWithSuffix[1];
  }
  function stripSummaryForJitFileSuffix(filePath) {
    return filePath.replace(JIT_SUMMARY_FILE, '.');
  }
  function summaryForJitName(symbolName) {
    return symbolName + "NgSummary";
  }
  function stripSummaryForJitNameSuffix(symbolName) {
    return symbolName.replace(JIT_SUMMARY_NAME, '');
  }
  var LifecycleHooks = {};
  LifecycleHooks.OnInit = 0;
  LifecycleHooks.OnDestroy = 1;
  LifecycleHooks.DoCheck = 2;
  LifecycleHooks.OnChanges = 3;
  LifecycleHooks.AfterContentInit = 4;
  LifecycleHooks.AfterContentChecked = 5;
  LifecycleHooks.AfterViewInit = 6;
  LifecycleHooks.AfterViewChecked = 7;
  LifecycleHooks[LifecycleHooks.OnInit] = "OnInit";
  LifecycleHooks[LifecycleHooks.OnDestroy] = "OnDestroy";
  LifecycleHooks[LifecycleHooks.DoCheck] = "DoCheck";
  LifecycleHooks[LifecycleHooks.OnChanges] = "OnChanges";
  LifecycleHooks[LifecycleHooks.AfterContentInit] = "AfterContentInit";
  LifecycleHooks[LifecycleHooks.AfterContentChecked] = "AfterContentChecked";
  LifecycleHooks[LifecycleHooks.AfterViewInit] = "AfterViewInit";
  LifecycleHooks[LifecycleHooks.AfterViewChecked] = "AfterViewChecked";
  var LIFECYCLE_HOOKS_VALUES = [LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges, LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit, LifecycleHooks.AfterViewChecked];
  function hasLifecycleHook(reflector, hook, token) {
    return reflector.hasLifecycleHook(token, getHookName(hook));
  }
  function getAllLifecycleHooks(reflector, token) {
    return LIFECYCLE_HOOKS_VALUES.filter(function(hook) {
      return hasLifecycleHook(reflector, hook, token);
    });
  }
  function getHookName(hook) {
    switch (hook) {
      case LifecycleHooks.OnInit:
        return 'ngOnInit';
      case LifecycleHooks.OnDestroy:
        return 'ngOnDestroy';
      case LifecycleHooks.DoCheck:
        return 'ngDoCheck';
      case LifecycleHooks.OnChanges:
        return 'ngOnChanges';
      case LifecycleHooks.AfterContentInit:
        return 'ngAfterContentInit';
      case LifecycleHooks.AfterContentChecked:
        return 'ngAfterContentChecked';
      case LifecycleHooks.AfterViewInit:
        return 'ngAfterViewInit';
      case LifecycleHooks.AfterViewChecked:
        return 'ngAfterViewChecked';
    }
  }
  function _isNgModuleMetadata(obj) {
    return obj instanceof _angular_core.NgModule;
  }
  var NgModuleResolver = (function() {
    function NgModuleResolver(_reflector) {
      this._reflector = _reflector;
    }
    NgModuleResolver.prototype.isNgModule = function(type) {
      return this._reflector.annotations(type).some(_isNgModuleMetadata);
    };
    NgModuleResolver.prototype.resolve = function(type, throwIfNotFound) {
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      var ngModuleMeta = findLast(this._reflector.annotations(type), _isNgModuleMetadata);
      if (ngModuleMeta) {
        return ngModuleMeta;
      } else {
        if (throwIfNotFound) {
          throw new Error("No NgModule metadata found for '" + _angular_core.ɵstringify(type) + "'.");
        }
        return null;
      }
    };
    return NgModuleResolver;
  }());
  NgModuleResolver.decorators = [{type: CompilerInjectable}];
  NgModuleResolver.ctorParameters = function() {
    return [{type: CompileReflector}];
  };
  function _isPipeMetadata(type) {
    return type instanceof _angular_core.Pipe;
  }
  var PipeResolver = (function() {
    function PipeResolver(_reflector) {
      this._reflector = _reflector;
    }
    PipeResolver.prototype.isPipe = function(type) {
      var typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));
      return typeMetadata && typeMetadata.some(_isPipeMetadata);
    };
    PipeResolver.prototype.resolve = function(type, throwIfNotFound) {
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      var metas = this._reflector.annotations(_angular_core.resolveForwardRef(type));
      if (metas) {
        var annotation = findLast(metas, _isPipeMetadata);
        if (annotation) {
          return annotation;
        }
      }
      if (throwIfNotFound) {
        throw new Error("No Pipe decorator found on " + _angular_core.ɵstringify(type));
      }
      return null;
    };
    return PipeResolver;
  }());
  PipeResolver.decorators = [{type: CompilerInjectable}];
  PipeResolver.ctorParameters = function() {
    return [{type: CompileReflector}];
  };
  var SummaryResolver = (function() {
    function SummaryResolver() {}
    SummaryResolver.prototype.isLibraryFile = function(fileName) {};
    SummaryResolver.prototype.getLibraryFileName = function(fileName) {};
    SummaryResolver.prototype.resolveSummary = function(reference) {};
    SummaryResolver.prototype.getSymbolsOf = function(filePath) {};
    SummaryResolver.prototype.getImportAs = function(reference) {};
    SummaryResolver.prototype.addSummary = function(summary) {};
    return SummaryResolver;
  }());
  var JitSummaryResolver = (function() {
    function JitSummaryResolver() {
      this._summaries = new Map();
    }
    JitSummaryResolver.prototype.isLibraryFile = function(fileName) {
      return false;
    };
    JitSummaryResolver.prototype.getLibraryFileName = function(fileName) {
      return null;
    };
    JitSummaryResolver.prototype.resolveSummary = function(reference) {
      return this._summaries.get(reference) || null;
    };
    JitSummaryResolver.prototype.getSymbolsOf = function(filePath) {
      return [];
    };
    JitSummaryResolver.prototype.getImportAs = function(reference) {
      return reference;
    };
    JitSummaryResolver.prototype.addSummary = function(summary) {
      this._summaries.set(summary.symbol, summary);
    };
    return JitSummaryResolver;
  }());
  JitSummaryResolver.decorators = [{type: CompilerInjectable}];
  JitSummaryResolver.ctorParameters = function() {
    return [];
  };
  var ERROR_COLLECTOR_TOKEN = new _angular_core.InjectionToken('ErrorCollector');
  var CompileMetadataResolver = (function() {
    function CompileMetadataResolver(_config, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {
      this._config = _config;
      this._ngModuleResolver = _ngModuleResolver;
      this._directiveResolver = _directiveResolver;
      this._pipeResolver = _pipeResolver;
      this._summaryResolver = _summaryResolver;
      this._schemaRegistry = _schemaRegistry;
      this._directiveNormalizer = _directiveNormalizer;
      this._console = _console;
      this._staticSymbolCache = _staticSymbolCache;
      this._reflector = _reflector;
      this._errorCollector = _errorCollector;
      this._nonNormalizedDirectiveCache = new Map();
      this._directiveCache = new Map();
      this._summaryCache = new Map();
      this._pipeCache = new Map();
      this._ngModuleCache = new Map();
      this._ngModuleOfTypes = new Map();
    }
    CompileMetadataResolver.prototype.getReflector = function() {
      return this._reflector;
    };
    CompileMetadataResolver.prototype.clearCacheFor = function(type) {
      var dirMeta = this._directiveCache.get(type);
      this._directiveCache.delete(type);
      this._nonNormalizedDirectiveCache.delete(type);
      this._summaryCache.delete(type);
      this._pipeCache.delete(type);
      this._ngModuleOfTypes.delete(type);
      this._ngModuleCache.clear();
      if (dirMeta) {
        this._directiveNormalizer.clearCacheFor(dirMeta);
      }
    };
    CompileMetadataResolver.prototype.clearCache = function() {
      this._directiveCache.clear();
      this._nonNormalizedDirectiveCache.clear();
      this._summaryCache.clear();
      this._pipeCache.clear();
      this._ngModuleCache.clear();
      this._ngModuleOfTypes.clear();
      this._directiveNormalizer.clearCache();
    };
    CompileMetadataResolver.prototype._createProxyClass = function(baseType, name) {
      var delegate = null;
      var proxyClass = (function() {
        if (!delegate) {
          throw new Error("Illegal state: Class " + name + " for type " + _angular_core.ɵstringify(baseType) + " is not compiled yet!");
        }
        return delegate.apply(this, arguments);
      });
      proxyClass.setDelegate = function(d) {
        delegate = d;
        ((proxyClass)).prototype = d.prototype;
      };
      ((proxyClass)).overriddenName = name;
      return proxyClass;
    };
    CompileMetadataResolver.prototype.getGeneratedClass = function(dirType, name) {
      if (dirType instanceof StaticSymbol) {
        return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);
      } else {
        return this._createProxyClass(dirType, name);
      }
    };
    CompileMetadataResolver.prototype.getComponentViewClass = function(dirType) {
      return this.getGeneratedClass(dirType, viewClassName(dirType, 0));
    };
    CompileMetadataResolver.prototype.getHostComponentViewClass = function(dirType) {
      return this.getGeneratedClass(dirType, hostViewClassName(dirType));
    };
    CompileMetadataResolver.prototype.getHostComponentType = function(dirType) {
      var name = identifierName({reference: dirType}) + "_Host";
      if (dirType instanceof StaticSymbol) {
        return this._staticSymbolCache.get(dirType.filePath, name);
      } else {
        var HostClass = (function HostClass() {});
        HostClass.overriddenName = name;
        return HostClass;
      }
    };
    CompileMetadataResolver.prototype.getRendererType = function(dirType) {
      if (dirType instanceof StaticSymbol) {
        return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));
      } else {
        return ({});
      }
    };
    CompileMetadataResolver.prototype.getComponentFactory = function(selector, dirType, inputs, outputs) {
      if (dirType instanceof StaticSymbol) {
        return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));
      } else {
        var hostView = this.getHostComponentViewClass(dirType);
        return _angular_core.ɵccf(selector, dirType, (hostView), inputs, outputs, []);
      }
    };
    CompileMetadataResolver.prototype.initComponentFactory = function(factory, ngContentSelectors) {
      if (!(factory instanceof StaticSymbol)) {
        (_a = factory.ngContentSelectors).push.apply(_a, ngContentSelectors);
      }
      var _a;
    };
    CompileMetadataResolver.prototype._loadSummary = function(type, kind) {
      var typeSummary = this._summaryCache.get(type);
      if (!typeSummary) {
        var summary = this._summaryResolver.resolveSummary(type);
        typeSummary = summary ? summary.type : null;
        this._summaryCache.set(type, typeSummary || null);
      }
      return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;
    };
    CompileMetadataResolver.prototype.loadDirectiveMetadata = function(ngModuleType, directiveType, isSync) {
      var _this = this;
      if (this._directiveCache.has(directiveType)) {
        return null;
      }
      directiveType = _angular_core.resolveForwardRef(directiveType);
      var _a = ((this.getNonNormalizedDirectiveMetadata(directiveType))),
          annotation = _a.annotation,
          metadata = _a.metadata;
      var createDirectiveMetadata = function(templateMetadata) {
        var normalizedDirMeta = new CompileDirectiveMetadata({
          isHost: false,
          type: metadata.type,
          isComponent: metadata.isComponent,
          selector: metadata.selector,
          exportAs: metadata.exportAs,
          changeDetection: metadata.changeDetection,
          inputs: metadata.inputs,
          outputs: metadata.outputs,
          hostListeners: metadata.hostListeners,
          hostProperties: metadata.hostProperties,
          hostAttributes: metadata.hostAttributes,
          providers: metadata.providers,
          viewProviders: metadata.viewProviders,
          queries: metadata.queries,
          viewQueries: metadata.viewQueries,
          entryComponents: metadata.entryComponents,
          componentViewType: metadata.componentViewType,
          rendererType: metadata.rendererType,
          componentFactory: metadata.componentFactory,
          template: templateMetadata
        });
        if (templateMetadata) {
          _this.initComponentFactory(((metadata.componentFactory)), templateMetadata.ngContentSelectors);
        }
        _this._directiveCache.set(directiveType, normalizedDirMeta);
        _this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());
        return null;
      };
      if (metadata.isComponent) {
        var template = ((metadata.template));
        var templateMeta = this._directiveNormalizer.normalizeTemplate({
          ngModuleType: ngModuleType,
          componentType: directiveType,
          moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),
          encapsulation: template.encapsulation,
          template: template.template,
          templateUrl: template.templateUrl,
          styles: template.styles,
          styleUrls: template.styleUrls,
          animations: template.animations,
          interpolation: template.interpolation
        });
        if (_angular_core.ɵisPromise(templateMeta) && isSync) {
          this._reportError(componentStillLoadingError(directiveType), directiveType);
          return null;
        }
        return SyncAsync.then(templateMeta, createDirectiveMetadata);
      } else {
        createDirectiveMetadata(null);
        return null;
      }
    };
    CompileMetadataResolver.prototype.getNonNormalizedDirectiveMetadata = function(directiveType) {
      var _this = this;
      directiveType = _angular_core.resolveForwardRef(directiveType);
      if (!directiveType) {
        return null;
      }
      var cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);
      if (cacheEntry) {
        return cacheEntry;
      }
      var dirMeta = this._directiveResolver.resolve(directiveType, false);
      if (!dirMeta) {
        return null;
      }
      var nonNormalizedTemplateMetadata = ((undefined));
      if (dirMeta instanceof _angular_core.Component) {
        assertArrayOfStrings('styles', dirMeta.styles);
        assertArrayOfStrings('styleUrls', dirMeta.styleUrls);
        assertInterpolationSymbols('interpolation', dirMeta.interpolation);
        var animations = dirMeta.animations;
        nonNormalizedTemplateMetadata = new CompileTemplateMetadata({
          encapsulation: noUndefined(dirMeta.encapsulation),
          template: noUndefined(dirMeta.template),
          templateUrl: noUndefined(dirMeta.templateUrl),
          styles: dirMeta.styles || [],
          styleUrls: dirMeta.styleUrls || [],
          animations: animations || [],
          interpolation: noUndefined(dirMeta.interpolation),
          isInline: !!dirMeta.template,
          externalStylesheets: [],
          ngContentSelectors: []
        });
      }
      var changeDetectionStrategy = ((null));
      var viewProviders = [];
      var entryComponentMetadata = [];
      var selector = dirMeta.selector;
      if (dirMeta instanceof _angular_core.Component) {
        changeDetectionStrategy = ((dirMeta.changeDetection));
        if (dirMeta.viewProviders) {
          viewProviders = this._getProvidersMetadata(dirMeta.viewProviders, entryComponentMetadata, "viewProviders for \"" + stringifyType(directiveType) + "\"", [], directiveType);
        }
        if (dirMeta.entryComponents) {
          entryComponentMetadata = flattenAndDedupeArray(dirMeta.entryComponents).map(function(type) {
            return ((_this._getEntryComponentMetadata(type)));
          }).concat(entryComponentMetadata);
        }
        if (!selector) {
          selector = this._schemaRegistry.getDefaultComponentElementName();
        }
      } else {
        if (!selector) {
          this._reportError(syntaxError("Directive " + stringifyType(directiveType) + " has no selector, please add it!"), directiveType);
          selector = 'error';
        }
      }
      var providers = [];
      if (dirMeta.providers != null) {
        providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, "providers for \"" + stringifyType(directiveType) + "\"", [], directiveType);
      }
      var queries = [];
      var viewQueries = [];
      if (dirMeta.queries != null) {
        queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);
        viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);
      }
      var metadata = CompileDirectiveMetadata.create({
        isHost: false,
        selector: selector,
        exportAs: noUndefined(dirMeta.exportAs),
        isComponent: !!nonNormalizedTemplateMetadata,
        type: this._getTypeMetadata(directiveType),
        template: nonNormalizedTemplateMetadata,
        changeDetection: changeDetectionStrategy,
        inputs: dirMeta.inputs || [],
        outputs: dirMeta.outputs || [],
        host: dirMeta.host || {},
        providers: providers || [],
        viewProviders: viewProviders || [],
        queries: queries || [],
        viewQueries: viewQueries || [],
        entryComponents: entryComponentMetadata,
        componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) : null,
        rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,
        componentFactory: null
      });
      if (nonNormalizedTemplateMetadata) {
        metadata.componentFactory = this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);
      }
      cacheEntry = {
        metadata: metadata,
        annotation: dirMeta
      };
      this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);
      return cacheEntry;
    };
    CompileMetadataResolver.prototype.getDirectiveMetadata = function(directiveType) {
      var dirMeta = ((this._directiveCache.get(directiveType)));
      if (!dirMeta) {
        this._reportError(syntaxError("Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive " + stringifyType(directiveType) + "."), directiveType);
      }
      return dirMeta;
    };
    CompileMetadataResolver.prototype.getDirectiveSummary = function(dirType) {
      var dirSummary = (this._loadSummary(dirType, CompileSummaryKind.Directive));
      if (!dirSummary) {
        this._reportError(syntaxError("Illegal state: Could not load the summary for directive " + stringifyType(dirType) + "."), dirType);
      }
      return dirSummary;
    };
    CompileMetadataResolver.prototype.isDirective = function(type) {
      return !!this._loadSummary(type, CompileSummaryKind.Directive) || this._directiveResolver.isDirective(type);
    };
    CompileMetadataResolver.prototype.isPipe = function(type) {
      return !!this._loadSummary(type, CompileSummaryKind.Pipe) || this._pipeResolver.isPipe(type);
    };
    CompileMetadataResolver.prototype.isNgModule = function(type) {
      return !!this._loadSummary(type, CompileSummaryKind.NgModule) || this._ngModuleResolver.isNgModule(type);
    };
    CompileMetadataResolver.prototype.getNgModuleSummary = function(moduleType) {
      var moduleSummary = (this._loadSummary(moduleType, CompileSummaryKind.NgModule));
      if (!moduleSummary) {
        var moduleMeta = this.getNgModuleMetadata(moduleType, false);
        moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;
        if (moduleSummary) {
          this._summaryCache.set(moduleType, moduleSummary);
        }
      }
      return moduleSummary;
    };
    CompileMetadataResolver.prototype.loadNgModuleDirectiveAndPipeMetadata = function(moduleType, isSync, throwIfNotFound) {
      var _this = this;
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      var ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);
      var loading = [];
      if (ngModule) {
        ngModule.declaredDirectives.forEach(function(id) {
          var promise = _this.loadDirectiveMetadata(moduleType, id.reference, isSync);
          if (promise) {
            loading.push(promise);
          }
        });
        ngModule.declaredPipes.forEach(function(id) {
          return _this._loadPipeMetadata(id.reference);
        });
      }
      return Promise.all(loading);
    };
    CompileMetadataResolver.prototype.getNgModuleMetadata = function(moduleType, throwIfNotFound) {
      var _this = this;
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      moduleType = _angular_core.resolveForwardRef(moduleType);
      var compileMeta = this._ngModuleCache.get(moduleType);
      if (compileMeta) {
        return compileMeta;
      }
      var meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);
      if (!meta) {
        return null;
      }
      var declaredDirectives = [];
      var exportedNonModuleIdentifiers = [];
      var declaredPipes = [];
      var importedModules = [];
      var exportedModules = [];
      var providers = [];
      var entryComponents = [];
      var bootstrapComponents = [];
      var schemas = [];
      if (meta.imports) {
        flattenAndDedupeArray(meta.imports).forEach(function(importedType) {
          var importedModuleType = ((undefined));
          if (isValidType(importedType)) {
            importedModuleType = importedType;
          } else if (importedType && importedType.ngModule) {
            var moduleWithProviders = importedType;
            importedModuleType = moduleWithProviders.ngModule;
            if (moduleWithProviders.providers) {
              providers.push.apply(providers, _this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, "provider for the NgModule '" + stringifyType(importedModuleType) + "'", [], importedType));
            }
          }
          if (importedModuleType) {
            if (_this._checkSelfImport(moduleType, importedModuleType))
              return;
            var importedModuleSummary = _this.getNgModuleSummary(importedModuleType);
            if (!importedModuleSummary) {
              _this._reportError(syntaxError("Unexpected " + _this._getTypeDescriptor(importedType) + " '" + stringifyType(importedType) + "' imported by the module '" + stringifyType(moduleType) + "'. Please add a @NgModule annotation."), moduleType);
              return;
            }
            importedModules.push(importedModuleSummary);
          } else {
            _this._reportError(syntaxError("Unexpected value '" + stringifyType(importedType) + "' imported by the module '" + stringifyType(moduleType) + "'"), moduleType);
            return;
          }
        });
      }
      if (meta.exports) {
        flattenAndDedupeArray(meta.exports).forEach(function(exportedType) {
          if (!isValidType(exportedType)) {
            _this._reportError(syntaxError("Unexpected value '" + stringifyType(exportedType) + "' exported by the module '" + stringifyType(moduleType) + "'"), moduleType);
            return;
          }
          var exportedModuleSummary = _this.getNgModuleSummary(exportedType);
          if (exportedModuleSummary) {
            exportedModules.push(exportedModuleSummary);
          } else {
            exportedNonModuleIdentifiers.push(_this._getIdentifierMetadata(exportedType));
          }
        });
      }
      var transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);
      if (meta.declarations) {
        flattenAndDedupeArray(meta.declarations).forEach(function(declaredType) {
          if (!isValidType(declaredType)) {
            _this._reportError(syntaxError("Unexpected value '" + stringifyType(declaredType) + "' declared by the module '" + stringifyType(moduleType) + "'"), moduleType);
            return;
          }
          var declaredIdentifier = _this._getIdentifierMetadata(declaredType);
          if (_this.isDirective(declaredType)) {
            transitiveModule.addDirective(declaredIdentifier);
            declaredDirectives.push(declaredIdentifier);
            _this._addTypeToModule(declaredType, moduleType);
          } else if (_this.isPipe(declaredType)) {
            transitiveModule.addPipe(declaredIdentifier);
            transitiveModule.pipes.push(declaredIdentifier);
            declaredPipes.push(declaredIdentifier);
            _this._addTypeToModule(declaredType, moduleType);
          } else {
            _this._reportError(syntaxError("Unexpected " + _this._getTypeDescriptor(declaredType) + " '" + stringifyType(declaredType) + "' declared by the module '" + stringifyType(moduleType) + "'. Please add a @Pipe/@Directive/@Component annotation."), moduleType);
            return;
          }
        });
      }
      var exportedDirectives = [];
      var exportedPipes = [];
      exportedNonModuleIdentifiers.forEach(function(exportedId) {
        if (transitiveModule.directivesSet.has(exportedId.reference)) {
          exportedDirectives.push(exportedId);
          transitiveModule.addExportedDirective(exportedId);
        } else if (transitiveModule.pipesSet.has(exportedId.reference)) {
          exportedPipes.push(exportedId);
          transitiveModule.addExportedPipe(exportedId);
        } else {
          _this._reportError(syntaxError("Can't export " + _this._getTypeDescriptor(exportedId.reference) + " " + stringifyType(exportedId.reference) + " from " + stringifyType(moduleType) + " as it was neither declared nor imported!"), moduleType);
          return;
        }
      });
      if (meta.providers) {
        providers.push.apply(providers, this._getProvidersMetadata(meta.providers, entryComponents, "provider for the NgModule '" + stringifyType(moduleType) + "'", [], moduleType));
      }
      if (meta.entryComponents) {
        entryComponents.push.apply(entryComponents, flattenAndDedupeArray(meta.entryComponents).map(function(type) {
          return ((_this._getEntryComponentMetadata(type)));
        }));
      }
      if (meta.bootstrap) {
        flattenAndDedupeArray(meta.bootstrap).forEach(function(type) {
          if (!isValidType(type)) {
            _this._reportError(syntaxError("Unexpected value '" + stringifyType(type) + "' used in the bootstrap property of module '" + stringifyType(moduleType) + "'"), moduleType);
            return;
          }
          bootstrapComponents.push(_this._getIdentifierMetadata(type));
        });
      }
      entryComponents.push.apply(entryComponents, bootstrapComponents.map(function(type) {
        return ((_this._getEntryComponentMetadata(type.reference)));
      }));
      if (meta.schemas) {
        schemas.push.apply(schemas, flattenAndDedupeArray(meta.schemas));
      }
      compileMeta = new CompileNgModuleMetadata({
        type: this._getTypeMetadata(moduleType),
        providers: providers,
        entryComponents: entryComponents,
        bootstrapComponents: bootstrapComponents,
        schemas: schemas,
        declaredDirectives: declaredDirectives,
        exportedDirectives: exportedDirectives,
        declaredPipes: declaredPipes,
        exportedPipes: exportedPipes,
        importedModules: importedModules,
        exportedModules: exportedModules,
        transitiveModule: transitiveModule,
        id: meta.id || null
      });
      entryComponents.forEach(function(id) {
        return transitiveModule.addEntryComponent(id);
      });
      providers.forEach(function(provider) {
        return transitiveModule.addProvider(provider, ((compileMeta)).type);
      });
      transitiveModule.addModule(compileMeta.type);
      this._ngModuleCache.set(moduleType, compileMeta);
      return compileMeta;
    };
    CompileMetadataResolver.prototype._checkSelfImport = function(moduleType, importedModuleType) {
      if (moduleType === importedModuleType) {
        this._reportError(syntaxError("'" + stringifyType(moduleType) + "' module can't import itself"), moduleType);
        return true;
      }
      return false;
    };
    CompileMetadataResolver.prototype._getTypeDescriptor = function(type) {
      if (this.isDirective(type)) {
        return 'directive';
      }
      if (this.isPipe(type)) {
        return 'pipe';
      }
      if (this.isNgModule(type)) {
        return 'module';
      }
      if (((type)).provide) {
        return 'provider';
      }
      return 'value';
    };
    CompileMetadataResolver.prototype._addTypeToModule = function(type, moduleType) {
      var oldModule = this._ngModuleOfTypes.get(type);
      if (oldModule && oldModule !== moduleType) {
        this._reportError(syntaxError("Type " + stringifyType(type) + " is part of the declarations of 2 modules: " + stringifyType(oldModule) + " and " + stringifyType(moduleType) + "! " + ("Please consider moving " + stringifyType(type) + " to a higher module that imports " + stringifyType(oldModule) + " and " + stringifyType(moduleType) + ". ") + ("You can also create a new NgModule that exports and includes " + stringifyType(type) + " then import that NgModule in " + stringifyType(oldModule) + " and " + stringifyType(moduleType) + ".")), moduleType);
        return;
      }
      this._ngModuleOfTypes.set(type, moduleType);
    };
    CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function(importedModules, exportedModules) {
      var result = new TransitiveCompileNgModuleMetadata();
      var modulesByToken = new Map();
      importedModules.concat(exportedModules).forEach(function(modSummary) {
        modSummary.modules.forEach(function(mod) {
          return result.addModule(mod);
        });
        modSummary.entryComponents.forEach(function(comp) {
          return result.addEntryComponent(comp);
        });
        var addedTokens = new Set();
        modSummary.providers.forEach(function(entry) {
          var tokenRef = tokenReference(entry.provider.token);
          var prevModules = modulesByToken.get(tokenRef);
          if (!prevModules) {
            prevModules = new Set();
            modulesByToken.set(tokenRef, prevModules);
          }
          var moduleRef = entry.module.reference;
          if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {
            prevModules.add(moduleRef);
            addedTokens.add(tokenRef);
            result.addProvider(entry.provider, entry.module);
          }
        });
      });
      exportedModules.forEach(function(modSummary) {
        modSummary.exportedDirectives.forEach(function(id) {
          return result.addExportedDirective(id);
        });
        modSummary.exportedPipes.forEach(function(id) {
          return result.addExportedPipe(id);
        });
      });
      importedModules.forEach(function(modSummary) {
        modSummary.exportedDirectives.forEach(function(id) {
          return result.addDirective(id);
        });
        modSummary.exportedPipes.forEach(function(id) {
          return result.addPipe(id);
        });
      });
      return result;
    };
    CompileMetadataResolver.prototype._getIdentifierMetadata = function(type) {
      type = _angular_core.resolveForwardRef(type);
      return {reference: type};
    };
    CompileMetadataResolver.prototype.isInjectable = function(type) {
      var annotations = this._reflector.annotations(type);
      return annotations.some(function(ann) {
        return ann.constructor === _angular_core.Injectable;
      });
    };
    CompileMetadataResolver.prototype.getInjectableSummary = function(type) {
      return {
        summaryKind: CompileSummaryKind.Injectable,
        type: this._getTypeMetadata(type, null, false)
      };
    };
    CompileMetadataResolver.prototype._getInjectableMetadata = function(type, dependencies) {
      if (dependencies === void 0) {
        dependencies = null;
      }
      var typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);
      if (typeSummary) {
        return typeSummary.type;
      }
      return this._getTypeMetadata(type, dependencies);
    };
    CompileMetadataResolver.prototype._getTypeMetadata = function(type, dependencies, throwOnUnknownDeps) {
      if (dependencies === void 0) {
        dependencies = null;
      }
      if (throwOnUnknownDeps === void 0) {
        throwOnUnknownDeps = true;
      }
      var identifier = this._getIdentifierMetadata(type);
      return {
        reference: identifier.reference,
        diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),
        lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference)
      };
    };
    CompileMetadataResolver.prototype._getFactoryMetadata = function(factory, dependencies) {
      if (dependencies === void 0) {
        dependencies = null;
      }
      factory = _angular_core.resolveForwardRef(factory);
      return {
        reference: factory,
        diDeps: this._getDependenciesMetadata(factory, dependencies)
      };
    };
    CompileMetadataResolver.prototype.getPipeMetadata = function(pipeType) {
      var pipeMeta = this._pipeCache.get(pipeType);
      if (!pipeMeta) {
        this._reportError(syntaxError("Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe " + stringifyType(pipeType) + "."), pipeType);
      }
      return pipeMeta || null;
    };
    CompileMetadataResolver.prototype.getPipeSummary = function(pipeType) {
      var pipeSummary = (this._loadSummary(pipeType, CompileSummaryKind.Pipe));
      if (!pipeSummary) {
        this._reportError(syntaxError("Illegal state: Could not load the summary for pipe " + stringifyType(pipeType) + "."), pipeType);
      }
      return pipeSummary;
    };
    CompileMetadataResolver.prototype.getOrLoadPipeMetadata = function(pipeType) {
      var pipeMeta = this._pipeCache.get(pipeType);
      if (!pipeMeta) {
        pipeMeta = this._loadPipeMetadata(pipeType);
      }
      return pipeMeta;
    };
    CompileMetadataResolver.prototype._loadPipeMetadata = function(pipeType) {
      pipeType = _angular_core.resolveForwardRef(pipeType);
      var pipeAnnotation = ((this._pipeResolver.resolve(pipeType)));
      var pipeMeta = new CompilePipeMetadata({
        type: this._getTypeMetadata(pipeType),
        name: pipeAnnotation.name,
        pure: !!pipeAnnotation.pure
      });
      this._pipeCache.set(pipeType, pipeMeta);
      this._summaryCache.set(pipeType, pipeMeta.toSummary());
      return pipeMeta;
    };
    CompileMetadataResolver.prototype._getDependenciesMetadata = function(typeOrFunc, dependencies, throwOnUnknownDeps) {
      var _this = this;
      if (throwOnUnknownDeps === void 0) {
        throwOnUnknownDeps = true;
      }
      var hasUnknownDeps = false;
      var params = dependencies || this._reflector.parameters(typeOrFunc) || [];
      var dependenciesMetadata = params.map(function(param) {
        var isAttribute = false;
        var isHost = false;
        var isSelf = false;
        var isSkipSelf = false;
        var isOptional = false;
        var token = null;
        if (Array.isArray(param)) {
          param.forEach(function(paramEntry) {
            if (paramEntry instanceof _angular_core.Host) {
              isHost = true;
            } else if (paramEntry instanceof _angular_core.Self) {
              isSelf = true;
            } else if (paramEntry instanceof _angular_core.SkipSelf) {
              isSkipSelf = true;
            } else if (paramEntry instanceof _angular_core.Optional) {
              isOptional = true;
            } else if (paramEntry instanceof _angular_core.Attribute) {
              isAttribute = true;
              token = paramEntry.attributeName;
            } else if (paramEntry instanceof _angular_core.Inject) {
              token = paramEntry.token;
            } else if (paramEntry instanceof _angular_core.InjectionToken) {
              token = paramEntry;
            } else if (isValidType(paramEntry) && token == null) {
              token = paramEntry;
            }
          });
        } else {
          token = param;
        }
        if (token == null) {
          hasUnknownDeps = true;
          return ((null));
        }
        return {
          isAttribute: isAttribute,
          isHost: isHost,
          isSelf: isSelf,
          isSkipSelf: isSkipSelf,
          isOptional: isOptional,
          token: _this._getTokenMetadata(token)
        };
      });
      if (hasUnknownDeps) {
        var depsTokens = dependenciesMetadata.map(function(dep) {
          return dep ? stringifyType(dep.token) : '?';
        }).join(', ');
        var message = "Can't resolve all parameters for " + stringifyType(typeOrFunc) + ": (" + depsTokens + ").";
        if (throwOnUnknownDeps) {
          this._reportError(syntaxError(message), typeOrFunc);
        } else {
          this._console.warn("Warning: " + message + " This will become an error in Angular v5.x");
        }
      }
      return dependenciesMetadata;
    };
    CompileMetadataResolver.prototype._getTokenMetadata = function(token) {
      token = _angular_core.resolveForwardRef(token);
      var compileToken;
      if (typeof token === 'string') {
        compileToken = {value: token};
      } else {
        compileToken = {identifier: {reference: token}};
      }
      return compileToken;
    };
    CompileMetadataResolver.prototype._getProvidersMetadata = function(providers, targetEntryComponents, debugInfo, compileProviders, type) {
      var _this = this;
      if (compileProviders === void 0) {
        compileProviders = [];
      }
      providers.forEach(function(provider, providerIdx) {
        if (Array.isArray(provider)) {
          _this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);
        } else {
          provider = _angular_core.resolveForwardRef(provider);
          var providerMeta = ((undefined));
          if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {
            _this._validateProvider(provider);
            providerMeta = new ProviderMeta(provider.provide, provider);
          } else if (isValidType(provider)) {
            providerMeta = new ProviderMeta(provider, {useClass: provider});
          } else if (provider === void 0) {
            _this._reportError(syntaxError("Encountered undefined provider! Usually this means you have a circular dependencies (might be caused by using 'barrel' index.ts files."));
            return;
          } else {
            var providersInfo = ((providers.reduce(function(soFar, seenProvider, seenProviderIdx) {
              if (seenProviderIdx < providerIdx) {
                soFar.push("" + stringifyType(seenProvider));
              } else if (seenProviderIdx == providerIdx) {
                soFar.push("?" + stringifyType(seenProvider) + "?");
              } else if (seenProviderIdx == providerIdx + 1) {
                soFar.push('...');
              }
              return soFar;
            }, []))).join(', ');
            _this._reportError(syntaxError("Invalid " + (debugInfo ? debugInfo : 'provider') + " - only instances of Provider and Type are allowed, got: [" + providersInfo + "]"), type);
            return;
          }
          if (providerMeta.token === _this._reflector.resolveExternalReference(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {
            targetEntryComponents.push.apply(targetEntryComponents, _this._getEntryComponentsFromProvider(providerMeta, type));
          } else {
            compileProviders.push(_this.getProviderMetadata(providerMeta));
          }
        }
      });
      return compileProviders;
    };
    CompileMetadataResolver.prototype._validateProvider = function(provider) {
      if (provider.hasOwnProperty('useClass') && provider.useClass == null) {
        this._reportError(syntaxError("Invalid provider for " + stringifyType(provider.provide) + ". useClass cannot be " + provider.useClass + ".\n           Usually it happens when:\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\n           2. Class was used before it was declared. Use forwardRef in this case."));
      }
    };
    CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function(provider, type) {
      var _this = this;
      var components = [];
      var collectedIdentifiers = [];
      if (provider.useFactory || provider.useExisting || provider.useClass) {
        this._reportError(syntaxError("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!"), type);
        return [];
      }
      if (!provider.multi) {
        this._reportError(syntaxError("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!"), type);
        return [];
      }
      extractIdentifiers(provider.useValue, collectedIdentifiers);
      collectedIdentifiers.forEach(function(identifier) {
        var entry = _this._getEntryComponentMetadata(identifier.reference, false);
        if (entry) {
          components.push(entry);
        }
      });
      return components;
    };
    CompileMetadataResolver.prototype._getEntryComponentMetadata = function(dirType, throwIfNotFound) {
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      var dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);
      if (dirMeta && dirMeta.metadata.isComponent) {
        return {
          componentType: dirType,
          componentFactory: ((dirMeta.metadata.componentFactory))
        };
      }
      var dirSummary = (this._loadSummary(dirType, CompileSummaryKind.Directive));
      if (dirSummary && dirSummary.isComponent) {
        return {
          componentType: dirType,
          componentFactory: ((dirSummary.componentFactory))
        };
      }
      if (throwIfNotFound) {
        throw syntaxError(dirType.name + " cannot be used as an entry component.");
      }
      return null;
    };
    CompileMetadataResolver.prototype.getProviderMetadata = function(provider) {
      var compileDeps = ((undefined));
      var compileTypeMetadata = ((null));
      var compileFactoryMetadata = ((null));
      var token = this._getTokenMetadata(provider.token);
      if (provider.useClass) {
        compileTypeMetadata = this._getInjectableMetadata(provider.useClass, provider.dependencies);
        compileDeps = compileTypeMetadata.diDeps;
        if (provider.token === provider.useClass) {
          token = {identifier: compileTypeMetadata};
        }
      } else if (provider.useFactory) {
        compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);
        compileDeps = compileFactoryMetadata.diDeps;
      }
      return {
        token: token,
        useClass: compileTypeMetadata,
        useValue: provider.useValue,
        useFactory: compileFactoryMetadata,
        useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,
        deps: compileDeps,
        multi: provider.multi
      };
    };
    CompileMetadataResolver.prototype._getQueriesMetadata = function(queries, isViewQuery, directiveType) {
      var _this = this;
      var res = [];
      Object.keys(queries).forEach(function(propertyName) {
        var query = queries[propertyName];
        if (query.isViewQuery === isViewQuery) {
          res.push(_this._getQueryMetadata(query, propertyName, directiveType));
        }
      });
      return res;
    };
    CompileMetadataResolver.prototype._queryVarBindings = function(selector) {
      return selector.split(/\s*,\s*/);
    };
    CompileMetadataResolver.prototype._getQueryMetadata = function(q, propertyName, typeOrFunc) {
      var _this = this;
      var selectors;
      if (typeof q.selector === 'string') {
        selectors = this._queryVarBindings(q.selector).map(function(varName) {
          return _this._getTokenMetadata(varName);
        });
      } else {
        if (!q.selector) {
          this._reportError(syntaxError("Can't construct a query for the property \"" + propertyName + "\" of \"" + stringifyType(typeOrFunc) + "\" since the query selector wasn't defined."), typeOrFunc);
          selectors = [];
        } else {
          selectors = [this._getTokenMetadata(q.selector)];
        }
      }
      return {
        selectors: selectors,
        first: q.first,
        descendants: q.descendants,
        propertyName: propertyName,
        read: q.read ? this._getTokenMetadata(q.read) : ((null))
      };
    };
    CompileMetadataResolver.prototype._reportError = function(error, type, otherType) {
      if (this._errorCollector) {
        this._errorCollector(error, type);
        if (otherType) {
          this._errorCollector(error, otherType);
        }
      } else {
        throw error;
      }
    };
    return CompileMetadataResolver;
  }());
  CompileMetadataResolver.decorators = [{type: CompilerInjectable}];
  CompileMetadataResolver.ctorParameters = function() {
    return [{type: CompilerConfig}, {type: NgModuleResolver}, {type: DirectiveResolver}, {type: PipeResolver}, {type: SummaryResolver}, {type: ElementSchemaRegistry}, {type: DirectiveNormalizer}, {type: _angular_core.ɵConsole}, {
      type: StaticSymbolCache,
      decorators: [{type: _angular_core.Optional}]
    }, {type: CompileReflector}, {
      type: undefined,
      decorators: [{type: _angular_core.Optional}, {
        type: _angular_core.Inject,
        args: [ERROR_COLLECTOR_TOKEN]
      }]
    }];
  };
  function flattenArray(tree, out) {
    if (out === void 0) {
      out = [];
    }
    if (tree) {
      for (var i = 0; i < tree.length; i++) {
        var item = _angular_core.resolveForwardRef(tree[i]);
        if (Array.isArray(item)) {
          flattenArray(item, out);
        } else {
          out.push(item);
        }
      }
    }
    return out;
  }
  function dedupeArray(array) {
    if (array) {
      return Array.from(new Set(array));
    }
    return [];
  }
  function flattenAndDedupeArray(tree) {
    return dedupeArray(flattenArray(tree));
  }
  function isValidType(value) {
    return (value instanceof StaticSymbol) || (value instanceof _angular_core.Type);
  }
  function extractIdentifiers(value, targetIdentifiers) {
    visitValue(value, new _CompileValueConverter(), targetIdentifiers);
  }
  var _CompileValueConverter = (function(_super) {
    __extends(_CompileValueConverter, _super);
    function _CompileValueConverter() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    _CompileValueConverter.prototype.visitOther = function(value, targetIdentifiers) {
      targetIdentifiers.push({reference: value});
    };
    return _CompileValueConverter;
  }(ValueTransformer));
  function stringifyType(type) {
    if (type instanceof StaticSymbol) {
      return type.name + " in " + type.filePath;
    } else {
      return _angular_core.ɵstringify(type);
    }
  }
  function componentStillLoadingError(compType) {
    var error = Error("Can't compile synchronously as " + _angular_core.ɵstringify(compType) + " is still being loaded!");
    ((error))[_angular_core.ɵERROR_COMPONENT_TYPE] = compType;
    return error;
  }
  var TypeModifier = {};
  TypeModifier.Const = 0;
  TypeModifier[TypeModifier.Const] = "Const";
  var Type$1 = (function() {
    function Type$1(modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      this.modifiers = modifiers;
      if (!modifiers) {
        this.modifiers = [];
      }
    }
    Type$1.prototype.visitType = function(visitor, context) {};
    Type$1.prototype.hasModifier = function(modifier) {
      return ((this.modifiers)).indexOf(modifier) !== -1;
    };
    return Type$1;
  }());
  var BuiltinTypeName = {};
  BuiltinTypeName.Dynamic = 0;
  BuiltinTypeName.Bool = 1;
  BuiltinTypeName.String = 2;
  BuiltinTypeName.Int = 3;
  BuiltinTypeName.Number = 4;
  BuiltinTypeName.Function = 5;
  BuiltinTypeName.Inferred = 6;
  BuiltinTypeName[BuiltinTypeName.Dynamic] = "Dynamic";
  BuiltinTypeName[BuiltinTypeName.Bool] = "Bool";
  BuiltinTypeName[BuiltinTypeName.String] = "String";
  BuiltinTypeName[BuiltinTypeName.Int] = "Int";
  BuiltinTypeName[BuiltinTypeName.Number] = "Number";
  BuiltinTypeName[BuiltinTypeName.Function] = "Function";
  BuiltinTypeName[BuiltinTypeName.Inferred] = "Inferred";
  var BuiltinType = (function(_super) {
    __extends(BuiltinType, _super);
    function BuiltinType(name, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      var _this = _super.call(this, modifiers) || this;
      _this.name = name;
      return _this;
    }
    BuiltinType.prototype.visitType = function(visitor, context) {
      return visitor.visitBuiltintType(this, context);
    };
    return BuiltinType;
  }(Type$1));
  var ExpressionType = (function(_super) {
    __extends(ExpressionType, _super);
    function ExpressionType(value, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      var _this = _super.call(this, modifiers) || this;
      _this.value = value;
      return _this;
    }
    ExpressionType.prototype.visitType = function(visitor, context) {
      return visitor.visitExpressionType(this, context);
    };
    return ExpressionType;
  }(Type$1));
  var ArrayType = (function(_super) {
    __extends(ArrayType, _super);
    function ArrayType(of, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      var _this = _super.call(this, modifiers) || this;
      _this.of = of;
      return _this;
    }
    ArrayType.prototype.visitType = function(visitor, context) {
      return visitor.visitArrayType(this, context);
    };
    return ArrayType;
  }(Type$1));
  var MapType = (function(_super) {
    __extends(MapType, _super);
    function MapType(valueType, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      var _this = _super.call(this, modifiers) || this;
      _this.valueType = valueType || null;
      return _this;
    }
    MapType.prototype.visitType = function(visitor, context) {
      return visitor.visitMapType(this, context);
    };
    return MapType;
  }(Type$1));
  var DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
  var INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);
  var BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
  var INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
  var NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
  var STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
  var FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
  var BinaryOperator = {};
  BinaryOperator.Equals = 0;
  BinaryOperator.NotEquals = 1;
  BinaryOperator.Identical = 2;
  BinaryOperator.NotIdentical = 3;
  BinaryOperator.Minus = 4;
  BinaryOperator.Plus = 5;
  BinaryOperator.Divide = 6;
  BinaryOperator.Multiply = 7;
  BinaryOperator.Modulo = 8;
  BinaryOperator.And = 9;
  BinaryOperator.Or = 10;
  BinaryOperator.Lower = 11;
  BinaryOperator.LowerEquals = 12;
  BinaryOperator.Bigger = 13;
  BinaryOperator.BiggerEquals = 14;
  BinaryOperator[BinaryOperator.Equals] = "Equals";
  BinaryOperator[BinaryOperator.NotEquals] = "NotEquals";
  BinaryOperator[BinaryOperator.Identical] = "Identical";
  BinaryOperator[BinaryOperator.NotIdentical] = "NotIdentical";
  BinaryOperator[BinaryOperator.Minus] = "Minus";
  BinaryOperator[BinaryOperator.Plus] = "Plus";
  BinaryOperator[BinaryOperator.Divide] = "Divide";
  BinaryOperator[BinaryOperator.Multiply] = "Multiply";
  BinaryOperator[BinaryOperator.Modulo] = "Modulo";
  BinaryOperator[BinaryOperator.And] = "And";
  BinaryOperator[BinaryOperator.Or] = "Or";
  BinaryOperator[BinaryOperator.Lower] = "Lower";
  BinaryOperator[BinaryOperator.LowerEquals] = "LowerEquals";
  BinaryOperator[BinaryOperator.Bigger] = "Bigger";
  BinaryOperator[BinaryOperator.BiggerEquals] = "BiggerEquals";
  var Expression = (function() {
    function Expression(type, sourceSpan) {
      this.type = type || null;
      this.sourceSpan = sourceSpan || null;
    }
    Expression.prototype.visitExpression = function(visitor, context) {};
    Expression.prototype.prop = function(name, sourceSpan) {
      return new ReadPropExpr(this, name, null, sourceSpan);
    };
    Expression.prototype.key = function(index, type, sourceSpan) {
      return new ReadKeyExpr(this, index, type, sourceSpan);
    };
    Expression.prototype.callMethod = function(name, params, sourceSpan) {
      return new InvokeMethodExpr(this, name, params, null, sourceSpan);
    };
    Expression.prototype.callFn = function(params, sourceSpan) {
      return new InvokeFunctionExpr(this, params, null, sourceSpan);
    };
    Expression.prototype.instantiate = function(params, type, sourceSpan) {
      return new InstantiateExpr(this, params, type, sourceSpan);
    };
    Expression.prototype.conditional = function(trueCase, falseCase, sourceSpan) {
      if (falseCase === void 0) {
        falseCase = null;
      }
      return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);
    };
    Expression.prototype.equals = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);
    };
    Expression.prototype.notEquals = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);
    };
    Expression.prototype.identical = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);
    };
    Expression.prototype.notIdentical = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);
    };
    Expression.prototype.minus = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);
    };
    Expression.prototype.plus = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);
    };
    Expression.prototype.divide = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);
    };
    Expression.prototype.multiply = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);
    };
    Expression.prototype.modulo = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);
    };
    Expression.prototype.and = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);
    };
    Expression.prototype.or = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);
    };
    Expression.prototype.lower = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);
    };
    Expression.prototype.lowerEquals = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);
    };
    Expression.prototype.bigger = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);
    };
    Expression.prototype.biggerEquals = function(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);
    };
    Expression.prototype.isBlank = function(sourceSpan) {
      return this.equals(TYPED_NULL_EXPR, sourceSpan);
    };
    Expression.prototype.cast = function(type, sourceSpan) {
      return new CastExpr(this, type, sourceSpan);
    };
    Expression.prototype.toStmt = function() {
      return new ExpressionStatement(this, null);
    };
    return Expression;
  }());
  var BuiltinVar = {};
  BuiltinVar.This = 0;
  BuiltinVar.Super = 1;
  BuiltinVar.CatchError = 2;
  BuiltinVar.CatchStack = 3;
  BuiltinVar[BuiltinVar.This] = "This";
  BuiltinVar[BuiltinVar.Super] = "Super";
  BuiltinVar[BuiltinVar.CatchError] = "CatchError";
  BuiltinVar[BuiltinVar.CatchStack] = "CatchStack";
  var ReadVarExpr = (function(_super) {
    __extends(ReadVarExpr, _super);
    function ReadVarExpr(name, type, sourceSpan) {
      var _this = _super.call(this, type, sourceSpan) || this;
      if (typeof name === 'string') {
        _this.name = name;
        _this.builtin = null;
      } else {
        _this.name = null;
        _this.builtin = name;
      }
      return _this;
    }
    ReadVarExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitReadVarExpr(this, context);
    };
    ReadVarExpr.prototype.set = function(value) {
      if (!this.name) {
        throw new Error("Built in variable " + this.builtin + " can not be assigned to.");
      }
      return new WriteVarExpr(this.name, value, null, this.sourceSpan);
    };
    return ReadVarExpr;
  }(Expression));
  var WriteVarExpr = (function(_super) {
    __extends(WriteVarExpr, _super);
    function WriteVarExpr(name, value, type, sourceSpan) {
      var _this = _super.call(this, type || value.type, sourceSpan) || this;
      _this.name = name;
      _this.value = value;
      return _this;
    }
    WriteVarExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitWriteVarExpr(this, context);
    };
    WriteVarExpr.prototype.toDeclStmt = function(type, modifiers) {
      return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);
    };
    return WriteVarExpr;
  }(Expression));
  var WriteKeyExpr = (function(_super) {
    __extends(WriteKeyExpr, _super);
    function WriteKeyExpr(receiver, index, value, type, sourceSpan) {
      var _this = _super.call(this, type || value.type, sourceSpan) || this;
      _this.receiver = receiver;
      _this.index = index;
      _this.value = value;
      return _this;
    }
    WriteKeyExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitWriteKeyExpr(this, context);
    };
    return WriteKeyExpr;
  }(Expression));
  var WritePropExpr = (function(_super) {
    __extends(WritePropExpr, _super);
    function WritePropExpr(receiver, name, value, type, sourceSpan) {
      var _this = _super.call(this, type || value.type, sourceSpan) || this;
      _this.receiver = receiver;
      _this.name = name;
      _this.value = value;
      return _this;
    }
    WritePropExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitWritePropExpr(this, context);
    };
    return WritePropExpr;
  }(Expression));
  var BuiltinMethod = {};
  BuiltinMethod.ConcatArray = 0;
  BuiltinMethod.SubscribeObservable = 1;
  BuiltinMethod.Bind = 2;
  BuiltinMethod[BuiltinMethod.ConcatArray] = "ConcatArray";
  BuiltinMethod[BuiltinMethod.SubscribeObservable] = "SubscribeObservable";
  BuiltinMethod[BuiltinMethod.Bind] = "Bind";
  var InvokeMethodExpr = (function(_super) {
    __extends(InvokeMethodExpr, _super);
    function InvokeMethodExpr(receiver, method, args, type, sourceSpan) {
      var _this = _super.call(this, type, sourceSpan) || this;
      _this.receiver = receiver;
      _this.args = args;
      if (typeof method === 'string') {
        _this.name = method;
        _this.builtin = null;
      } else {
        _this.name = null;
        _this.builtin = method;
      }
      return _this;
    }
    InvokeMethodExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitInvokeMethodExpr(this, context);
    };
    return InvokeMethodExpr;
  }(Expression));
  var InvokeFunctionExpr = (function(_super) {
    __extends(InvokeFunctionExpr, _super);
    function InvokeFunctionExpr(fn, args, type, sourceSpan) {
      var _this = _super.call(this, type, sourceSpan) || this;
      _this.fn = fn;
      _this.args = args;
      return _this;
    }
    InvokeFunctionExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitInvokeFunctionExpr(this, context);
    };
    return InvokeFunctionExpr;
  }(Expression));
  var InstantiateExpr = (function(_super) {
    __extends(InstantiateExpr, _super);
    function InstantiateExpr(classExpr, args, type, sourceSpan) {
      var _this = _super.call(this, type, sourceSpan) || this;
      _this.classExpr = classExpr;
      _this.args = args;
      return _this;
    }
    InstantiateExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitInstantiateExpr(this, context);
    };
    return InstantiateExpr;
  }(Expression));
  var LiteralExpr = (function(_super) {
    __extends(LiteralExpr, _super);
    function LiteralExpr(value, type, sourceSpan) {
      var _this = _super.call(this, type, sourceSpan) || this;
      _this.value = value;
      return _this;
    }
    LiteralExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitLiteralExpr(this, context);
    };
    return LiteralExpr;
  }(Expression));
  var ExternalExpr = (function(_super) {
    __extends(ExternalExpr, _super);
    function ExternalExpr(value, type, typeParams, sourceSpan) {
      if (typeParams === void 0) {
        typeParams = null;
      }
      var _this = _super.call(this, type, sourceSpan) || this;
      _this.value = value;
      _this.typeParams = typeParams;
      return _this;
    }
    ExternalExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitExternalExpr(this, context);
    };
    return ExternalExpr;
  }(Expression));
  var ExternalReference = (function() {
    function ExternalReference(moduleName, name, runtime) {
      this.moduleName = moduleName;
      this.name = name;
      this.runtime = runtime;
    }
    return ExternalReference;
  }());
  var ConditionalExpr = (function(_super) {
    __extends(ConditionalExpr, _super);
    function ConditionalExpr(condition, trueCase, falseCase, type, sourceSpan) {
      if (falseCase === void 0) {
        falseCase = null;
      }
      var _this = _super.call(this, type || trueCase.type, sourceSpan) || this;
      _this.condition = condition;
      _this.falseCase = falseCase;
      _this.trueCase = trueCase;
      return _this;
    }
    ConditionalExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitConditionalExpr(this, context);
    };
    return ConditionalExpr;
  }(Expression));
  var NotExpr = (function(_super) {
    __extends(NotExpr, _super);
    function NotExpr(condition, sourceSpan) {
      var _this = _super.call(this, BOOL_TYPE, sourceSpan) || this;
      _this.condition = condition;
      return _this;
    }
    NotExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitNotExpr(this, context);
    };
    return NotExpr;
  }(Expression));
  var AssertNotNull = (function(_super) {
    __extends(AssertNotNull, _super);
    function AssertNotNull(condition, sourceSpan) {
      var _this = _super.call(this, condition.type, sourceSpan) || this;
      _this.condition = condition;
      return _this;
    }
    AssertNotNull.prototype.visitExpression = function(visitor, context) {
      return visitor.visitAssertNotNullExpr(this, context);
    };
    return AssertNotNull;
  }(Expression));
  var CastExpr = (function(_super) {
    __extends(CastExpr, _super);
    function CastExpr(value, type, sourceSpan) {
      var _this = _super.call(this, type, sourceSpan) || this;
      _this.value = value;
      return _this;
    }
    CastExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitCastExpr(this, context);
    };
    return CastExpr;
  }(Expression));
  var FnParam = (function() {
    function FnParam(name, type) {
      if (type === void 0) {
        type = null;
      }
      this.name = name;
      this.type = type;
    }
    return FnParam;
  }());
  var FunctionExpr = (function(_super) {
    __extends(FunctionExpr, _super);
    function FunctionExpr(params, statements, type, sourceSpan) {
      var _this = _super.call(this, type, sourceSpan) || this;
      _this.params = params;
      _this.statements = statements;
      return _this;
    }
    FunctionExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitFunctionExpr(this, context);
    };
    FunctionExpr.prototype.toDeclStmt = function(name, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);
    };
    return FunctionExpr;
  }(Expression));
  var BinaryOperatorExpr = (function(_super) {
    __extends(BinaryOperatorExpr, _super);
    function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan) {
      var _this = _super.call(this, type || lhs.type, sourceSpan) || this;
      _this.operator = operator;
      _this.rhs = rhs;
      _this.lhs = lhs;
      return _this;
    }
    BinaryOperatorExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitBinaryOperatorExpr(this, context);
    };
    return BinaryOperatorExpr;
  }(Expression));
  var ReadPropExpr = (function(_super) {
    __extends(ReadPropExpr, _super);
    function ReadPropExpr(receiver, name, type, sourceSpan) {
      var _this = _super.call(this, type, sourceSpan) || this;
      _this.receiver = receiver;
      _this.name = name;
      return _this;
    }
    ReadPropExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitReadPropExpr(this, context);
    };
    ReadPropExpr.prototype.set = function(value) {
      return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);
    };
    return ReadPropExpr;
  }(Expression));
  var ReadKeyExpr = (function(_super) {
    __extends(ReadKeyExpr, _super);
    function ReadKeyExpr(receiver, index, type, sourceSpan) {
      var _this = _super.call(this, type, sourceSpan) || this;
      _this.receiver = receiver;
      _this.index = index;
      return _this;
    }
    ReadKeyExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitReadKeyExpr(this, context);
    };
    ReadKeyExpr.prototype.set = function(value) {
      return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);
    };
    return ReadKeyExpr;
  }(Expression));
  var LiteralArrayExpr = (function(_super) {
    __extends(LiteralArrayExpr, _super);
    function LiteralArrayExpr(entries, type, sourceSpan) {
      var _this = _super.call(this, type, sourceSpan) || this;
      _this.entries = entries;
      return _this;
    }
    LiteralArrayExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitLiteralArrayExpr(this, context);
    };
    return LiteralArrayExpr;
  }(Expression));
  var LiteralMapEntry = (function() {
    function LiteralMapEntry(key, value, quoted) {
      this.key = key;
      this.value = value;
      this.quoted = quoted;
    }
    return LiteralMapEntry;
  }());
  var LiteralMapExpr = (function(_super) {
    __extends(LiteralMapExpr, _super);
    function LiteralMapExpr(entries, type, sourceSpan) {
      var _this = _super.call(this, type, sourceSpan) || this;
      _this.entries = entries;
      _this.valueType = null;
      if (type) {
        _this.valueType = type.valueType;
      }
      return _this;
    }
    LiteralMapExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitLiteralMapExpr(this, context);
    };
    return LiteralMapExpr;
  }(Expression));
  var CommaExpr = (function(_super) {
    __extends(CommaExpr, _super);
    function CommaExpr(parts, sourceSpan) {
      var _this = _super.call(this, parts[parts.length - 1].type, sourceSpan) || this;
      _this.parts = parts;
      return _this;
    }
    CommaExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitCommaExpr(this, context);
    };
    return CommaExpr;
  }(Expression));
  var THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);
  var SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);
  var CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);
  var CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);
  var NULL_EXPR = new LiteralExpr(null, null, null);
  var TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);
  var StmtModifier = {};
  StmtModifier.Final = 0;
  StmtModifier.Private = 1;
  StmtModifier.Exported = 2;
  StmtModifier[StmtModifier.Final] = "Final";
  StmtModifier[StmtModifier.Private] = "Private";
  StmtModifier[StmtModifier.Exported] = "Exported";
  var Statement = (function() {
    function Statement(modifiers, sourceSpan) {
      this.modifiers = modifiers || [];
      this.sourceSpan = sourceSpan || null;
    }
    Statement.prototype.visitStatement = function(visitor, context) {};
    Statement.prototype.hasModifier = function(modifier) {
      return ((this.modifiers)).indexOf(modifier) !== -1;
    };
    return Statement;
  }());
  var DeclareVarStmt = (function(_super) {
    __extends(DeclareVarStmt, _super);
    function DeclareVarStmt(name, value, type, modifiers, sourceSpan) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      var _this = _super.call(this, modifiers, sourceSpan) || this;
      _this.name = name;
      _this.value = value;
      _this.type = type || value.type;
      return _this;
    }
    DeclareVarStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitDeclareVarStmt(this, context);
    };
    return DeclareVarStmt;
  }(Statement));
  var DeclareFunctionStmt = (function(_super) {
    __extends(DeclareFunctionStmt, _super);
    function DeclareFunctionStmt(name, params, statements, type, modifiers, sourceSpan) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      var _this = _super.call(this, modifiers, sourceSpan) || this;
      _this.name = name;
      _this.params = params;
      _this.statements = statements;
      _this.type = type || null;
      return _this;
    }
    DeclareFunctionStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitDeclareFunctionStmt(this, context);
    };
    return DeclareFunctionStmt;
  }(Statement));
  var ExpressionStatement = (function(_super) {
    __extends(ExpressionStatement, _super);
    function ExpressionStatement(expr, sourceSpan) {
      var _this = _super.call(this, null, sourceSpan) || this;
      _this.expr = expr;
      return _this;
    }
    ExpressionStatement.prototype.visitStatement = function(visitor, context) {
      return visitor.visitExpressionStmt(this, context);
    };
    return ExpressionStatement;
  }(Statement));
  var ReturnStatement = (function(_super) {
    __extends(ReturnStatement, _super);
    function ReturnStatement(value, sourceSpan) {
      var _this = _super.call(this, null, sourceSpan) || this;
      _this.value = value;
      return _this;
    }
    ReturnStatement.prototype.visitStatement = function(visitor, context) {
      return visitor.visitReturnStmt(this, context);
    };
    return ReturnStatement;
  }(Statement));
  var AbstractClassPart = (function() {
    function AbstractClassPart(type, modifiers) {
      this.modifiers = modifiers;
      if (!modifiers) {
        this.modifiers = [];
      }
      this.type = type || null;
    }
    AbstractClassPart.prototype.hasModifier = function(modifier) {
      return ((this.modifiers)).indexOf(modifier) !== -1;
    };
    return AbstractClassPart;
  }());
  var ClassMethod = (function(_super) {
    __extends(ClassMethod, _super);
    function ClassMethod(name, params, body, type, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      var _this = _super.call(this, type, modifiers) || this;
      _this.name = name;
      _this.params = params;
      _this.body = body;
      return _this;
    }
    return ClassMethod;
  }(AbstractClassPart));
  var ClassGetter = (function(_super) {
    __extends(ClassGetter, _super);
    function ClassGetter(name, body, type, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      var _this = _super.call(this, type, modifiers) || this;
      _this.name = name;
      _this.body = body;
      return _this;
    }
    return ClassGetter;
  }(AbstractClassPart));
  var ClassStmt = (function(_super) {
    __extends(ClassStmt, _super);
    function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers, sourceSpan) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      var _this = _super.call(this, modifiers, sourceSpan) || this;
      _this.name = name;
      _this.parent = parent;
      _this.fields = fields;
      _this.getters = getters;
      _this.constructorMethod = constructorMethod;
      _this.methods = methods;
      return _this;
    }
    ClassStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitDeclareClassStmt(this, context);
    };
    return ClassStmt;
  }(Statement));
  var IfStmt = (function(_super) {
    __extends(IfStmt, _super);
    function IfStmt(condition, trueCase, falseCase, sourceSpan) {
      if (falseCase === void 0) {
        falseCase = [];
      }
      var _this = _super.call(this, null, sourceSpan) || this;
      _this.condition = condition;
      _this.trueCase = trueCase;
      _this.falseCase = falseCase;
      return _this;
    }
    IfStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitIfStmt(this, context);
    };
    return IfStmt;
  }(Statement));
  var CommentStmt = (function(_super) {
    __extends(CommentStmt, _super);
    function CommentStmt(comment, sourceSpan) {
      var _this = _super.call(this, null, sourceSpan) || this;
      _this.comment = comment;
      return _this;
    }
    CommentStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitCommentStmt(this, context);
    };
    return CommentStmt;
  }(Statement));
  var TryCatchStmt = (function(_super) {
    __extends(TryCatchStmt, _super);
    function TryCatchStmt(bodyStmts, catchStmts, sourceSpan) {
      var _this = _super.call(this, null, sourceSpan) || this;
      _this.bodyStmts = bodyStmts;
      _this.catchStmts = catchStmts;
      return _this;
    }
    TryCatchStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitTryCatchStmt(this, context);
    };
    return TryCatchStmt;
  }(Statement));
  var ThrowStmt = (function(_super) {
    __extends(ThrowStmt, _super);
    function ThrowStmt(error, sourceSpan) {
      var _this = _super.call(this, null, sourceSpan) || this;
      _this.error = error;
      return _this;
    }
    ThrowStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitThrowStmt(this, context);
    };
    return ThrowStmt;
  }(Statement));
  var AstTransformer$1 = (function() {
    function AstTransformer$1() {}
    AstTransformer$1.prototype.transformExpr = function(expr, context) {
      return expr;
    };
    AstTransformer$1.prototype.transformStmt = function(stmt, context) {
      return stmt;
    };
    AstTransformer$1.prototype.visitReadVarExpr = function(ast, context) {
      return this.transformExpr(ast, context);
    };
    AstTransformer$1.prototype.visitWriteVarExpr = function(expr, context) {
      return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitWriteKeyExpr = function(expr, context) {
      return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitWritePropExpr = function(expr, context) {
      return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitInvokeMethodExpr = function(ast, context) {
      var method = ast.builtin || ast.name;
      return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), ((method)), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitInvokeFunctionExpr = function(ast, context) {
      return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitInstantiateExpr = function(ast, context) {
      return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitLiteralExpr = function(ast, context) {
      return this.transformExpr(ast, context);
    };
    AstTransformer$1.prototype.visitExternalExpr = function(ast, context) {
      return this.transformExpr(ast, context);
    };
    AstTransformer$1.prototype.visitConditionalExpr = function(ast, context) {
      return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ((ast.falseCase)).visitExpression(this, context), ast.type, ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitNotExpr = function(ast, context) {
      return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitAssertNotNullExpr = function(ast, context) {
      return this.transformExpr(new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitCastExpr = function(ast, context) {
      return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitFunctionExpr = function(ast, context) {
      return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitBinaryOperatorExpr = function(ast, context) {
      return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitReadPropExpr = function(ast, context) {
      return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitReadKeyExpr = function(ast, context) {
      return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitLiteralArrayExpr = function(ast, context) {
      return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitLiteralMapExpr = function(ast, context) {
      var _this = this;
      var entries = ast.entries.map(function(entry) {
        return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this, context), entry.quoted);
      });
      var mapType = new MapType(ast.valueType, null);
      return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitCommaExpr = function(ast, context) {
      return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitAllExpressions = function(exprs, context) {
      var _this = this;
      return exprs.map(function(expr) {
        return expr.visitExpression(_this, context);
      });
    };
    AstTransformer$1.prototype.visitDeclareVarStmt = function(stmt, context) {
      return this.transformStmt(new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitDeclareFunctionStmt = function(stmt, context) {
      return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitExpressionStmt = function(stmt, context) {
      return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitReturnStmt = function(stmt, context) {
      return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitDeclareClassStmt = function(stmt, context) {
      var _this = this;
      var parent = ((stmt.parent)).visitExpression(this, context);
      var getters = stmt.getters.map(function(getter) {
        return new ClassGetter(getter.name, _this.visitAllStatements(getter.body, context), getter.type, getter.modifiers);
      });
      var ctorMethod = stmt.constructorMethod && new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);
      var methods = stmt.methods.map(function(method) {
        return new ClassMethod(method.name, method.params, _this.visitAllStatements(method.body, context), method.type, method.modifiers);
      });
      return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitIfStmt = function(stmt, context) {
      return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitTryCatchStmt = function(stmt, context) {
      return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitThrowStmt = function(stmt, context) {
      return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);
    };
    AstTransformer$1.prototype.visitCommentStmt = function(stmt, context) {
      return this.transformStmt(stmt, context);
    };
    AstTransformer$1.prototype.visitAllStatements = function(stmts, context) {
      var _this = this;
      return stmts.map(function(stmt) {
        return stmt.visitStatement(_this, context);
      });
    };
    return AstTransformer$1;
  }());
  var RecursiveAstVisitor$1 = (function() {
    function RecursiveAstVisitor$1() {}
    RecursiveAstVisitor$1.prototype.visitReadVarExpr = function(ast, context) {
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitWriteVarExpr = function(expr, context) {
      expr.value.visitExpression(this, context);
      return expr;
    };
    RecursiveAstVisitor$1.prototype.visitWriteKeyExpr = function(expr, context) {
      expr.receiver.visitExpression(this, context);
      expr.index.visitExpression(this, context);
      expr.value.visitExpression(this, context);
      return expr;
    };
    RecursiveAstVisitor$1.prototype.visitWritePropExpr = function(expr, context) {
      expr.receiver.visitExpression(this, context);
      expr.value.visitExpression(this, context);
      return expr;
    };
    RecursiveAstVisitor$1.prototype.visitInvokeMethodExpr = function(ast, context) {
      ast.receiver.visitExpression(this, context);
      this.visitAllExpressions(ast.args, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitInvokeFunctionExpr = function(ast, context) {
      ast.fn.visitExpression(this, context);
      this.visitAllExpressions(ast.args, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitInstantiateExpr = function(ast, context) {
      ast.classExpr.visitExpression(this, context);
      this.visitAllExpressions(ast.args, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitLiteralExpr = function(ast, context) {
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitExternalExpr = function(ast, context) {
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitConditionalExpr = function(ast, context) {
      ast.condition.visitExpression(this, context);
      ast.trueCase.visitExpression(this, context);
      ((ast.falseCase)).visitExpression(this, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitNotExpr = function(ast, context) {
      ast.condition.visitExpression(this, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitAssertNotNullExpr = function(ast, context) {
      ast.condition.visitExpression(this, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitCastExpr = function(ast, context) {
      ast.value.visitExpression(this, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitFunctionExpr = function(ast, context) {
      this.visitAllStatements(ast.statements, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitBinaryOperatorExpr = function(ast, context) {
      ast.lhs.visitExpression(this, context);
      ast.rhs.visitExpression(this, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitReadPropExpr = function(ast, context) {
      ast.receiver.visitExpression(this, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitReadKeyExpr = function(ast, context) {
      ast.receiver.visitExpression(this, context);
      ast.index.visitExpression(this, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitLiteralArrayExpr = function(ast, context) {
      this.visitAllExpressions(ast.entries, context);
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitLiteralMapExpr = function(ast, context) {
      var _this = this;
      ast.entries.forEach(function(entry) {
        return entry.value.visitExpression(_this, context);
      });
      return ast;
    };
    RecursiveAstVisitor$1.prototype.visitCommaExpr = function(ast, context) {
      this.visitAllExpressions(ast.parts, context);
    };
    RecursiveAstVisitor$1.prototype.visitAllExpressions = function(exprs, context) {
      var _this = this;
      exprs.forEach(function(expr) {
        return expr.visitExpression(_this, context);
      });
    };
    RecursiveAstVisitor$1.prototype.visitDeclareVarStmt = function(stmt, context) {
      stmt.value.visitExpression(this, context);
      return stmt;
    };
    RecursiveAstVisitor$1.prototype.visitDeclareFunctionStmt = function(stmt, context) {
      this.visitAllStatements(stmt.statements, context);
      return stmt;
    };
    RecursiveAstVisitor$1.prototype.visitExpressionStmt = function(stmt, context) {
      stmt.expr.visitExpression(this, context);
      return stmt;
    };
    RecursiveAstVisitor$1.prototype.visitReturnStmt = function(stmt, context) {
      stmt.value.visitExpression(this, context);
      return stmt;
    };
    RecursiveAstVisitor$1.prototype.visitDeclareClassStmt = function(stmt, context) {
      var _this = this;
      ((stmt.parent)).visitExpression(this, context);
      stmt.getters.forEach(function(getter) {
        return _this.visitAllStatements(getter.body, context);
      });
      if (stmt.constructorMethod) {
        this.visitAllStatements(stmt.constructorMethod.body, context);
      }
      stmt.methods.forEach(function(method) {
        return _this.visitAllStatements(method.body, context);
      });
      return stmt;
    };
    RecursiveAstVisitor$1.prototype.visitIfStmt = function(stmt, context) {
      stmt.condition.visitExpression(this, context);
      this.visitAllStatements(stmt.trueCase, context);
      this.visitAllStatements(stmt.falseCase, context);
      return stmt;
    };
    RecursiveAstVisitor$1.prototype.visitTryCatchStmt = function(stmt, context) {
      this.visitAllStatements(stmt.bodyStmts, context);
      this.visitAllStatements(stmt.catchStmts, context);
      return stmt;
    };
    RecursiveAstVisitor$1.prototype.visitThrowStmt = function(stmt, context) {
      stmt.error.visitExpression(this, context);
      return stmt;
    };
    RecursiveAstVisitor$1.prototype.visitCommentStmt = function(stmt, context) {
      return stmt;
    };
    RecursiveAstVisitor$1.prototype.visitAllStatements = function(stmts, context) {
      var _this = this;
      stmts.forEach(function(stmt) {
        return stmt.visitStatement(_this, context);
      });
    };
    return RecursiveAstVisitor$1;
  }());
  function findReadVarNames(stmts) {
    var visitor = new _ReadVarVisitor();
    visitor.visitAllStatements(stmts, null);
    return visitor.varNames;
  }
  var _ReadVarVisitor = (function(_super) {
    __extends(_ReadVarVisitor, _super);
    function _ReadVarVisitor() {
      var _this = _super.apply(this, arguments) || this;
      _this.varNames = new Set();
      return _this;
    }
    _ReadVarVisitor.prototype.visitDeclareFunctionStmt = function(stmt, context) {
      return stmt;
    };
    _ReadVarVisitor.prototype.visitDeclareClassStmt = function(stmt, context) {
      return stmt;
    };
    _ReadVarVisitor.prototype.visitReadVarExpr = function(ast, context) {
      if (ast.name) {
        this.varNames.add(ast.name);
      }
      return null;
    };
    return _ReadVarVisitor;
  }(RecursiveAstVisitor$1));
  function applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {
    if (!sourceSpan) {
      return stmt;
    }
    var transformer = new _ApplySourceSpanTransformer(sourceSpan);
    return stmt.visitStatement(transformer, null);
  }
  function applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {
    if (!sourceSpan) {
      return expr;
    }
    var transformer = new _ApplySourceSpanTransformer(sourceSpan);
    return expr.visitExpression(transformer, null);
  }
  var _ApplySourceSpanTransformer = (function(_super) {
    __extends(_ApplySourceSpanTransformer, _super);
    function _ApplySourceSpanTransformer(sourceSpan) {
      var _this = _super.call(this) || this;
      _this.sourceSpan = sourceSpan;
      return _this;
    }
    _ApplySourceSpanTransformer.prototype._clone = function(obj) {
      var clone = Object.create(obj.constructor.prototype);
      for (var prop in obj) {
        clone[prop] = obj[prop];
      }
      return clone;
    };
    _ApplySourceSpanTransformer.prototype.transformExpr = function(expr, context) {
      if (!expr.sourceSpan) {
        expr = this._clone(expr);
        expr.sourceSpan = this.sourceSpan;
      }
      return expr;
    };
    _ApplySourceSpanTransformer.prototype.transformStmt = function(stmt, context) {
      if (!stmt.sourceSpan) {
        stmt = this._clone(stmt);
        stmt.sourceSpan = this.sourceSpan;
      }
      return stmt;
    };
    return _ApplySourceSpanTransformer;
  }(AstTransformer$1));
  function variable(name, type, sourceSpan) {
    return new ReadVarExpr(name, type, sourceSpan);
  }
  function importExpr(id, typeParams, sourceSpan) {
    if (typeParams === void 0) {
      typeParams = null;
    }
    return new ExternalExpr(id, null, typeParams, sourceSpan);
  }
  function importType(id, typeParams, typeModifiers) {
    if (typeParams === void 0) {
      typeParams = null;
    }
    if (typeModifiers === void 0) {
      typeModifiers = null;
    }
    return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;
  }
  function expressionType(expr, typeModifiers) {
    if (typeModifiers === void 0) {
      typeModifiers = null;
    }
    return expr != null ? ((new ExpressionType(expr, typeModifiers))) : null;
  }
  function literalArr(values, type, sourceSpan) {
    return new LiteralArrayExpr(values, type, sourceSpan);
  }
  function literalMap(values, type) {
    if (type === void 0) {
      type = null;
    }
    return new LiteralMapExpr(values.map(function(e) {
      return new LiteralMapEntry(e.key, e.value, e.quoted);
    }), type, null);
  }
  function not(expr, sourceSpan) {
    return new NotExpr(expr, sourceSpan);
  }
  function assertNotNull(expr, sourceSpan) {
    return new AssertNotNull(expr, sourceSpan);
  }
  function fn(params, body, type, sourceSpan) {
    return new FunctionExpr(params, body, type, sourceSpan);
  }
  function literal(value, type, sourceSpan) {
    return new LiteralExpr(value, type, sourceSpan);
  }
  var QUOTED_KEYS = '$quoted$';
  function convertValueToOutputAst(ctx, value, type) {
    if (type === void 0) {
      type = null;
    }
    return visitValue(value, new _ValueOutputAstTransformer(ctx), type);
  }
  var _ValueOutputAstTransformer = (function() {
    function _ValueOutputAstTransformer(ctx) {
      this.ctx = ctx;
    }
    _ValueOutputAstTransformer.prototype.visitArray = function(arr, type) {
      var _this = this;
      return literalArr(arr.map(function(value) {
        return visitValue(value, _this, null);
      }), type);
    };
    _ValueOutputAstTransformer.prototype.visitStringMap = function(map, type) {
      var _this = this;
      var entries = [];
      var quotedSet = new Set(map && map[QUOTED_KEYS]);
      Object.keys(map).forEach(function(key) {
        entries.push(new LiteralMapEntry(key, visitValue(map[key], _this, null), quotedSet.has(key)));
      });
      return new LiteralMapExpr(entries, type);
    };
    _ValueOutputAstTransformer.prototype.visitPrimitive = function(value, type) {
      return literal(value, type);
    };
    _ValueOutputAstTransformer.prototype.visitOther = function(value, type) {
      if (value instanceof Expression) {
        return value;
      } else {
        return this.ctx.importExpr(value);
      }
    };
    return _ValueOutputAstTransformer;
  }());
  function providerDef(ctx, providerAst) {
    var flags = 0;
    if (!providerAst.eager) {
      flags |= 4096;
    }
    if (providerAst.providerType === ProviderAstType.PrivateService) {
      flags |= 8192;
    }
    providerAst.lifecycleHooks.forEach(function(lifecycleHook) {
      if (lifecycleHook === LifecycleHooks.OnDestroy || providerAst.providerType === ProviderAstType.Directive || providerAst.providerType === ProviderAstType.Component) {
        flags |= lifecycleHookToNodeFlag(lifecycleHook);
      }
    });
    var _a = providerAst.multiProvider ? multiProviderDef(ctx, flags, providerAst.providers) : singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]),
        providerExpr = _a.providerExpr,
        providerFlags = _a.flags,
        depsExpr = _a.depsExpr;
    return {
      providerExpr: providerExpr,
      flags: providerFlags,
      depsExpr: depsExpr,
      tokenExpr: tokenExpr(ctx, providerAst.token)
    };
  }
  function multiProviderDef(ctx, flags, providers) {
    var allDepDefs = [];
    var allParams = [];
    var exprs = providers.map(function(provider, providerIndex) {
      var expr;
      if (provider.useClass) {
        var depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);
        expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);
      } else if (provider.useFactory) {
        var depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);
        expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);
      } else if (provider.useExisting) {
        var depExprs = convertDeps(providerIndex, [{token: provider.useExisting}]);
        expr = depExprs[0];
      } else {
        expr = convertValueToOutputAst(ctx, provider.useValue);
      }
      return expr;
    });
    var providerExpr = fn(allParams, [new ReturnStatement(literalArr(exprs))], INFERRED_TYPE);
    return {
      providerExpr: providerExpr,
      flags: flags | 1024,
      depsExpr: literalArr(allDepDefs)
    };
    function convertDeps(providerIndex, deps) {
      return deps.map(function(dep, depIndex) {
        var paramName = "p" + providerIndex + "_" + depIndex;
        allParams.push(new FnParam(paramName, DYNAMIC_TYPE));
        allDepDefs.push(depDef(ctx, dep));
        return variable(paramName);
      });
    }
  }
  function singleProviderDef(ctx, flags, providerType, providerMeta) {
    var providerExpr;
    var deps;
    if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {
      providerExpr = ctx.importExpr(((providerMeta.useClass)).reference);
      flags |= 16384;
      deps = providerMeta.deps || ((providerMeta.useClass)).diDeps;
    } else {
      if (providerMeta.useClass) {
        providerExpr = ctx.importExpr(providerMeta.useClass.reference);
        flags |= 512;
        deps = providerMeta.deps || providerMeta.useClass.diDeps;
      } else if (providerMeta.useFactory) {
        providerExpr = ctx.importExpr(providerMeta.useFactory.reference);
        flags |= 1024;
        deps = providerMeta.deps || providerMeta.useFactory.diDeps;
      } else if (providerMeta.useExisting) {
        providerExpr = NULL_EXPR;
        flags |= 2048;
        deps = [{token: providerMeta.useExisting}];
      } else {
        providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);
        flags |= 256;
        deps = [];
      }
    }
    var depsExpr = literalArr(deps.map(function(dep) {
      return depDef(ctx, dep);
    }));
    return {
      providerExpr: providerExpr,
      flags: flags,
      depsExpr: depsExpr
    };
  }
  function tokenExpr(ctx, tokenMeta) {
    return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) : literal(tokenMeta.value);
  }
  function depDef(ctx, dep) {
    var expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, ((dep.token)));
    var flags = 0;
    if (dep.isSkipSelf) {
      flags |= 1;
    }
    if (dep.isOptional) {
      flags |= 2;
    }
    if (dep.isValue) {
      flags |= 8;
    }
    return flags === 0 ? expr : literalArr([literal(flags), expr]);
  }
  function lifecycleHookToNodeFlag(lifecycleHook) {
    var nodeFlag = 0;
    switch (lifecycleHook) {
      case LifecycleHooks.AfterContentChecked:
        nodeFlag = 2097152;
        break;
      case LifecycleHooks.AfterContentInit:
        nodeFlag = 1048576;
        break;
      case LifecycleHooks.AfterViewChecked:
        nodeFlag = 8388608;
        break;
      case LifecycleHooks.AfterViewInit:
        nodeFlag = 4194304;
        break;
      case LifecycleHooks.DoCheck:
        nodeFlag = 262144;
        break;
      case LifecycleHooks.OnChanges:
        nodeFlag = 524288;
        break;
      case LifecycleHooks.OnDestroy:
        nodeFlag = 131072;
        break;
      case LifecycleHooks.OnInit:
        nodeFlag = 65536;
        break;
    }
    return nodeFlag;
  }
  function componentFactoryResolverProviderDef(reflector, ctx, flags, entryComponents) {
    var entryComponentFactories = entryComponents.map(function(entryComponent) {
      return ctx.importExpr(entryComponent.componentFactory);
    });
    var token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);
    var classMeta = {
      diDeps: [{
        isValue: true,
        value: literalArr(entryComponentFactories)
      }, {
        token: token,
        isSkipSelf: true,
        isOptional: true
      }, {token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef)}],
      lifecycleHooks: [],
      reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)
    };
    var _a = singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {
      token: token,
      multi: false,
      useClass: classMeta
    }),
        providerExpr = _a.providerExpr,
        providerFlags = _a.flags,
        depsExpr = _a.depsExpr;
    return {
      providerExpr: providerExpr,
      flags: providerFlags,
      depsExpr: depsExpr,
      tokenExpr: tokenExpr(ctx, token)
    };
  }
  var NgModuleCompileResult = (function() {
    function NgModuleCompileResult(ngModuleFactoryVar) {
      this.ngModuleFactoryVar = ngModuleFactoryVar;
    }
    return NgModuleCompileResult;
  }());
  var LOG_VAR = variable('_l');
  var NgModuleCompiler = (function() {
    function NgModuleCompiler(reflector) {
      this.reflector = reflector;
    }
    NgModuleCompiler.prototype.compile = function(ctx, ngModuleMeta, extraProviders) {
      var sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);
      var entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents;
      var bootstrapComponents = ngModuleMeta.bootstrapComponents;
      var providerParser = new NgModuleProviderAnalyzer(this.reflector, ngModuleMeta, extraProviders, sourceSpan);
      var providerDefs = [componentFactoryResolverProviderDef(this.reflector, ctx, 0, entryComponentFactories)].concat(providerParser.parse().map(function(provider) {
        return providerDef(ctx, provider);
      })).map(function(_a) {
        var providerExpr = _a.providerExpr,
            depsExpr = _a.depsExpr,
            flags = _a.flags,
            tokenExpr = _a.tokenExpr;
        return importExpr(Identifiers.moduleProviderDef).callFn([literal(flags), tokenExpr, providerExpr, depsExpr]);
      });
      var ngModuleDef = importExpr(Identifiers.moduleDef).callFn([literalArr(providerDefs)]);
      var ngModuleDefFactory = fn([new FnParam(((LOG_VAR.name)))], [new ReturnStatement(ngModuleDef)], INFERRED_TYPE);
      var ngModuleFactoryVar = identifierName(ngModuleMeta.type) + "NgFactory";
      this._createNgModuleFactory(ctx, ngModuleMeta.type.reference, importExpr(Identifiers.createModuleFactory).callFn([ctx.importExpr(ngModuleMeta.type.reference), literalArr(bootstrapComponents.map(function(id) {
        return ctx.importExpr(id.reference);
      })), ngModuleDefFactory]));
      if (ngModuleMeta.id) {
        var registerFactoryStmt = importExpr(Identifiers.RegisterModuleFactoryFn).callFn([literal(ngModuleMeta.id), variable(ngModuleFactoryVar)]).toStmt();
        ctx.statements.push(registerFactoryStmt);
      }
      return new NgModuleCompileResult(ngModuleFactoryVar);
    };
    NgModuleCompiler.prototype.createStub = function(ctx, ngModuleReference) {
      this._createNgModuleFactory(ctx, ngModuleReference, NULL_EXPR);
    };
    NgModuleCompiler.prototype._createNgModuleFactory = function(ctx, reference, value) {
      var ngModuleFactoryVar = identifierName({reference: reference}) + "NgFactory";
      var ngModuleFactoryStmt = variable(ngModuleFactoryVar).set(value).toDeclStmt(importType(Identifiers.NgModuleFactory, [((expressionType(ctx.importExpr(reference))))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]);
      ctx.statements.push(ngModuleFactoryStmt);
    };
    return NgModuleCompiler;
  }());
  NgModuleCompiler.decorators = [{type: CompilerInjectable}];
  NgModuleCompiler.ctorParameters = function() {
    return [{type: CompileReflector}];
  };
  var VERSION$1 = 3;
  var JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';
  var SourceMapGenerator = (function() {
    function SourceMapGenerator(file) {
      if (file === void 0) {
        file = null;
      }
      this.file = file;
      this.sourcesContent = new Map();
      this.lines = [];
      this.lastCol0 = 0;
      this.hasMappings = false;
    }
    SourceMapGenerator.prototype.addSource = function(url, content) {
      if (content === void 0) {
        content = null;
      }
      if (!this.sourcesContent.has(url)) {
        this.sourcesContent.set(url, content);
      }
      return this;
    };
    SourceMapGenerator.prototype.addLine = function() {
      this.lines.push([]);
      this.lastCol0 = 0;
      return this;
    };
    SourceMapGenerator.prototype.addMapping = function(col0, sourceUrl, sourceLine0, sourceCol0) {
      if (!this.currentLine) {
        throw new Error("A line must be added before mappings can be added");
      }
      if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {
        throw new Error("Unknown source file \"" + sourceUrl + "\"");
      }
      if (col0 == null) {
        throw new Error("The column in the generated code must be provided");
      }
      if (col0 < this.lastCol0) {
        throw new Error("Mapping should be added in output order");
      }
      if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {
        throw new Error("The source location must be provided when a source url is provided");
      }
      this.hasMappings = true;
      this.lastCol0 = col0;
      this.currentLine.push({
        col0: col0,
        sourceUrl: sourceUrl,
        sourceLine0: sourceLine0,
        sourceCol0: sourceCol0
      });
      return this;
    };
    Object.defineProperty(SourceMapGenerator.prototype, "currentLine", {
      get: function() {
        return this.lines.slice(-1)[0];
      },
      enumerable: true,
      configurable: true
    });
    SourceMapGenerator.prototype.toJSON = function() {
      var _this = this;
      if (!this.hasMappings) {
        return null;
      }
      var sourcesIndex = new Map();
      var sources = [];
      var sourcesContent = [];
      Array.from(this.sourcesContent.keys()).forEach(function(url, i) {
        sourcesIndex.set(url, i);
        sources.push(url);
        sourcesContent.push(_this.sourcesContent.get(url) || null);
      });
      var mappings = '';
      var lastCol0 = 0;
      var lastSourceIndex = 0;
      var lastSourceLine0 = 0;
      var lastSourceCol0 = 0;
      this.lines.forEach(function(segments) {
        lastCol0 = 0;
        mappings += segments.map(function(segment) {
          var segAsStr = toBase64VLQ(segment.col0 - lastCol0);
          lastCol0 = segment.col0;
          if (segment.sourceUrl != null) {
            segAsStr += toBase64VLQ(((sourcesIndex.get(segment.sourceUrl))) - lastSourceIndex);
            lastSourceIndex = ((sourcesIndex.get(segment.sourceUrl)));
            segAsStr += toBase64VLQ(((segment.sourceLine0)) - lastSourceLine0);
            lastSourceLine0 = ((segment.sourceLine0));
            segAsStr += toBase64VLQ(((segment.sourceCol0)) - lastSourceCol0);
            lastSourceCol0 = ((segment.sourceCol0));
          }
          return segAsStr;
        }).join(',');
        mappings += ';';
      });
      mappings = mappings.slice(0, -1);
      return {
        'file': this.file || '',
        'version': VERSION$1,
        'sourceRoot': '',
        'sources': sources,
        'sourcesContent': sourcesContent,
        'mappings': mappings
      };
    };
    SourceMapGenerator.prototype.toJsComment = function() {
      return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : '';
    };
    return SourceMapGenerator;
  }());
  function toBase64String(value) {
    var b64 = '';
    value = utf8Encode(value);
    for (var i = 0; i < value.length; ) {
      var i1 = value.charCodeAt(i++);
      var i2 = value.charCodeAt(i++);
      var i3 = value.charCodeAt(i++);
      b64 += toBase64Digit(i1 >> 2);
      b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));
      b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));
      b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);
    }
    return b64;
  }
  function toBase64VLQ(value) {
    value = value < 0 ? ((-value) << 1) + 1 : value << 1;
    var out = '';
    do {
      var digit = value & 31;
      value = value >> 5;
      if (value > 0) {
        digit = digit | 32;
      }
      out += toBase64Digit(digit);
    } while (value > 0);
    return out;
  }
  var B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  function toBase64Digit(value) {
    if (value < 0 || value >= 64) {
      throw new Error("Can only encode value in the range [0, 63]");
    }
    return B64_DIGITS[value];
  }
  var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
  var _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
  var _INDENT_WITH = '  ';
  var CATCH_ERROR_VAR$1 = variable('error', null, null);
  var CATCH_STACK_VAR$1 = variable('stack', null, null);
  var _EmittedLine = (function() {
    function _EmittedLine(indent) {
      this.indent = indent;
      this.partsLength = 0;
      this.parts = [];
      this.srcSpans = [];
    }
    return _EmittedLine;
  }());
  var EmitterVisitorContext = (function() {
    function EmitterVisitorContext(_indent) {
      this._indent = _indent;
      this._classes = [];
      this._preambleLineCount = 0;
      this._lines = [new _EmittedLine(_indent)];
    }
    EmitterVisitorContext.createRoot = function() {
      return new EmitterVisitorContext(0);
    };
    Object.defineProperty(EmitterVisitorContext.prototype, "_currentLine", {
      get: function() {
        return this._lines[this._lines.length - 1];
      },
      enumerable: true,
      configurable: true
    });
    EmitterVisitorContext.prototype.println = function(from, lastPart) {
      if (lastPart === void 0) {
        lastPart = '';
      }
      this.print(from || null, lastPart, true);
    };
    EmitterVisitorContext.prototype.lineIsEmpty = function() {
      return this._currentLine.parts.length === 0;
    };
    EmitterVisitorContext.prototype.lineLength = function() {
      return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;
    };
    EmitterVisitorContext.prototype.print = function(from, part, newLine) {
      if (newLine === void 0) {
        newLine = false;
      }
      if (part.length > 0) {
        this._currentLine.parts.push(part);
        this._currentLine.partsLength += part.length;
        this._currentLine.srcSpans.push(from && from.sourceSpan || null);
      }
      if (newLine) {
        this._lines.push(new _EmittedLine(this._indent));
      }
    };
    EmitterVisitorContext.prototype.removeEmptyLastLine = function() {
      if (this.lineIsEmpty()) {
        this._lines.pop();
      }
    };
    EmitterVisitorContext.prototype.incIndent = function() {
      this._indent++;
      if (this.lineIsEmpty()) {
        this._currentLine.indent = this._indent;
      }
    };
    EmitterVisitorContext.prototype.decIndent = function() {
      this._indent--;
      if (this.lineIsEmpty()) {
        this._currentLine.indent = this._indent;
      }
    };
    EmitterVisitorContext.prototype.pushClass = function(clazz) {
      this._classes.push(clazz);
    };
    EmitterVisitorContext.prototype.popClass = function() {
      return ((this._classes.pop()));
    };
    Object.defineProperty(EmitterVisitorContext.prototype, "currentClass", {
      get: function() {
        return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
      },
      enumerable: true,
      configurable: true
    });
    EmitterVisitorContext.prototype.toSource = function() {
      return this.sourceLines.map(function(l) {
        return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '';
      }).join('\n');
    };
    EmitterVisitorContext.prototype.toSourceMapGenerator = function(sourceFilePath, genFilePath, startsAtLine) {
      if (startsAtLine === void 0) {
        startsAtLine = 0;
      }
      var map = new SourceMapGenerator(genFilePath);
      var firstOffsetMapped = false;
      var mapFirstOffsetIfNeeded = function() {
        if (!firstOffsetMapped) {
          map.addSource(sourceFilePath, ' ').addMapping(0, sourceFilePath, 0, 0);
          firstOffsetMapped = true;
        }
      };
      for (var i = 0; i < startsAtLine; i++) {
        map.addLine();
        mapFirstOffsetIfNeeded();
      }
      this.sourceLines.forEach(function(line, lineIdx) {
        map.addLine();
        var spans = line.srcSpans;
        var parts = line.parts;
        var col0 = line.indent * _INDENT_WITH.length;
        var spanIdx = 0;
        while (spanIdx < spans.length && !spans[spanIdx]) {
          col0 += parts[spanIdx].length;
          spanIdx++;
        }
        if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {
          firstOffsetMapped = true;
        } else {
          mapFirstOffsetIfNeeded();
        }
        while (spanIdx < spans.length) {
          var span = ((spans[spanIdx]));
          var source = span.start.file;
          var sourceLine = span.start.line;
          var sourceCol = span.start.col;
          map.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);
          col0 += parts[spanIdx].length;
          spanIdx++;
          while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {
            col0 += parts[spanIdx].length;
            spanIdx++;
          }
        }
      });
      return map;
    };
    EmitterVisitorContext.prototype.setPreambleLineCount = function(count) {
      return this._preambleLineCount = count;
    };
    EmitterVisitorContext.prototype.spanOf = function(line, column) {
      var emittedLine = this._lines[line - this._preambleLineCount];
      if (emittedLine) {
        var columnsLeft = column - emittedLine.indent;
        for (var partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {
          var part = emittedLine.parts[partIndex];
          if (part.length > columnsLeft) {
            return emittedLine.srcSpans[partIndex];
          }
          columnsLeft -= part.length;
        }
      }
      return null;
    };
    Object.defineProperty(EmitterVisitorContext.prototype, "sourceLines", {
      get: function() {
        if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {
          return this._lines.slice(0, -1);
        }
        return this._lines;
      },
      enumerable: true,
      configurable: true
    });
    return EmitterVisitorContext;
  }());
  var AbstractEmitterVisitor = (function() {
    function AbstractEmitterVisitor(_escapeDollarInStrings) {
      this._escapeDollarInStrings = _escapeDollarInStrings;
    }
    AbstractEmitterVisitor.prototype.visitExpressionStmt = function(stmt, ctx) {
      stmt.expr.visitExpression(this, ctx);
      ctx.println(stmt, ';');
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReturnStmt = function(stmt, ctx) {
      ctx.print(stmt, "return ");
      stmt.value.visitExpression(this, ctx);
      ctx.println(stmt, ';');
      return null;
    };
    AbstractEmitterVisitor.prototype.visitCastExpr = function(ast, context) {};
    AbstractEmitterVisitor.prototype.visitDeclareClassStmt = function(stmt, ctx) {};
    AbstractEmitterVisitor.prototype.visitIfStmt = function(stmt, ctx) {
      ctx.print(stmt, "if (");
      stmt.condition.visitExpression(this, ctx);
      ctx.print(stmt, ") {");
      var hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;
      if (stmt.trueCase.length <= 1 && !hasElseCase) {
        ctx.print(stmt, " ");
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.removeEmptyLastLine();
        ctx.print(stmt, " ");
      } else {
        ctx.println();
        ctx.incIndent();
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.decIndent();
        if (hasElseCase) {
          ctx.println(stmt, "} else {");
          ctx.incIndent();
          this.visitAllStatements(stmt.falseCase, ctx);
          ctx.decIndent();
        }
      }
      ctx.println(stmt, "}");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitTryCatchStmt = function(stmt, ctx) {};
    AbstractEmitterVisitor.prototype.visitThrowStmt = function(stmt, ctx) {
      ctx.print(stmt, "throw ");
      stmt.error.visitExpression(this, ctx);
      ctx.println(stmt, ";");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitCommentStmt = function(stmt, ctx) {
      var lines = stmt.comment.split('\n');
      lines.forEach(function(line) {
        ctx.println(stmt, "// " + line);
      });
      return null;
    };
    AbstractEmitterVisitor.prototype.visitDeclareVarStmt = function(stmt, ctx) {};
    AbstractEmitterVisitor.prototype.visitWriteVarExpr = function(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print(expr, '(');
      }
      ctx.print(expr, expr.name + " = ");
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(expr, ')');
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print(expr, '(');
      }
      expr.receiver.visitExpression(this, ctx);
      ctx.print(expr, "[");
      expr.index.visitExpression(this, ctx);
      ctx.print(expr, "] = ");
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(expr, ')');
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitWritePropExpr = function(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print(expr, '(');
      }
      expr.receiver.visitExpression(this, ctx);
      ctx.print(expr, "." + expr.name + " = ");
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(expr, ')');
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function(expr, ctx) {
      expr.receiver.visitExpression(this, ctx);
      var name = expr.name;
      if (expr.builtin != null) {
        name = this.getBuiltinMethodName(expr.builtin);
        if (name == null) {
          return null;
        }
      }
      ctx.print(expr, "." + name + "(");
      this.visitAllExpressions(expr.args, ctx, ",");
      ctx.print(expr, ")");
      return null;
    };
    AbstractEmitterVisitor.prototype.getBuiltinMethodName = function(method) {};
    AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function(expr, ctx) {
      expr.fn.visitExpression(this, ctx);
      ctx.print(expr, "(");
      this.visitAllExpressions(expr.args, ctx, ',');
      ctx.print(expr, ")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReadVarExpr = function(ast, ctx) {
      var varName = ((ast.name));
      if (ast.builtin != null) {
        switch (ast.builtin) {
          case BuiltinVar.Super:
            varName = 'super';
            break;
          case BuiltinVar.This:
            varName = 'this';
            break;
          case BuiltinVar.CatchError:
            varName = ((CATCH_ERROR_VAR$1.name));
            break;
          case BuiltinVar.CatchStack:
            varName = ((CATCH_STACK_VAR$1.name));
            break;
          default:
            throw new Error("Unknown builtin variable " + ast.builtin);
        }
      }
      ctx.print(ast, varName);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitInstantiateExpr = function(ast, ctx) {
      ctx.print(ast, "new ");
      ast.classExpr.visitExpression(this, ctx);
      ctx.print(ast, "(");
      this.visitAllExpressions(ast.args, ctx, ',');
      ctx.print(ast, ")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralExpr = function(ast, ctx) {
      var value = ast.value;
      if (typeof value === 'string') {
        ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));
      } else {
        ctx.print(ast, "" + value);
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitExternalExpr = function(ast, ctx) {};
    AbstractEmitterVisitor.prototype.visitConditionalExpr = function(ast, ctx) {
      ctx.print(ast, "(");
      ast.condition.visitExpression(this, ctx);
      ctx.print(ast, '? ');
      ast.trueCase.visitExpression(this, ctx);
      ctx.print(ast, ': ');
      ((ast.falseCase)).visitExpression(this, ctx);
      ctx.print(ast, ")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitNotExpr = function(ast, ctx) {
      ctx.print(ast, '!');
      ast.condition.visitExpression(this, ctx);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitAssertNotNullExpr = function(ast, ctx) {
      ast.condition.visitExpression(this, ctx);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitFunctionExpr = function(ast, ctx) {};
    AbstractEmitterVisitor.prototype.visitDeclareFunctionStmt = function(stmt, context) {};
    AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function(ast, ctx) {
      var opStr;
      switch (ast.operator) {
        case BinaryOperator.Equals:
          opStr = '==';
          break;
        case BinaryOperator.Identical:
          opStr = '===';
          break;
        case BinaryOperator.NotEquals:
          opStr = '!=';
          break;
        case BinaryOperator.NotIdentical:
          opStr = '!==';
          break;
        case BinaryOperator.And:
          opStr = '&&';
          break;
        case BinaryOperator.Or:
          opStr = '||';
          break;
        case BinaryOperator.Plus:
          opStr = '+';
          break;
        case BinaryOperator.Minus:
          opStr = '-';
          break;
        case BinaryOperator.Divide:
          opStr = '/';
          break;
        case BinaryOperator.Multiply:
          opStr = '*';
          break;
        case BinaryOperator.Modulo:
          opStr = '%';
          break;
        case BinaryOperator.Lower:
          opStr = '<';
          break;
        case BinaryOperator.LowerEquals:
          opStr = '<=';
          break;
        case BinaryOperator.Bigger:
          opStr = '>';
          break;
        case BinaryOperator.BiggerEquals:
          opStr = '>=';
          break;
        default:
          throw new Error("Unknown operator " + ast.operator);
      }
      ctx.print(ast, "(");
      ast.lhs.visitExpression(this, ctx);
      ctx.print(ast, " " + opStr + " ");
      ast.rhs.visitExpression(this, ctx);
      ctx.print(ast, ")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReadPropExpr = function(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print(ast, ".");
      ctx.print(ast, ast.name);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReadKeyExpr = function(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print(ast, "[");
      ast.index.visitExpression(this, ctx);
      ctx.print(ast, "]");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function(ast, ctx) {
      ctx.print(ast, "[");
      this.visitAllExpressions(ast.entries, ctx, ',');
      ctx.print(ast, "]");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function(ast, ctx) {
      var _this = this;
      ctx.print(ast, "{");
      this.visitAllObjects(function(entry) {
        ctx.print(ast, escapeIdentifier(entry.key, _this._escapeDollarInStrings, entry.quoted) + ":");
        entry.value.visitExpression(_this, ctx);
      }, ast.entries, ctx, ',');
      ctx.print(ast, "}");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitCommaExpr = function(ast, ctx) {
      ctx.print(ast, '(');
      this.visitAllExpressions(ast.parts, ctx, ',');
      ctx.print(ast, ')');
      return null;
    };
    AbstractEmitterVisitor.prototype.visitAllExpressions = function(expressions, ctx, separator) {
      var _this = this;
      this.visitAllObjects(function(expr) {
        return expr.visitExpression(_this, ctx);
      }, expressions, ctx, separator);
    };
    AbstractEmitterVisitor.prototype.visitAllObjects = function(handler, expressions, ctx, separator) {
      var incrementedIndent = false;
      for (var i = 0; i < expressions.length; i++) {
        if (i > 0) {
          if (ctx.lineLength() > 80) {
            ctx.print(null, separator, true);
            if (!incrementedIndent) {
              ctx.incIndent();
              ctx.incIndent();
              incrementedIndent = true;
            }
          } else {
            ctx.print(null, separator, false);
          }
        }
        handler(expressions[i]);
      }
      if (incrementedIndent) {
        ctx.decIndent();
        ctx.decIndent();
      }
    };
    AbstractEmitterVisitor.prototype.visitAllStatements = function(statements, ctx) {
      var _this = this;
      statements.forEach(function(stmt) {
        return stmt.visitStatement(_this, ctx);
      });
    };
    return AbstractEmitterVisitor;
  }());
  function escapeIdentifier(input, escapeDollar, alwaysQuote) {
    if (alwaysQuote === void 0) {
      alwaysQuote = true;
    }
    if (input == null) {
      return null;
    }
    var body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function() {
      var match = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        match[_i] = arguments[_i];
      }
      if (match[0] == '$') {
        return escapeDollar ? '\\$' : '$';
      } else if (match[0] == '\n') {
        return '\\n';
      } else if (match[0] == '\r') {
        return '\\r';
      } else {
        return "\\" + match[0];
      }
    });
    var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
    return requiresQuotes ? "'" + body + "'" : body;
  }
  function _createIndent(count) {
    var res = '';
    for (var i = 0; i < count; i++) {
      res += _INDENT_WITH;
    }
    return res;
  }
  function debugOutputAstAsTypeScript(ast) {
    var converter = new _TsEmitterVisitor();
    var ctx = EmitterVisitorContext.createRoot();
    var asts = Array.isArray(ast) ? ast : [ast];
    asts.forEach(function(ast) {
      if (ast instanceof Statement) {
        ast.visitStatement(converter, ctx);
      } else if (ast instanceof Expression) {
        ast.visitExpression(converter, ctx);
      } else if (ast instanceof Type$1) {
        ast.visitType(converter, ctx);
      } else {
        throw new Error("Don't know how to print debug info for " + ast);
      }
    });
    return ctx.toSource();
  }
  var TypeScriptEmitter = (function() {
    function TypeScriptEmitter() {}
    TypeScriptEmitter.prototype.emitStatementsAndContext = function(srcFilePath, genFilePath, stmts, preamble, emitSourceMaps) {
      if (preamble === void 0) {
        preamble = '';
      }
      if (emitSourceMaps === void 0) {
        emitSourceMaps = true;
      }
      var converter = new _TsEmitterVisitor();
      var ctx = EmitterVisitorContext.createRoot();
      converter.visitAllStatements(stmts, ctx);
      var preambleLines = preamble ? preamble.split('\n') : [];
      converter.reexports.forEach(function(reexports, exportedModuleName) {
        var reexportsCode = reexports.map(function(reexport) {
          return reexport.name + " as " + reexport.as;
        }).join(',');
        preambleLines.push("export {" + reexportsCode + "} from '" + exportedModuleName + "';");
      });
      converter.importsWithPrefixes.forEach(function(prefix, importedModuleName) {
        preambleLines.push("imp" + ("ort * as " + prefix + " from '" + importedModuleName + "';"));
      });
      var sm = emitSourceMaps ? ctx.toSourceMapGenerator(srcFilePath, genFilePath, preambleLines.length).toJsComment() : '';
      var lines = preambleLines.concat([ctx.toSource(), sm]);
      if (sm) {
        lines.push('');
      }
      ctx.setPreambleLineCount(preambleLines.length);
      return {
        sourceText: lines.join('\n'),
        context: ctx
      };
    };
    TypeScriptEmitter.prototype.emitStatements = function(srcFilePath, genFilePath, stmts, preamble) {
      if (preamble === void 0) {
        preamble = '';
      }
      return this.emitStatementsAndContext(srcFilePath, genFilePath, stmts, preamble).sourceText;
    };
    return TypeScriptEmitter;
  }());
  var _TsEmitterVisitor = (function(_super) {
    __extends(_TsEmitterVisitor, _super);
    function _TsEmitterVisitor() {
      var _this = _super.call(this, false) || this;
      _this.typeExpression = 0;
      _this.importsWithPrefixes = new Map();
      _this.reexports = new Map();
      return _this;
    }
    _TsEmitterVisitor.prototype.visitType = function(t, ctx, defaultType) {
      if (defaultType === void 0) {
        defaultType = 'any';
      }
      if (t) {
        this.typeExpression++;
        t.visitType(this, ctx);
        this.typeExpression--;
      } else {
        ctx.print(null, defaultType);
      }
    };
    _TsEmitterVisitor.prototype.visitLiteralExpr = function(ast, ctx) {
      var value = ast.value;
      if (value == null && ast.type != INFERRED_TYPE) {
        ctx.print(ast, "(" + value + " as any)");
        return null;
      }
      return _super.prototype.visitLiteralExpr.call(this, ast, ctx);
    };
    _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function(ast, ctx) {
      if (ast.entries.length === 0) {
        ctx.print(ast, '(');
      }
      var result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);
      if (ast.entries.length === 0) {
        ctx.print(ast, ' as any[])');
      }
      return result;
    };
    _TsEmitterVisitor.prototype.visitExternalExpr = function(ast, ctx) {
      this._visitIdentifier(ast.value, ast.typeParams, ctx);
      return null;
    };
    _TsEmitterVisitor.prototype.visitAssertNotNullExpr = function(ast, ctx) {
      var result = _super.prototype.visitAssertNotNullExpr.call(this, ast, ctx);
      ctx.print(ast, '!');
      return result;
    };
    _TsEmitterVisitor.prototype.visitDeclareVarStmt = function(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported) && stmt.value instanceof ExternalExpr && !stmt.type) {
        var _a = stmt.value.value,
            name = _a.name,
            moduleName = _a.moduleName;
        if (moduleName) {
          var reexports = this.reexports.get(moduleName);
          if (!reexports) {
            reexports = [];
            this.reexports.set(moduleName, reexports);
          }
          reexports.push({
            name: ((name)),
            as: stmt.name
          });
          return null;
        }
      }
      if (stmt.hasModifier(StmtModifier.Exported)) {
        ctx.print(stmt, "export ");
      }
      if (stmt.hasModifier(StmtModifier.Final)) {
        ctx.print(stmt, "const");
      } else {
        ctx.print(stmt, "var");
      }
      ctx.print(stmt, " " + stmt.name);
      this._printColonType(stmt.type, ctx);
      ctx.print(stmt, " = ");
      stmt.value.visitExpression(this, ctx);
      ctx.println(stmt, ";");
      return null;
    };
    _TsEmitterVisitor.prototype.visitCastExpr = function(ast, ctx) {
      ctx.print(ast, "(<");
      ((ast.type)).visitType(this, ctx);
      ctx.print(ast, ">");
      ast.value.visitExpression(this, ctx);
      ctx.print(ast, ")");
      return null;
    };
    _TsEmitterVisitor.prototype.visitInstantiateExpr = function(ast, ctx) {
      ctx.print(ast, "new ");
      this.typeExpression++;
      ast.classExpr.visitExpression(this, ctx);
      this.typeExpression--;
      ctx.print(ast, "(");
      this.visitAllExpressions(ast.args, ctx, ',');
      ctx.print(ast, ")");
      return null;
    };
    _TsEmitterVisitor.prototype.visitDeclareClassStmt = function(stmt, ctx) {
      var _this = this;
      ctx.pushClass(stmt);
      if (stmt.hasModifier(StmtModifier.Exported)) {
        ctx.print(stmt, "export ");
      }
      ctx.print(stmt, "class " + stmt.name);
      if (stmt.parent != null) {
        ctx.print(stmt, " extends ");
        this.typeExpression++;
        stmt.parent.visitExpression(this, ctx);
        this.typeExpression--;
      }
      ctx.println(stmt, " {");
      ctx.incIndent();
      stmt.fields.forEach(function(field) {
        return _this._visitClassField(field, ctx);
      });
      if (stmt.constructorMethod != null) {
        this._visitClassConstructor(stmt, ctx);
      }
      stmt.getters.forEach(function(getter) {
        return _this._visitClassGetter(getter, ctx);
      });
      stmt.methods.forEach(function(method) {
        return _this._visitClassMethod(method, ctx);
      });
      ctx.decIndent();
      ctx.println(stmt, "}");
      ctx.popClass();
      return null;
    };
    _TsEmitterVisitor.prototype._visitClassField = function(field, ctx) {
      if (field.hasModifier(StmtModifier.Private)) {
        ctx.print(null, "/*private*/ ");
      }
      ctx.print(null, field.name);
      this._printColonType(field.type, ctx);
      ctx.println(null, ";");
    };
    _TsEmitterVisitor.prototype._visitClassGetter = function(getter, ctx) {
      if (getter.hasModifier(StmtModifier.Private)) {
        ctx.print(null, "private ");
      }
      ctx.print(null, "get " + getter.name + "()");
      this._printColonType(getter.type, ctx);
      ctx.println(null, " {");
      ctx.incIndent();
      this.visitAllStatements(getter.body, ctx);
      ctx.decIndent();
      ctx.println(null, "}");
    };
    _TsEmitterVisitor.prototype._visitClassConstructor = function(stmt, ctx) {
      ctx.print(stmt, "constructor(");
      this._visitParams(stmt.constructorMethod.params, ctx);
      ctx.println(stmt, ") {");
      ctx.incIndent();
      this.visitAllStatements(stmt.constructorMethod.body, ctx);
      ctx.decIndent();
      ctx.println(stmt, "}");
    };
    _TsEmitterVisitor.prototype._visitClassMethod = function(method, ctx) {
      if (method.hasModifier(StmtModifier.Private)) {
        ctx.print(null, "private ");
      }
      ctx.print(null, method.name + "(");
      this._visitParams(method.params, ctx);
      ctx.print(null, ")");
      this._printColonType(method.type, ctx, 'void');
      ctx.println(null, " {");
      ctx.incIndent();
      this.visitAllStatements(method.body, ctx);
      ctx.decIndent();
      ctx.println(null, "}");
    };
    _TsEmitterVisitor.prototype.visitFunctionExpr = function(ast, ctx) {
      ctx.print(ast, "(");
      this._visitParams(ast.params, ctx);
      ctx.print(ast, ")");
      this._printColonType(ast.type, ctx, 'void');
      ctx.println(ast, " => {");
      ctx.incIndent();
      this.visitAllStatements(ast.statements, ctx);
      ctx.decIndent();
      ctx.print(ast, "}");
      return null;
    };
    _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported)) {
        ctx.print(stmt, "export ");
      }
      ctx.print(stmt, "function " + stmt.name + "(");
      this._visitParams(stmt.params, ctx);
      ctx.print(stmt, ")");
      this._printColonType(stmt.type, ctx, 'void');
      ctx.println(stmt, " {");
      ctx.incIndent();
      this.visitAllStatements(stmt.statements, ctx);
      ctx.decIndent();
      ctx.println(stmt, "}");
      return null;
    };
    _TsEmitterVisitor.prototype.visitTryCatchStmt = function(stmt, ctx) {
      ctx.println(stmt, "try {");
      ctx.incIndent();
      this.visitAllStatements(stmt.bodyStmts, ctx);
      ctx.decIndent();
      ctx.println(stmt, "} catch (" + CATCH_ERROR_VAR$1.name + ") {");
      ctx.incIndent();
      var catchStmts = [(CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack', null)).toDeclStmt(null, [StmtModifier.Final]))].concat(stmt.catchStmts);
      this.visitAllStatements(catchStmts, ctx);
      ctx.decIndent();
      ctx.println(stmt, "}");
      return null;
    };
    _TsEmitterVisitor.prototype.visitBuiltintType = function(type, ctx) {
      var typeStr;
      switch (type.name) {
        case BuiltinTypeName.Bool:
          typeStr = 'boolean';
          break;
        case BuiltinTypeName.Dynamic:
          typeStr = 'any';
          break;
        case BuiltinTypeName.Function:
          typeStr = 'Function';
          break;
        case BuiltinTypeName.Number:
          typeStr = 'number';
          break;
        case BuiltinTypeName.Int:
          typeStr = 'number';
          break;
        case BuiltinTypeName.String:
          typeStr = 'string';
          break;
        default:
          throw new Error("Unsupported builtin type " + type.name);
      }
      ctx.print(null, typeStr);
      return null;
    };
    _TsEmitterVisitor.prototype.visitExpressionType = function(ast, ctx) {
      ast.value.visitExpression(this, ctx);
      return null;
    };
    _TsEmitterVisitor.prototype.visitArrayType = function(type, ctx) {
      this.visitType(type.of, ctx);
      ctx.print(null, "[]");
      return null;
    };
    _TsEmitterVisitor.prototype.visitMapType = function(type, ctx) {
      ctx.print(null, "{[key: string]:");
      this.visitType(type.valueType, ctx);
      ctx.print(null, "}");
      return null;
    };
    _TsEmitterVisitor.prototype.getBuiltinMethodName = function(method) {
      var name;
      switch (method) {
        case BuiltinMethod.ConcatArray:
          name = 'concat';
          break;
        case BuiltinMethod.SubscribeObservable:
          name = 'subscribe';
          break;
        case BuiltinMethod.Bind:
          name = 'bind';
          break;
        default:
          throw new Error("Unknown builtin method: " + method);
      }
      return name;
    };
    _TsEmitterVisitor.prototype._visitParams = function(params, ctx) {
      var _this = this;
      this.visitAllObjects(function(param) {
        ctx.print(null, param.name);
        _this._printColonType(param.type, ctx);
      }, params, ctx, ',');
    };
    _TsEmitterVisitor.prototype._visitIdentifier = function(value, typeParams, ctx) {
      var _this = this;
      var name = value.name,
          moduleName = value.moduleName;
      if (moduleName) {
        var prefix = this.importsWithPrefixes.get(moduleName);
        if (prefix == null) {
          prefix = "i" + this.importsWithPrefixes.size;
          this.importsWithPrefixes.set(moduleName, prefix);
        }
        ctx.print(null, prefix + ".");
      }
      ctx.print(null, ((name)));
      if (this.typeExpression > 0) {
        var suppliedParameters = typeParams || [];
        if (suppliedParameters.length > 0) {
          ctx.print(null, "<");
          this.visitAllObjects(function(type) {
            return type.visitType(_this, ctx);
          }, ((typeParams)), ctx, ',');
          ctx.print(null, ">");
        }
      }
    };
    _TsEmitterVisitor.prototype._printColonType = function(type, ctx, defaultType) {
      if (type !== INFERRED_TYPE) {
        ctx.print(null, ':');
        this.visitType(type, ctx, defaultType);
      }
    };
    return _TsEmitterVisitor;
  }(AbstractEmitterVisitor));
  var SECURITY_SCHEMA = {};
  function registerContext(ctx, specs) {
    for (var _i = 0,
        specs_1 = specs; _i < specs_1.length; _i++) {
      var spec = specs_1[_i];
      SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
    }
  }
  registerContext(_angular_core.SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);
  registerContext(_angular_core.SecurityContext.STYLE, ['*|style']);
  registerContext(_angular_core.SecurityContext.URL, ['*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href', 'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action', 'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite', 'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src']);
  registerContext(_angular_core.SecurityContext.RESOURCE_URL, ['applet|code', 'applet|codebase', 'base|href', 'embed|src', 'frame|src', 'head|profile', 'html|manifest', 'iframe|src', 'link|href', 'media|src', 'object|codebase', 'object|data', 'script|src']);
  var BOOLEAN = 'boolean';
  var NUMBER = 'number';
  var STRING = 'string';
  var OBJECT = 'object';
  var SCHEMA = ['[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' + ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored', '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume', ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username', 'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username', 'audio^media|', 'br^[HTMLElement]|clear', 'base^[HTMLElement]|href,target', 'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas^[HTMLElement]|#height,#width', 'content^[HTMLElement]|select', 'dl^[HTMLElement]|!compact', 'datalist^[HTMLElement]|', 'details^[HTMLElement]|!open', 'dialog^[HTMLElement]|!open,returnValue', 'dir^[HTMLElement]|!compact', 'div^[HTMLElement]|align', 'embed^[HTMLElement]|align,height,name,src,type,width', 'fieldset^[HTMLElement]|!disabled,name', 'font^[HTMLElement]|color,face,size', 'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr^[HTMLElement]|align,color,!noShade,size,width', 'head^[HTMLElement]|', 'h1,h2,h3,h4,h5,h6^[HTMLElement]|align', 'html^[HTMLElement]|version', 'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width', 'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width', 'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'li^[HTMLElement]|type,#value', 'label^[HTMLElement]|htmlFor', 'legend^[HTMLElement]|align', 'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type', 'map^[HTMLElement]|name', 'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu^[HTMLElement]|!compact', 'meta^[HTMLElement]|content,httpEquiv,name,scheme', 'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value', 'ins,del^[HTMLElement]|cite,dateTime', 'ol^[HTMLElement]|!compact,!reversed,#start,type', 'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup^[HTMLElement]|!disabled,label', 'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value', 'output^[HTMLElement]|defaultValue,%htmlFor,name,value', 'p^[HTMLElement]|align', 'param^[HTMLElement]|name,type,value,valueType', 'picture^[HTMLElement]|', 'pre^[HTMLElement]|#width', 'progress^[HTMLElement]|#max,#value', 'q,blockquote,cite^[HTMLElement]|', 'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type', 'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'shadow^[HTMLElement]|', 'slot^[HTMLElement]|name', 'source^[HTMLElement]|media,sizes,src,srcset,type', 'span^[HTMLElement]|', 'style^[HTMLElement]|!disabled,media,type', 'caption^[HTMLElement]|align', 'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width', 'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign', 'template^[HTMLElement]|', 'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'title^[HTMLElement]|text', 'track^[HTMLElement]|!default,kind,label,src,srclang', 'ul^[HTMLElement]|!compact,type', 'unknown^[HTMLElement]|', 'video^media|#height,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan', 'data^[HTMLElement]|value', 'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name', 'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default', 'summary^[HTMLElement]|', 'time^[HTMLElement]|dateTime', ':svg:cursor^:svg:|'];
  var _ATTR_TO_PROP = {
    'class': 'className',
    'for': 'htmlFor',
    'formaction': 'formAction',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex'
  };
  var DomElementSchemaRegistry = (function(_super) {
    __extends(DomElementSchemaRegistry, _super);
    function DomElementSchemaRegistry() {
      var _this = _super.call(this) || this;
      _this._schema = {};
      SCHEMA.forEach(function(encodedType) {
        var type = {};
        var _a = encodedType.split('|'),
            strType = _a[0],
            strProperties = _a[1];
        var properties = strProperties.split(',');
        var _b = strType.split('^'),
            typeNames = _b[0],
            superName = _b[1];
        typeNames.split(',').forEach(function(tag) {
          return _this._schema[tag.toLowerCase()] = type;
        });
        var superType = superName && _this._schema[superName.toLowerCase()];
        if (superType) {
          Object.keys(superType).forEach(function(prop) {
            type[prop] = superType[prop];
          });
        }
        properties.forEach(function(property) {
          if (property.length > 0) {
            switch (property[0]) {
              case '*':
                break;
              case '!':
                type[property.substring(1)] = BOOLEAN;
                break;
              case '#':
                type[property.substring(1)] = NUMBER;
                break;
              case '%':
                type[property.substring(1)] = OBJECT;
                break;
              default:
                type[property] = STRING;
            }
          }
        });
      });
      return _this;
    }
    DomElementSchemaRegistry.prototype.hasProperty = function(tagName, propName, schemaMetas) {
      if (schemaMetas.some(function(schema) {
        return schema.name === _angular_core.NO_ERRORS_SCHEMA.name;
      })) {
        return true;
      }
      if (tagName.indexOf('-') > -1) {
        if (isNgContainer(tagName) || isNgContent(tagName)) {
          return false;
        }
        if (schemaMetas.some(function(schema) {
          return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name;
        })) {
          return true;
        }
      }
      var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];
      return !!elementProperties[propName];
    };
    DomElementSchemaRegistry.prototype.hasElement = function(tagName, schemaMetas) {
      if (schemaMetas.some(function(schema) {
        return schema.name === _angular_core.NO_ERRORS_SCHEMA.name;
      })) {
        return true;
      }
      if (tagName.indexOf('-') > -1) {
        if (isNgContainer(tagName) || isNgContent(tagName)) {
          return true;
        }
        if (schemaMetas.some(function(schema) {
          return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name;
        })) {
          return true;
        }
      }
      return !!this._schema[tagName.toLowerCase()];
    };
    DomElementSchemaRegistry.prototype.securityContext = function(tagName, propName, isAttribute) {
      if (isAttribute) {
        propName = this.getMappedPropName(propName);
      }
      tagName = tagName.toLowerCase();
      propName = propName.toLowerCase();
      var ctx = SECURITY_SCHEMA[tagName + '|' + propName];
      if (ctx) {
        return ctx;
      }
      ctx = SECURITY_SCHEMA['*|' + propName];
      return ctx ? ctx : _angular_core.SecurityContext.NONE;
    };
    DomElementSchemaRegistry.prototype.getMappedPropName = function(propName) {
      return _ATTR_TO_PROP[propName] || propName;
    };
    DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function() {
      return 'ng-component';
    };
    DomElementSchemaRegistry.prototype.validateProperty = function(name) {
      if (name.toLowerCase().startsWith('on')) {
        var msg = "Binding to event property '" + name + "' is disallowed for security reasons, " + ("please use (" + name.slice(2) + ")=...") + ("\nIf '" + name + "' is a directive input, make sure the directive is imported by the") + " current module.";
        return {
          error: true,
          msg: msg
        };
      } else {
        return {error: false};
      }
    };
    DomElementSchemaRegistry.prototype.validateAttribute = function(name) {
      if (name.toLowerCase().startsWith('on')) {
        var msg = "Binding to event attribute '" + name + "' is disallowed for security reasons, " + ("please use (" + name.slice(2) + ")=...");
        return {
          error: true,
          msg: msg
        };
      } else {
        return {error: false};
      }
    };
    DomElementSchemaRegistry.prototype.allKnownElementNames = function() {
      return Object.keys(this._schema);
    };
    DomElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function(propName) {
      return dashCaseToCamelCase(propName);
    };
    DomElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function(camelCaseProp, userProvidedProp, val) {
      var unit = '';
      var strVal = val.toString().trim();
      var errorMsg = ((null));
      if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {
        if (typeof val === 'number') {
          unit = 'px';
        } else {
          var valAndSuffixMatch = val.match(/^[+-]?[\d\.]+([a-z]*)$/);
          if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
            errorMsg = "Please provide a CSS unit value for " + userProvidedProp + ":" + val;
          }
        }
      }
      return {
        error: errorMsg,
        value: strVal + unit
      };
    };
    return DomElementSchemaRegistry;
  }(ElementSchemaRegistry));
  DomElementSchemaRegistry.decorators = [{type: CompilerInjectable}];
  DomElementSchemaRegistry.ctorParameters = function() {
    return [];
  };
  function _isPixelDimensionStyle(prop) {
    switch (prop) {
      case 'width':
      case 'height':
      case 'minWidth':
      case 'minHeight':
      case 'maxWidth':
      case 'maxHeight':
      case 'left':
      case 'top':
      case 'bottom':
      case 'right':
      case 'fontSize':
      case 'outlineWidth':
      case 'outlineOffset':
      case 'paddingTop':
      case 'paddingLeft':
      case 'paddingBottom':
      case 'paddingRight':
      case 'marginTop':
      case 'marginLeft':
      case 'marginBottom':
      case 'marginRight':
      case 'borderRadius':
      case 'borderWidth':
      case 'borderTopWidth':
      case 'borderLeftWidth':
      case 'borderRightWidth':
      case 'borderBottomWidth':
      case 'textIndent':
        return true;
      default:
        return false;
    }
  }
  var ShadowCss = (function() {
    function ShadowCss() {
      this.strictStyling = true;
    }
    ShadowCss.prototype.shimCssText = function(cssText, selector, hostSelector) {
      if (hostSelector === void 0) {
        hostSelector = '';
      }
      var sourceMappingUrl = extractSourceMappingUrl(cssText);
      cssText = stripComments(cssText);
      cssText = this._insertDirectives(cssText);
      return this._scopeCssText(cssText, selector, hostSelector) + sourceMappingUrl;
    };
    ShadowCss.prototype._insertDirectives = function(cssText) {
      cssText = this._insertPolyfillDirectivesInCssText(cssText);
      return this._insertPolyfillRulesInCssText(cssText);
    };
    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function(cssText) {
      return cssText.replace(_cssContentNextSelectorRe, function() {
        var m = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          m[_i] = arguments[_i];
        }
        return m[2] + '{';
      });
    };
    ShadowCss.prototype._insertPolyfillRulesInCssText = function(cssText) {
      return cssText.replace(_cssContentRuleRe, function() {
        var m = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          m[_i] = arguments[_i];
        }
        var rule = m[0].replace(m[1], '').replace(m[2], '');
        return m[4] + rule;
      });
    };
    ShadowCss.prototype._scopeCssText = function(cssText, scopeSelector, hostSelector) {
      var unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
      cssText = this._insertPolyfillHostInCssText(cssText);
      cssText = this._convertColonHost(cssText);
      cssText = this._convertColonHostContext(cssText);
      cssText = this._convertShadowDOMSelectors(cssText);
      if (scopeSelector) {
        cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
      }
      cssText = cssText + '\n' + unscopedRules;
      return cssText.trim();
    };
    ShadowCss.prototype._extractUnscopedRulesFromCssText = function(cssText) {
      var r = '';
      var m;
      _cssContentUnscopedRuleRe.lastIndex = 0;
      while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
        var rule = m[0].replace(m[2], '').replace(m[1], m[4]);
        r += rule + '\n\n';
      }
      return r;
    };
    ShadowCss.prototype._convertColonHost = function(cssText) {
      return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
    };
    ShadowCss.prototype._convertColonHostContext = function(cssText) {
      return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
    };
    ShadowCss.prototype._convertColonRule = function(cssText, regExp, partReplacer) {
      return cssText.replace(regExp, function() {
        var m = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          m[_i] = arguments[_i];
        }
        if (m[2]) {
          var parts = m[2].split(',');
          var r = [];
          for (var i = 0; i < parts.length; i++) {
            var p = parts[i].trim();
            if (!p)
              break;
            r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
          }
          return r.join(',');
        } else {
          return _polyfillHostNoCombinator + m[3];
        }
      });
    };
    ShadowCss.prototype._colonHostContextPartReplacer = function(host, part, suffix) {
      if (part.indexOf(_polyfillHost) > -1) {
        return this._colonHostPartReplacer(host, part, suffix);
      } else {
        return host + part + suffix + ', ' + part + ' ' + host + suffix;
      }
    };
    ShadowCss.prototype._colonHostPartReplacer = function(host, part, suffix) {
      return host + part.replace(_polyfillHost, '') + suffix;
    };
    ShadowCss.prototype._convertShadowDOMSelectors = function(cssText) {
      return _shadowDOMSelectorsRe.reduce(function(result, pattern) {
        return result.replace(pattern, ' ');
      }, cssText);
    };
    ShadowCss.prototype._scopeSelectors = function(cssText, scopeSelector, hostSelector) {
      var _this = this;
      return processRules(cssText, function(rule) {
        var selector = rule.selector;
        var content = rule.content;
        if (rule.selector[0] != '@') {
          selector = _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);
        } else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') || rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
          content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);
        }
        return new CssRule(selector, content);
      });
    };
    ShadowCss.prototype._scopeSelector = function(selector, scopeSelector, hostSelector, strict) {
      var _this = this;
      return selector.split(',').map(function(part) {
        return part.trim().split(_shadowDeepSelectors);
      }).map(function(deepParts) {
        var shallowPart = deepParts[0],
            otherParts = deepParts.slice(1);
        var applyScope = function(shallowPart) {
          if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {
            return strict ? _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) : _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
          } else {
            return shallowPart;
          }
        };
        return [applyScope(shallowPart)].concat(otherParts).join(' ');
      }).join(', ');
    };
    ShadowCss.prototype._selectorNeedsScoping = function(selector, scopeSelector) {
      var re = this._makeScopeMatcher(scopeSelector);
      return !re.test(selector);
    };
    ShadowCss.prototype._makeScopeMatcher = function(scopeSelector) {
      var lre = /\[/g;
      var rre = /\]/g;
      scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
      return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
    };
    ShadowCss.prototype._applySelectorScope = function(selector, scopeSelector, hostSelector) {
      return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
    };
    ShadowCss.prototype._applySimpleSelectorScope = function(selector, scopeSelector, hostSelector) {
      _polyfillHostRe.lastIndex = 0;
      if (_polyfillHostRe.test(selector)) {
        var replaceBy_1 = this.strictStyling ? "[" + hostSelector + "]" : scopeSelector;
        return selector.replace(_polyfillHostNoCombinatorRe, function(hnc, selector) {
          return selector.replace(/([^:]*)(:*)(.*)/, function(_, before, colon, after) {
            return before + replaceBy_1 + colon + after;
          });
        }).replace(_polyfillHostRe, replaceBy_1 + ' ');
      }
      return scopeSelector + ' ' + selector;
    };
    ShadowCss.prototype._applyStrictSelectorScope = function(selector, scopeSelector, hostSelector) {
      var _this = this;
      var isRe = /\[is=([^\]]*)\]/g;
      scopeSelector = scopeSelector.replace(isRe, function(_) {
        var parts = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          parts[_i - 1] = arguments[_i];
        }
        return parts[0];
      });
      var attrName = '[' + scopeSelector + ']';
      var _scopeSelectorPart = function(p) {
        var scopedP = p.trim();
        if (!scopedP) {
          return '';
        }
        if (p.indexOf(_polyfillHostNoCombinator) > -1) {
          scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
        } else {
          var t = p.replace(_polyfillHostRe, '');
          if (t.length > 0) {
            var matches = t.match(/([^:]*)(:*)(.*)/);
            if (matches) {
              scopedP = matches[1] + attrName + matches[2] + matches[3];
            }
          }
        }
        return scopedP;
      };
      var safeContent = new SafeSelector(selector);
      selector = safeContent.content();
      var scopedSelector = '';
      var startIndex = 0;
      var res;
      var sep = /( |>|\+|~(?!=))\s*/g;
      var scopeAfter = selector.indexOf(_polyfillHostNoCombinator);
      while ((res = sep.exec(selector)) !== null) {
        var separator = res[1];
        var part = selector.slice(startIndex, res.index).trim();
        var scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;
        scopedSelector += scopedPart + " " + separator + " ";
        startIndex = sep.lastIndex;
      }
      scopedSelector += _scopeSelectorPart(selector.substring(startIndex));
      return safeContent.restore(scopedSelector);
    };
    ShadowCss.prototype._insertPolyfillHostInCssText = function(selector) {
      return selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost);
    };
    return ShadowCss;
  }());
  var SafeSelector = (function() {
    function SafeSelector(selector) {
      var _this = this;
      this.placeholders = [];
      this.index = 0;
      selector = selector.replace(/(\[[^\]]*\])/g, function(_, keep) {
        var replaceBy = "__ph-" + _this.index + "__";
        _this.placeholders.push(keep);
        _this.index++;
        return replaceBy;
      });
      this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, function(_, pseudo, exp) {
        var replaceBy = "__ph-" + _this.index + "__";
        _this.placeholders.push(exp);
        _this.index++;
        return pseudo + replaceBy;
      });
    }
    SafeSelector.prototype.restore = function(content) {
      var _this = this;
      return content.replace(/__ph-(\d+)__/g, function(ph, index) {
        return _this.placeholders[+index];
      });
    };
    SafeSelector.prototype.content = function() {
      return this._content;
    };
    return SafeSelector;
  }());
  var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
  var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  var _polyfillHost = '-shadowcsshost';
  var _polyfillHostContext = '-shadowcsscontext';
  var _parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';
  var _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
  var _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
  var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
  var _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
  var _shadowDOMSelectorsRe = [/::shadow/g, /::content/g, /\/shadow-deep\//g, /\/shadow\//g];
  var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
  var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
  var _polyfillHostRe = /-shadowcsshost/gim;
  var _colonHostRe = /:host/gim;
  var _colonHostContextRe = /:host-context/gim;
  var _commentRe = /\/\*\s*[\s\S]*?\*\//g;
  function stripComments(input) {
    return input.replace(_commentRe, '');
  }
  var _sourceMappingUrlRe = /\/\*\s*#\s*sourceMappingURL=[\s\S]+?\*\//;
  function extractSourceMappingUrl(input) {
    var matcher = input.match(_sourceMappingUrlRe);
    return matcher ? matcher[0] : '';
  }
  var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
  var _curlyRe = /([{}])/g;
  var OPEN_CURLY = '{';
  var CLOSE_CURLY = '}';
  var BLOCK_PLACEHOLDER = '%BLOCK%';
  var CssRule = (function() {
    function CssRule(selector, content) {
      this.selector = selector;
      this.content = content;
    }
    return CssRule;
  }());
  function processRules(input, ruleCallback) {
    var inputWithEscapedBlocks = escapeBlocks(input);
    var nextBlockIndex = 0;
    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function() {
      var m = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        m[_i] = arguments[_i];
      }
      var selector = m[2];
      var content = '';
      var suffix = m[4];
      var contentPrefix = '';
      if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
        content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
        suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
        contentPrefix = '{';
      }
      var rule = ruleCallback(new CssRule(selector, content));
      return "" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;
    });
  }
  var StringWithEscapedBlocks = (function() {
    function StringWithEscapedBlocks(escapedString, blocks) {
      this.escapedString = escapedString;
      this.blocks = blocks;
    }
    return StringWithEscapedBlocks;
  }());
  function escapeBlocks(input) {
    var inputParts = input.split(_curlyRe);
    var resultParts = [];
    var escapedBlocks = [];
    var bracketCount = 0;
    var currentBlockParts = [];
    for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {
      var part = inputParts[partIndex];
      if (part == CLOSE_CURLY) {
        bracketCount--;
      }
      if (bracketCount > 0) {
        currentBlockParts.push(part);
      } else {
        if (currentBlockParts.length > 0) {
          escapedBlocks.push(currentBlockParts.join(''));
          resultParts.push(BLOCK_PLACEHOLDER);
          currentBlockParts = [];
        }
        resultParts.push(part);
      }
      if (part == OPEN_CURLY) {
        bracketCount++;
      }
    }
    if (currentBlockParts.length > 0) {
      escapedBlocks.push(currentBlockParts.join(''));
      resultParts.push(BLOCK_PLACEHOLDER);
    }
    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
  }
  var COMPONENT_VARIABLE = '%COMP%';
  var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
  var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
  var StylesCompileDependency = (function() {
    function StylesCompileDependency(name, moduleUrl, setValue) {
      this.name = name;
      this.moduleUrl = moduleUrl;
      this.setValue = setValue;
    }
    return StylesCompileDependency;
  }());
  var CompiledStylesheet = (function() {
    function CompiledStylesheet(outputCtx, stylesVar, dependencies, isShimmed, meta) {
      this.outputCtx = outputCtx;
      this.stylesVar = stylesVar;
      this.dependencies = dependencies;
      this.isShimmed = isShimmed;
      this.meta = meta;
    }
    return CompiledStylesheet;
  }());
  var StyleCompiler = (function() {
    function StyleCompiler(_urlResolver) {
      this._urlResolver = _urlResolver;
      this._shadowCss = new ShadowCss();
    }
    StyleCompiler.prototype.compileComponent = function(outputCtx, comp) {
      var template = ((comp.template));
      return this._compileStyles(outputCtx, comp, new CompileStylesheetMetadata({
        styles: template.styles,
        styleUrls: template.styleUrls,
        moduleUrl: identifierModuleUrl(comp.type)
      }), true);
    };
    StyleCompiler.prototype.compileStyles = function(outputCtx, comp, stylesheet) {
      return this._compileStyles(outputCtx, comp, stylesheet, false);
    };
    StyleCompiler.prototype.needsStyleShim = function(comp) {
      return ((comp.template)).encapsulation === _angular_core.ViewEncapsulation.Emulated;
    };
    StyleCompiler.prototype._compileStyles = function(outputCtx, comp, stylesheet, isComponentStylesheet) {
      var _this = this;
      var shim = this.needsStyleShim(comp);
      var styleExpressions = stylesheet.styles.map(function(plainStyle) {
        return literal(_this._shimIfNeeded(plainStyle, shim));
      });
      var dependencies = [];
      stylesheet.styleUrls.forEach(function(styleUrl) {
        var exprIndex = styleExpressions.length;
        styleExpressions.push(((null)));
        dependencies.push(new StylesCompileDependency(getStylesVarName(null), styleUrl, function(value) {
          return styleExpressions[exprIndex] = outputCtx.importExpr(value);
        }));
      });
      var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);
      var stmt = variable(stylesVar).set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const]))).toDeclStmt(null, isComponentStylesheet ? [StmtModifier.Final] : [StmtModifier.Final, StmtModifier.Exported]);
      outputCtx.statements.push(stmt);
      return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);
    };
    StyleCompiler.prototype._shimIfNeeded = function(style$$1, shim) {
      return shim ? this._shadowCss.shimCssText(style$$1, CONTENT_ATTR, HOST_ATTR) : style$$1;
    };
    return StyleCompiler;
  }());
  StyleCompiler.decorators = [{type: CompilerInjectable}];
  StyleCompiler.ctorParameters = function() {
    return [{type: UrlResolver}];
  };
  function getStylesVarName(component) {
    var result = "styles";
    if (component) {
      result += "_" + identifierName(component.type);
    }
    return result;
  }
  var EventHandlerVars = (function() {
    function EventHandlerVars() {}
    return EventHandlerVars;
  }());
  EventHandlerVars.event = variable('$event');
  var ConvertActionBindingResult = (function() {
    function ConvertActionBindingResult(stmts, allowDefault) {
      this.stmts = stmts;
      this.allowDefault = allowDefault;
    }
    return ConvertActionBindingResult;
  }());
  function convertActionBinding(localResolver, implicitReceiver, action, bindingId) {
    if (!localResolver) {
      localResolver = new DefaultLocalResolver();
    }
    var actionWithoutBuiltins = convertPropertyBindingBuiltins({
      createLiteralArrayConverter: function(argCount) {
        return function(args) {
          return literalArr(args);
        };
      },
      createLiteralMapConverter: function(keys) {
        return function(values) {
          var entries = keys.map(function(k, i) {
            return ({
              key: k.key,
              value: values[i],
              quoted: k.quoted
            });
          });
          return literalMap(entries);
        };
      },
      createPipeConverter: function(name) {
        throw new Error("Illegal State: Actions are not allowed to contain pipes. Pipe: " + name);
      }
    }, action);
    var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);
    var actionStmts = [];
    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);
    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);
    var lastIndex = actionStmts.length - 1;
    var preventDefaultVar = ((null));
    if (lastIndex >= 0) {
      var lastStatement = actionStmts[lastIndex];
      var returnExpr = convertStmtIntoExpression(lastStatement);
      if (returnExpr) {
        preventDefaultVar = createPreventDefaultVar(bindingId);
        actionStmts[lastIndex] = preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false))).toDeclStmt(null, [StmtModifier.Final]);
      }
    }
    return new ConvertActionBindingResult(actionStmts, preventDefaultVar);
  }
  function convertPropertyBindingBuiltins(converterFactory, ast) {
    return convertBuiltins(converterFactory, ast);
  }
  var ConvertPropertyBindingResult = (function() {
    function ConvertPropertyBindingResult(stmts, currValExpr) {
      this.stmts = stmts;
      this.currValExpr = currValExpr;
    }
    return ConvertPropertyBindingResult;
  }());
  function convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId) {
    if (!localResolver) {
      localResolver = new DefaultLocalResolver();
    }
    var currValExpr = createCurrValueExpr(bindingId);
    var stmts = [];
    var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);
    var outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);
    if (visitor.temporaryCount) {
      for (var i = 0; i < visitor.temporaryCount; i++) {
        stmts.push(temporaryDeclaration(bindingId, i));
      }
    }
    stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [StmtModifier.Final]));
    return new ConvertPropertyBindingResult(stmts, currValExpr);
  }
  function convertBuiltins(converterFactory, ast) {
    var visitor = new _BuiltinAstConverter(converterFactory);
    return ast.visit(visitor);
  }
  function temporaryName(bindingId, temporaryNumber) {
    return "tmp_" + bindingId + "_" + temporaryNumber;
  }
  function temporaryDeclaration(bindingId, temporaryNumber) {
    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);
  }
  function prependTemporaryDecls(temporaryCount, bindingId, statements) {
    for (var i = temporaryCount - 1; i >= 0; i--) {
      statements.unshift(temporaryDeclaration(bindingId, i));
    }
  }
  var _Mode = {};
  _Mode.Statement = 0;
  _Mode.Expression = 1;
  _Mode[_Mode.Statement] = "Statement";
  _Mode[_Mode.Expression] = "Expression";
  function ensureStatementMode(mode, ast) {
    if (mode !== _Mode.Statement) {
      throw new Error("Expected a statement, but saw " + ast);
    }
  }
  function ensureExpressionMode(mode, ast) {
    if (mode !== _Mode.Expression) {
      throw new Error("Expected an expression, but saw " + ast);
    }
  }
  function convertToStatementIfNeeded(mode, expr) {
    if (mode === _Mode.Statement) {
      return expr.toStmt();
    } else {
      return expr;
    }
  }
  var _BuiltinAstConverter = (function(_super) {
    __extends(_BuiltinAstConverter, _super);
    function _BuiltinAstConverter(_converterFactory) {
      var _this = _super.call(this) || this;
      _this._converterFactory = _converterFactory;
      return _this;
    }
    _BuiltinAstConverter.prototype.visitPipe = function(ast, context) {
      var _this = this;
      var args = [ast.exp].concat(ast.args).map(function(ast) {
        return ast.visit(_this, context);
      });
      return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));
    };
    _BuiltinAstConverter.prototype.visitLiteralArray = function(ast, context) {
      var _this = this;
      var args = ast.expressions.map(function(ast) {
        return ast.visit(_this, context);
      });
      return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));
    };
    _BuiltinAstConverter.prototype.visitLiteralMap = function(ast, context) {
      var _this = this;
      var args = ast.values.map(function(ast) {
        return ast.visit(_this, context);
      });
      return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));
    };
    return _BuiltinAstConverter;
  }(AstTransformer));
  var _AstToIrVisitor = (function() {
    function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId) {
      this._localResolver = _localResolver;
      this._implicitReceiver = _implicitReceiver;
      this.bindingId = bindingId;
      this._nodeMap = new Map();
      this._resultMap = new Map();
      this._currentTemporary = 0;
      this.temporaryCount = 0;
    }
    _AstToIrVisitor.prototype.visitBinary = function(ast, mode) {
      var op;
      switch (ast.operation) {
        case '+':
          op = BinaryOperator.Plus;
          break;
        case '-':
          op = BinaryOperator.Minus;
          break;
        case '*':
          op = BinaryOperator.Multiply;
          break;
        case '/':
          op = BinaryOperator.Divide;
          break;
        case '%':
          op = BinaryOperator.Modulo;
          break;
        case '&&':
          op = BinaryOperator.And;
          break;
        case '||':
          op = BinaryOperator.Or;
          break;
        case '==':
          op = BinaryOperator.Equals;
          break;
        case '!=':
          op = BinaryOperator.NotEquals;
          break;
        case '===':
          op = BinaryOperator.Identical;
          break;
        case '!==':
          op = BinaryOperator.NotIdentical;
          break;
        case '<':
          op = BinaryOperator.Lower;
          break;
        case '>':
          op = BinaryOperator.Bigger;
          break;
        case '<=':
          op = BinaryOperator.LowerEquals;
          break;
        case '>=':
          op = BinaryOperator.BiggerEquals;
          break;
        default:
          throw new Error("Unsupported operation " + ast.operation);
      }
      return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitChain = function(ast, mode) {
      ensureStatementMode(mode, ast);
      return this.visitAll(ast.expressions, mode);
    };
    _AstToIrVisitor.prototype.visitConditional = function(ast, mode) {
      var value = this._visit(ast.condition, _Mode.Expression);
      return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitPipe = function(ast, mode) {
      throw new Error("Illegal state: Pipes should have been converted into functions. Pipe: " + ast.name);
    };
    _AstToIrVisitor.prototype.visitFunctionCall = function(ast, mode) {
      var convertedArgs = this.visitAll(ast.args, _Mode.Expression);
      var fnResult;
      if (ast instanceof BuiltinFunctionCall) {
        fnResult = ast.converter(convertedArgs);
      } else {
        fnResult = this._visit(((ast.target)), _Mode.Expression).callFn(convertedArgs);
      }
      return convertToStatementIfNeeded(mode, fnResult);
    };
    _AstToIrVisitor.prototype.visitImplicitReceiver = function(ast, mode) {
      ensureExpressionMode(mode, ast);
      return this._implicitReceiver;
    };
    _AstToIrVisitor.prototype.visitInterpolation = function(ast, mode) {
      ensureExpressionMode(mode, ast);
      var args = [literal(ast.expressions.length)];
      for (var i = 0; i < ast.strings.length - 1; i++) {
        args.push(literal(ast.strings[i]));
        args.push(this._visit(ast.expressions[i], _Mode.Expression));
      }
      args.push(literal(ast.strings[ast.strings.length - 1]));
      return ast.expressions.length <= 9 ? importExpr(Identifiers.inlineInterpolate).callFn(args) : importExpr(Identifiers.interpolate).callFn([args[0], literalArr(args.slice(1))]);
    };
    _AstToIrVisitor.prototype.visitKeyedRead = function(ast, mode) {
      var leftMostSafe = this.leftMostSafeNode(ast);
      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      } else {
        return convertToStatementIfNeeded(mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));
      }
    };
    _AstToIrVisitor.prototype.visitKeyedWrite = function(ast, mode) {
      var obj = this._visit(ast.obj, _Mode.Expression);
      var key = this._visit(ast.key, _Mode.Expression);
      var value = this._visit(ast.value, _Mode.Expression);
      return convertToStatementIfNeeded(mode, obj.key(key).set(value));
    };
    _AstToIrVisitor.prototype.visitLiteralArray = function(ast, mode) {
      throw new Error("Illegal State: literal arrays should have been converted into functions");
    };
    _AstToIrVisitor.prototype.visitLiteralMap = function(ast, mode) {
      throw new Error("Illegal State: literal maps should have been converted into functions");
    };
    _AstToIrVisitor.prototype.visitLiteralPrimitive = function(ast, mode) {
      return convertToStatementIfNeeded(mode, literal(ast.value));
    };
    _AstToIrVisitor.prototype._getLocal = function(name) {
      return this._localResolver.getLocal(name);
    };
    _AstToIrVisitor.prototype.visitMethodCall = function(ast, mode) {
      var leftMostSafe = this.leftMostSafeNode(ast);
      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      } else {
        var args = this.visitAll(ast.args, _Mode.Expression);
        var result = null;
        var receiver = this._visit(ast.receiver, _Mode.Expression);
        if (receiver === this._implicitReceiver) {
          var varExpr = this._getLocal(ast.name);
          if (varExpr) {
            result = varExpr.callFn(args);
          }
        }
        if (result == null) {
          result = receiver.callMethod(ast.name, args);
        }
        return convertToStatementIfNeeded(mode, result);
      }
    };
    _AstToIrVisitor.prototype.visitPrefixNot = function(ast, mode) {
      return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitNonNullAssert = function(ast, mode) {
      return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitPropertyRead = function(ast, mode) {
      var leftMostSafe = this.leftMostSafeNode(ast);
      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      } else {
        var result = null;
        var receiver = this._visit(ast.receiver, _Mode.Expression);
        if (receiver === this._implicitReceiver) {
          result = this._getLocal(ast.name);
        }
        if (result == null) {
          result = receiver.prop(ast.name);
        }
        return convertToStatementIfNeeded(mode, result);
      }
    };
    _AstToIrVisitor.prototype.visitPropertyWrite = function(ast, mode) {
      var receiver = this._visit(ast.receiver, _Mode.Expression);
      if (receiver === this._implicitReceiver) {
        var varExpr = this._getLocal(ast.name);
        if (varExpr) {
          throw new Error('Cannot assign to a reference or variable!');
        }
      }
      return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this._visit(ast.value, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitSafePropertyRead = function(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    };
    _AstToIrVisitor.prototype.visitSafeMethodCall = function(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    };
    _AstToIrVisitor.prototype.visitAll = function(asts, mode) {
      var _this = this;
      return asts.map(function(ast) {
        return _this._visit(ast, mode);
      });
    };
    _AstToIrVisitor.prototype.visitQuote = function(ast, mode) {
      throw new Error("Quotes are not supported for evaluation!\n        Statement: " + ast.uninterpretedExpression + " located at " + ast.location);
    };
    _AstToIrVisitor.prototype._visit = function(ast, mode) {
      var result = this._resultMap.get(ast);
      if (result)
        return result;
      return (this._nodeMap.get(ast) || ast).visit(this, mode);
    };
    _AstToIrVisitor.prototype.convertSafeAccess = function(ast, leftMostSafe, mode) {
      var guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);
      var temporary = ((undefined));
      if (this.needsTemporary(leftMostSafe.receiver)) {
        temporary = this.allocateTemporary();
        guardedExpression = temporary.set(guardedExpression);
        this._resultMap.set(leftMostSafe.receiver, temporary);
      }
      var condition = guardedExpression.isBlank();
      if (leftMostSafe instanceof SafeMethodCall) {
        this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));
      } else {
        this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));
      }
      var access = this._visit(ast, _Mode.Expression);
      this._nodeMap.delete(leftMostSafe);
      if (temporary) {
        this.releaseTemporary(temporary);
      }
      return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));
    };
    _AstToIrVisitor.prototype.leftMostSafeNode = function(ast) {
      var _this = this;
      var visit = function(visitor, ast) {
        return (_this._nodeMap.get(ast) || ast).visit(visitor);
      };
      return ast.visit({
        visitBinary: function(ast) {
          return null;
        },
        visitChain: function(ast) {
          return null;
        },
        visitConditional: function(ast) {
          return null;
        },
        visitFunctionCall: function(ast) {
          return null;
        },
        visitImplicitReceiver: function(ast) {
          return null;
        },
        visitInterpolation: function(ast) {
          return null;
        },
        visitKeyedRead: function(ast) {
          return visit(this, ast.obj);
        },
        visitKeyedWrite: function(ast) {
          return null;
        },
        visitLiteralArray: function(ast) {
          return null;
        },
        visitLiteralMap: function(ast) {
          return null;
        },
        visitLiteralPrimitive: function(ast) {
          return null;
        },
        visitMethodCall: function(ast) {
          return visit(this, ast.receiver);
        },
        visitPipe: function(ast) {
          return null;
        },
        visitPrefixNot: function(ast) {
          return null;
        },
        visitNonNullAssert: function(ast) {
          return null;
        },
        visitPropertyRead: function(ast) {
          return visit(this, ast.receiver);
        },
        visitPropertyWrite: function(ast) {
          return null;
        },
        visitQuote: function(ast) {
          return null;
        },
        visitSafeMethodCall: function(ast) {
          return visit(this, ast.receiver) || ast;
        },
        visitSafePropertyRead: function(ast) {
          return visit(this, ast.receiver) || ast;
        }
      });
    };
    _AstToIrVisitor.prototype.needsTemporary = function(ast) {
      var _this = this;
      var visit = function(visitor, ast) {
        return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);
      };
      var visitSome = function(visitor, ast) {
        return ast.some(function(ast) {
          return visit(visitor, ast);
        });
      };
      return ast.visit({
        visitBinary: function(ast) {
          return visit(this, ast.left) || visit(this, ast.right);
        },
        visitChain: function(ast) {
          return false;
        },
        visitConditional: function(ast) {
          return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);
        },
        visitFunctionCall: function(ast) {
          return true;
        },
        visitImplicitReceiver: function(ast) {
          return false;
        },
        visitInterpolation: function(ast) {
          return visitSome(this, ast.expressions);
        },
        visitKeyedRead: function(ast) {
          return false;
        },
        visitKeyedWrite: function(ast) {
          return false;
        },
        visitLiteralArray: function(ast) {
          return true;
        },
        visitLiteralMap: function(ast) {
          return true;
        },
        visitLiteralPrimitive: function(ast) {
          return false;
        },
        visitMethodCall: function(ast) {
          return true;
        },
        visitPipe: function(ast) {
          return true;
        },
        visitPrefixNot: function(ast) {
          return visit(this, ast.expression);
        },
        visitNonNullAssert: function(ast) {
          return visit(this, ast.expression);
        },
        visitPropertyRead: function(ast) {
          return false;
        },
        visitPropertyWrite: function(ast) {
          return false;
        },
        visitQuote: function(ast) {
          return false;
        },
        visitSafeMethodCall: function(ast) {
          return true;
        },
        visitSafePropertyRead: function(ast) {
          return false;
        }
      });
    };
    _AstToIrVisitor.prototype.allocateTemporary = function() {
      var tempNumber = this._currentTemporary++;
      this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
      return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
    };
    _AstToIrVisitor.prototype.releaseTemporary = function(temporary) {
      this._currentTemporary--;
      if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
        throw new Error("Temporary " + temporary.name + " released out of order");
      }
    };
    return _AstToIrVisitor;
  }());
  function flattenStatements(arg, output) {
    if (Array.isArray(arg)) {
      ((arg)).forEach(function(entry) {
        return flattenStatements(entry, output);
      });
    } else {
      output.push(arg);
    }
  }
  var DefaultLocalResolver = (function() {
    function DefaultLocalResolver() {}
    DefaultLocalResolver.prototype.getLocal = function(name) {
      if (name === EventHandlerVars.event.name) {
        return EventHandlerVars.event;
      }
      return null;
    };
    return DefaultLocalResolver;
  }());
  function createCurrValueExpr(bindingId) {
    return variable("currVal_" + bindingId);
  }
  function createPreventDefaultVar(bindingId) {
    return variable("pd_" + bindingId);
  }
  function convertStmtIntoExpression(stmt) {
    if (stmt instanceof ExpressionStatement) {
      return stmt.expr;
    } else if (stmt instanceof ReturnStatement) {
      return stmt.value;
    }
    return null;
  }
  var BuiltinFunctionCall = (function(_super) {
    __extends(BuiltinFunctionCall, _super);
    function BuiltinFunctionCall(span, args, converter) {
      var _this = _super.call(this, span, null, args) || this;
      _this.args = args;
      _this.converter = converter;
      return _this;
    }
    return BuiltinFunctionCall;
  }(FunctionCall));
  var CLASS_ATTR$1 = 'class';
  var STYLE_ATTR = 'style';
  var IMPLICIT_TEMPLATE_VAR = '\$implicit';
  var ViewCompileResult = (function() {
    function ViewCompileResult(viewClassVar, rendererTypeVar) {
      this.viewClassVar = viewClassVar;
      this.rendererTypeVar = rendererTypeVar;
    }
    return ViewCompileResult;
  }());
  var ViewCompiler = (function() {
    function ViewCompiler(_config, _reflector, _schemaRegistry) {
      this._config = _config;
      this._reflector = _reflector;
      this._schemaRegistry = _schemaRegistry;
    }
    ViewCompiler.prototype.compileComponent = function(outputCtx, component, template, styles, usedPipes) {
      var _this = this;
      var embeddedViewCount = 0;
      var staticQueryIds = findStaticQueryIds(template);
      var renderComponentVarName = ((undefined));
      if (!component.isHost) {
        var template_1 = ((component.template));
        var customRenderData = [];
        if (template_1.animations && template_1.animations.length) {
          customRenderData.push(new LiteralMapEntry('animation', convertValueToOutputAst(outputCtx, template_1.animations), true));
        }
        var renderComponentVar = variable(rendererTypeName(component.type.reference));
        renderComponentVarName = ((renderComponentVar.name));
        outputCtx.statements.push(renderComponentVar.set(importExpr(Identifiers.createRendererType2).callFn([new LiteralMapExpr([new LiteralMapEntry('encapsulation', literal(template_1.encapsulation), false), new LiteralMapEntry('styles', styles, false), new LiteralMapEntry('data', new LiteralMapExpr(customRenderData), false)])])).toDeclStmt(importType(Identifiers.RendererType2), [StmtModifier.Final, StmtModifier.Exported]));
      }
      var viewBuilderFactory = function(parent) {
        var embeddedViewIndex = embeddedViewCount++;
        return new ViewBuilder(_this._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory);
      };
      var visitor = viewBuilderFactory(null);
      visitor.visitAll([], template);
      (_a = outputCtx.statements).push.apply(_a, visitor.build());
      return new ViewCompileResult(visitor.viewName, renderComponentVarName);
      var _a;
    };
    return ViewCompiler;
  }());
  ViewCompiler.decorators = [{type: CompilerInjectable}];
  ViewCompiler.ctorParameters = function() {
    return [{type: CompilerConfig}, {type: CompileReflector}, {type: ElementSchemaRegistry}];
  };
  var LOG_VAR$1 = variable('_l');
  var VIEW_VAR = variable('_v');
  var CHECK_VAR = variable('_ck');
  var COMP_VAR = variable('_co');
  var EVENT_NAME_VAR = variable('en');
  var ALLOW_DEFAULT_VAR = variable("ad");
  var ViewBuilder = (function() {
    function ViewBuilder(reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory) {
      this.reflector = reflector;
      this.outputCtx = outputCtx;
      this.parent = parent;
      this.component = component;
      this.embeddedViewIndex = embeddedViewIndex;
      this.usedPipes = usedPipes;
      this.staticQueryIds = staticQueryIds;
      this.viewBuilderFactory = viewBuilderFactory;
      this.nodes = [];
      this.purePipeNodeIndices = Object.create(null);
      this.refNodeIndices = Object.create(null);
      this.variables = [];
      this.children = [];
      this.compType = this.embeddedViewIndex > 0 ? DYNAMIC_TYPE : expressionType(outputCtx.importExpr(this.component.type.reference));
    }
    Object.defineProperty(ViewBuilder.prototype, "viewName", {
      get: function() {
        return viewClassName(this.component.type.reference, this.embeddedViewIndex);
      },
      enumerable: true,
      configurable: true
    });
    ViewBuilder.prototype.visitAll = function(variables, astNodes) {
      var _this = this;
      this.variables = variables;
      if (!this.parent) {
        this.usedPipes.forEach(function(pipe) {
          if (pipe.pure) {
            _this.purePipeNodeIndices[pipe.name] = _this._createPipe(null, pipe);
          }
        });
      }
      if (!this.parent) {
        var queryIds_1 = staticViewQueryIds(this.staticQueryIds);
        this.component.viewQueries.forEach(function(query, queryIndex) {
          var queryId = queryIndex + 1;
          var bindingType = query.first ? 0 : 1;
          var flags = 134217728 | calcStaticDynamicQueryFlags(queryIds_1, queryId, query.first);
          _this.nodes.push(function() {
            return ({
              sourceSpan: null,
              nodeFlags: flags,
              nodeDef: importExpr(Identifiers.queryDef).callFn([literal(flags), literal(queryId), new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])])
            });
          });
        });
      }
      templateVisitAll(this, astNodes);
      if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {
        this.nodes.push(function() {
          return ({
            sourceSpan: null,
            nodeFlags: 1,
            nodeDef: importExpr(Identifiers.anchorDef).callFn([literal(0), NULL_EXPR, NULL_EXPR, literal(0)])
          });
        });
      }
    };
    ViewBuilder.prototype.build = function(targetStatements) {
      if (targetStatements === void 0) {
        targetStatements = [];
      }
      this.children.forEach(function(child) {
        return child.build(targetStatements);
      });
      var _a = this._createNodeExpressions(),
          updateRendererStmts = _a.updateRendererStmts,
          updateDirectivesStmts = _a.updateDirectivesStmts,
          nodeDefExprs = _a.nodeDefExprs;
      var updateRendererFn = this._createUpdateFn(updateRendererStmts);
      var updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);
      var viewFlags = 0;
      if (!this.parent && this.component.changeDetection === _angular_core.ChangeDetectionStrategy.OnPush) {
        viewFlags |= 2;
      }
      var viewFactory = new DeclareFunctionStmt(this.viewName, [new FnParam(((LOG_VAR$1.name)))], [new ReturnStatement(importExpr(Identifiers.viewDef).callFn([literal(viewFlags), literalArr(nodeDefExprs), updateDirectivesFn, updateRendererFn]))], importType(Identifiers.ViewDefinition), this.embeddedViewIndex === 0 ? [StmtModifier.Exported] : []);
      targetStatements.push(viewFactory);
      return targetStatements;
    };
    ViewBuilder.prototype._createUpdateFn = function(updateStmts) {
      var updateFn;
      if (updateStmts.length > 0) {
        var preStmts = [];
        if (!this.component.isHost && findReadVarNames(updateStmts).has(((COMP_VAR.name)))) {
          preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));
        }
        updateFn = fn([new FnParam(((CHECK_VAR.name)), INFERRED_TYPE), new FnParam(((VIEW_VAR.name)), INFERRED_TYPE)], preStmts.concat(updateStmts), INFERRED_TYPE);
      } else {
        updateFn = NULL_EXPR;
      }
      return updateFn;
    };
    ViewBuilder.prototype.visitNgContent = function(ast, context) {
      this.nodes.push(function() {
        return ({
          sourceSpan: ast.sourceSpan,
          nodeFlags: 8,
          nodeDef: importExpr(Identifiers.ngContentDef).callFn([literal(ast.ngContentIndex), literal(ast.index)])
        });
      });
    };
    ViewBuilder.prototype.visitText = function(ast, context) {
      this.nodes.push(function() {
        return ({
          sourceSpan: ast.sourceSpan,
          nodeFlags: 2,
          nodeDef: importExpr(Identifiers.textDef).callFn([literal(ast.ngContentIndex), literalArr([literal(ast.value)])])
        });
      });
    };
    ViewBuilder.prototype.visitBoundText = function(ast, context) {
      var _this = this;
      var nodeIndex = this.nodes.length;
      this.nodes.push(((null)));
      var astWithSource = (ast.value);
      var inter = (astWithSource.ast);
      var updateRendererExpressions = inter.expressions.map(function(expr, bindingIndex) {
        return _this._preprocessUpdateExpression({
          nodeIndex: nodeIndex,
          bindingIndex: bindingIndex,
          sourceSpan: ast.sourceSpan,
          context: COMP_VAR,
          value: expr
        });
      });
      this.nodes[nodeIndex] = function() {
        return ({
          sourceSpan: ast.sourceSpan,
          nodeFlags: 2,
          nodeDef: importExpr(Identifiers.textDef).callFn([literal(ast.ngContentIndex), literalArr(inter.strings.map(function(s) {
            return literal(s);
          }))]),
          updateRenderer: updateRendererExpressions
        });
      };
    };
    ViewBuilder.prototype.visitEmbeddedTemplate = function(ast, context) {
      var _this = this;
      var nodeIndex = this.nodes.length;
      this.nodes.push(((null)));
      var _a = this._visitElementOrTemplate(nodeIndex, ast),
          flags = _a.flags,
          queryMatchesExpr = _a.queryMatchesExpr,
          hostEvents = _a.hostEvents;
      var childVisitor = this.viewBuilderFactory(this);
      this.children.push(childVisitor);
      childVisitor.visitAll(ast.variables, ast.children);
      var childCount = this.nodes.length - nodeIndex - 1;
      this.nodes[nodeIndex] = function() {
        return ({
          sourceSpan: ast.sourceSpan,
          nodeFlags: 1 | flags,
          nodeDef: importExpr(Identifiers.anchorDef).callFn([literal(flags), queryMatchesExpr, literal(ast.ngContentIndex), literal(childCount), _this._createElementHandleEventFn(nodeIndex, hostEvents), variable(childVisitor.viewName)])
        });
      };
    };
    ViewBuilder.prototype.visitElement = function(ast, context) {
      var _this = this;
      var nodeIndex = this.nodes.length;
      this.nodes.push(((null)));
      var elName = isNgContainer(ast.name) ? null : ast.name;
      var _a = this._visitElementOrTemplate(nodeIndex, ast),
          flags = _a.flags,
          usedEvents = _a.usedEvents,
          queryMatchesExpr = _a.queryMatchesExpr,
          dirHostBindings = _a.hostBindings,
          hostEvents = _a.hostEvents;
      var inputDefs = [];
      var updateRendererExpressions = [];
      var outputDefs = [];
      if (elName) {
        var hostBindings = ast.inputs.map(function(inputAst) {
          return ({
            context: (COMP_VAR),
            inputAst: inputAst,
            dirAst: (null)
          });
        }).concat(dirHostBindings);
        if (hostBindings.length) {
          updateRendererExpressions = hostBindings.map(function(hostBinding, bindingIndex) {
            return _this._preprocessUpdateExpression({
              context: hostBinding.context,
              nodeIndex: nodeIndex,
              bindingIndex: bindingIndex,
              sourceSpan: hostBinding.inputAst.sourceSpan,
              value: hostBinding.inputAst.value
            });
          });
          inputDefs = hostBindings.map(function(hostBinding) {
            return elementBindingDef(hostBinding.inputAst, hostBinding.dirAst);
          });
        }
        outputDefs = usedEvents.map(function(_a) {
          var target = _a[0],
              eventName = _a[1];
          return literalArr([literal(target), literal(eventName)]);
        });
      }
      templateVisitAll(this, ast.children);
      var childCount = this.nodes.length - nodeIndex - 1;
      var compAst = ast.directives.find(function(dirAst) {
        return dirAst.directive.isComponent;
      });
      var compRendererType = (NULL_EXPR);
      var compView = (NULL_EXPR);
      if (compAst) {
        compView = this.outputCtx.importExpr(compAst.directive.componentViewType);
        compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);
      }
      this.nodes[nodeIndex] = function() {
        return ({
          sourceSpan: ast.sourceSpan,
          nodeFlags: 1 | flags,
          nodeDef: importExpr(Identifiers.elementDef).callFn([literal(flags), queryMatchesExpr, literal(ast.ngContentIndex), literal(childCount), literal(elName), elName ? fixedAttrsDef(ast) : NULL_EXPR, inputDefs.length ? literalArr(inputDefs) : NULL_EXPR, outputDefs.length ? literalArr(outputDefs) : NULL_EXPR, _this._createElementHandleEventFn(nodeIndex, hostEvents), compView, compRendererType]),
          updateRenderer: updateRendererExpressions
        });
      };
    };
    ViewBuilder.prototype._visitElementOrTemplate = function(nodeIndex, ast) {
      var _this = this;
      var flags = 0;
      if (ast.hasViewContainer) {
        flags |= 16777216;
      }
      var usedEvents = new Map();
      ast.outputs.forEach(function(event) {
        var _a = elementEventNameAndTarget(event, null),
            name = _a.name,
            target = _a.target;
        usedEvents.set(_angular_core.ɵelementEventFullName(target, name), [target, name]);
      });
      ast.directives.forEach(function(dirAst) {
        dirAst.hostEvents.forEach(function(event) {
          var _a = elementEventNameAndTarget(event, dirAst),
              name = _a.name,
              target = _a.target;
          usedEvents.set(_angular_core.ɵelementEventFullName(target, name), [target, name]);
        });
      });
      var hostBindings = [];
      var hostEvents = [];
      this._visitComponentFactoryResolverProvider(ast.directives);
      ast.providers.forEach(function(providerAst, providerIndex) {
        var dirAst = ((undefined));
        var dirIndex = ((undefined));
        ast.directives.forEach(function(localDirAst, i) {
          if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {
            dirAst = localDirAst;
            dirIndex = i;
          }
        });
        if (dirAst) {
          var _a = _this._visitDirective(providerAst, dirAst, dirIndex, nodeIndex, ast.references, ast.queryMatches, usedEvents, ((_this.staticQueryIds.get((ast))))),
              dirHostBindings = _a.hostBindings,
              dirHostEvents = _a.hostEvents;
          hostBindings.push.apply(hostBindings, dirHostBindings);
          hostEvents.push.apply(hostEvents, dirHostEvents);
        } else {
          _this._visitProvider(providerAst, ast.queryMatches);
        }
      });
      var queryMatchExprs = [];
      ast.queryMatches.forEach(function(match) {
        var valueType = ((undefined));
        if (tokenReference(match.value) === _this.reflector.resolveExternalReference(Identifiers.ElementRef)) {
          valueType = 0;
        } else if (tokenReference(match.value) === _this.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {
          valueType = 3;
        } else if (tokenReference(match.value) === _this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {
          valueType = 2;
        }
        if (valueType != null) {
          queryMatchExprs.push(literalArr([literal(match.queryId), literal(valueType)]));
        }
      });
      ast.references.forEach(function(ref) {
        var valueType = ((undefined));
        if (!ref.value) {
          valueType = 1;
        } else if (tokenReference(ref.value) === _this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {
          valueType = 2;
        }
        if (valueType != null) {
          _this.refNodeIndices[ref.name] = nodeIndex;
          queryMatchExprs.push(literalArr([literal(ref.name), literal(valueType)]));
        }
      });
      ast.outputs.forEach(function(outputAst) {
        hostEvents.push({
          context: COMP_VAR,
          eventAst: outputAst,
          dirAst: ((null))
        });
      });
      return {
        flags: flags,
        usedEvents: Array.from(usedEvents.values()),
        queryMatchesExpr: queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,
        hostBindings: hostBindings,
        hostEvents: hostEvents
      };
    };
    ViewBuilder.prototype._visitDirective = function(providerAst, dirAst, directiveIndex, elementNodeIndex, refs, queryMatches, usedEvents, queryIds) {
      var _this = this;
      var nodeIndex = this.nodes.length;
      this.nodes.push(((null)));
      dirAst.directive.queries.forEach(function(query, queryIndex) {
        var queryId = dirAst.contentQueryStartId + queryIndex;
        var flags = 67108864 | calcStaticDynamicQueryFlags(queryIds, queryId, query.first);
        var bindingType = query.first ? 0 : 1;
        _this.nodes.push(function() {
          return ({
            sourceSpan: dirAst.sourceSpan,
            nodeFlags: flags,
            nodeDef: importExpr(Identifiers.queryDef).callFn([literal(flags), literal(queryId), new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])])
          });
        });
      });
      var childCount = this.nodes.length - nodeIndex - 1;
      var _a = this._visitProviderOrDirective(providerAst, queryMatches),
          flags = _a.flags,
          queryMatchExprs = _a.queryMatchExprs,
          providerExpr = _a.providerExpr,
          depsExpr = _a.depsExpr;
      refs.forEach(function(ref) {
        if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {
          _this.refNodeIndices[ref.name] = nodeIndex;
          queryMatchExprs.push(literalArr([literal(ref.name), literal(4)]));
        }
      });
      if (dirAst.directive.isComponent) {
        flags |= 32768;
      }
      var inputDefs = dirAst.inputs.map(function(inputAst, inputIndex) {
        var mapValue = literalArr([literal(inputIndex), literal(inputAst.directiveName)]);
        return new LiteralMapEntry(inputAst.directiveName, mapValue, false);
      });
      var outputDefs = [];
      var dirMeta = dirAst.directive;
      Object.keys(dirMeta.outputs).forEach(function(propName) {
        var eventName = dirMeta.outputs[propName];
        if (usedEvents.has(eventName)) {
          outputDefs.push(new LiteralMapEntry(propName, literal(eventName), false));
        }
      });
      var updateDirectiveExpressions = [];
      if (dirAst.inputs.length || (flags & (262144 | 65536)) > 0) {
        updateDirectiveExpressions = dirAst.inputs.map(function(input, bindingIndex) {
          return _this._preprocessUpdateExpression({
            nodeIndex: nodeIndex,
            bindingIndex: bindingIndex,
            sourceSpan: input.sourceSpan,
            context: COMP_VAR,
            value: input.value
          });
        });
      }
      var dirContextExpr = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);
      var hostBindings = dirAst.hostProperties.map(function(inputAst) {
        return ({
          context: dirContextExpr,
          dirAst: dirAst,
          inputAst: inputAst
        });
      });
      var hostEvents = dirAst.hostEvents.map(function(hostEventAst) {
        return ({
          context: dirContextExpr,
          eventAst: hostEventAst,
          dirAst: dirAst
        });
      });
      this.nodes[nodeIndex] = function() {
        return ({
          sourceSpan: dirAst.sourceSpan,
          nodeFlags: 16384 | flags,
          nodeDef: importExpr(Identifiers.directiveDef).callFn([literal(flags), queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR, literal(childCount), providerExpr, depsExpr, inputDefs.length ? new LiteralMapExpr(inputDefs) : NULL_EXPR, outputDefs.length ? new LiteralMapExpr(outputDefs) : NULL_EXPR]),
          updateDirectives: updateDirectiveExpressions,
          directive: dirAst.directive.type
        });
      };
      return {
        hostBindings: hostBindings,
        hostEvents: hostEvents
      };
    };
    ViewBuilder.prototype._visitProvider = function(providerAst, queryMatches) {
      this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));
    };
    ViewBuilder.prototype._visitComponentFactoryResolverProvider = function(directives) {
      var componentDirMeta = directives.find(function(dirAst) {
        return dirAst.directive.isComponent;
      });
      if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {
        var _a = componentFactoryResolverProviderDef(this.reflector, this.outputCtx, 8192, componentDirMeta.directive.entryComponents),
            providerExpr = _a.providerExpr,
            depsExpr = _a.depsExpr,
            flags = _a.flags,
            tokenExpr_1 = _a.tokenExpr;
        this._addProviderNode({
          providerExpr: providerExpr,
          depsExpr: depsExpr,
          flags: flags,
          tokenExpr: tokenExpr_1,
          queryMatchExprs: [],
          sourceSpan: componentDirMeta.sourceSpan
        });
      }
    };
    ViewBuilder.prototype._addProviderNode = function(data) {
      var nodeIndex = this.nodes.length;
      this.nodes.push(function() {
        return ({
          sourceSpan: data.sourceSpan,
          nodeFlags: data.flags,
          nodeDef: importExpr(Identifiers.providerDef).callFn([literal(data.flags), data.queryMatchExprs.length ? literalArr(data.queryMatchExprs) : NULL_EXPR, data.tokenExpr, data.providerExpr, data.depsExpr])
        });
      });
    };
    ViewBuilder.prototype._visitProviderOrDirective = function(providerAst, queryMatches) {
      var flags = 0;
      var queryMatchExprs = [];
      queryMatches.forEach(function(match) {
        if (tokenReference(match.value) === tokenReference(providerAst.token)) {
          queryMatchExprs.push(literalArr([literal(match.queryId), literal(4)]));
        }
      });
      var _a = providerDef(this.outputCtx, providerAst),
          providerExpr = _a.providerExpr,
          depsExpr = _a.depsExpr,
          providerFlags = _a.flags,
          tokenExpr = _a.tokenExpr;
      return {
        flags: flags | providerFlags,
        queryMatchExprs: queryMatchExprs,
        providerExpr: providerExpr,
        depsExpr: depsExpr,
        tokenExpr: tokenExpr,
        sourceSpan: providerAst.sourceSpan
      };
    };
    ViewBuilder.prototype.getLocal = function(name) {
      if (name == EventHandlerVars.event.name) {
        return EventHandlerVars.event;
      }
      var currViewExpr = VIEW_VAR;
      for (var currBuilder = this; currBuilder; currBuilder = currBuilder.parent, currViewExpr = currViewExpr.prop('parent').cast(DYNAMIC_TYPE)) {
        var refNodeIndex = currBuilder.refNodeIndices[name];
        if (refNodeIndex != null) {
          return importExpr(Identifiers.nodeValue).callFn([currViewExpr, literal(refNodeIndex)]);
        }
        var varAst = currBuilder.variables.find(function(varAst) {
          return varAst.name === name;
        });
        if (varAst) {
          var varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;
          return currViewExpr.prop('context').prop(varValue);
        }
      }
      return null;
    };
    ViewBuilder.prototype.createLiteralArrayConverter = function(sourceSpan, argCount) {
      if (argCount === 0) {
        var valueExpr_1 = importExpr(Identifiers.EMPTY_ARRAY);
        return function() {
          return valueExpr_1;
        };
      }
      var nodeIndex = this.nodes.length;
      this.nodes.push(function() {
        return ({
          sourceSpan: sourceSpan,
          nodeFlags: 32,
          nodeDef: importExpr(Identifiers.pureArrayDef).callFn([literal(argCount)])
        });
      });
      return function(args) {
        return callCheckStmt(nodeIndex, args);
      };
    };
    ViewBuilder.prototype.createLiteralMapConverter = function(sourceSpan, keys) {
      if (keys.length === 0) {
        var valueExpr_2 = importExpr(Identifiers.EMPTY_MAP);
        return function() {
          return valueExpr_2;
        };
      }
      var map = literalMap(keys.map(function(e, i) {
        return (Object.assign({}, e, {value: literal(i)}));
      }));
      var nodeIndex = this.nodes.length;
      this.nodes.push(function() {
        return ({
          sourceSpan: sourceSpan,
          nodeFlags: 64,
          nodeDef: importExpr(Identifiers.pureObjectDef).callFn([map])
        });
      });
      return function(args) {
        return callCheckStmt(nodeIndex, args);
      };
    };
    ViewBuilder.prototype.createPipeConverter = function(expression, name, argCount) {
      var pipe = ((this.usedPipes.find(function(pipeSummary) {
        return pipeSummary.name === name;
      })));
      if (pipe.pure) {
        var nodeIndex_1 = this.nodes.length;
        this.nodes.push(function() {
          return ({
            sourceSpan: expression.sourceSpan,
            nodeFlags: 128,
            nodeDef: importExpr(Identifiers.purePipeDef).callFn([literal(argCount)])
          });
        });
        var compViewExpr = VIEW_VAR;
        var compBuilder = this;
        while (compBuilder.parent) {
          compBuilder = compBuilder.parent;
          compViewExpr = compViewExpr.prop('parent').cast(DYNAMIC_TYPE);
        }
        var pipeNodeIndex = compBuilder.purePipeNodeIndices[name];
        var pipeValueExpr_1 = importExpr(Identifiers.nodeValue).callFn([compViewExpr, literal(pipeNodeIndex)]);
        return function(args) {
          return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(nodeIndex_1, [pipeValueExpr_1].concat(args)));
        };
      } else {
        var nodeIndex = this._createPipe(expression.sourceSpan, pipe);
        var nodeValueExpr_1 = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);
        return function(args) {
          return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr_1.callMethod('transform', args));
        };
      }
    };
    ViewBuilder.prototype._createPipe = function(sourceSpan, pipe) {
      var _this = this;
      var nodeIndex = this.nodes.length;
      var flags = 0;
      pipe.type.lifecycleHooks.forEach(function(lifecycleHook) {
        if (lifecycleHook === LifecycleHooks.OnDestroy) {
          flags |= lifecycleHookToNodeFlag(lifecycleHook);
        }
      });
      var depExprs = pipe.type.diDeps.map(function(diDep) {
        return depDef(_this.outputCtx, diDep);
      });
      this.nodes.push(function() {
        return ({
          sourceSpan: sourceSpan,
          nodeFlags: 16,
          nodeDef: importExpr(Identifiers.pipeDef).callFn([literal(flags), _this.outputCtx.importExpr(pipe.type.reference), literalArr(depExprs)])
        });
      });
      return nodeIndex;
    };
    ViewBuilder.prototype._preprocessUpdateExpression = function(expression) {
      var _this = this;
      return {
        nodeIndex: expression.nodeIndex,
        bindingIndex: expression.bindingIndex,
        sourceSpan: expression.sourceSpan,
        context: expression.context,
        value: convertPropertyBindingBuiltins({
          createLiteralArrayConverter: function(argCount) {
            return _this.createLiteralArrayConverter(expression.sourceSpan, argCount);
          },
          createLiteralMapConverter: function(keys) {
            return _this.createLiteralMapConverter(expression.sourceSpan, keys);
          },
          createPipeConverter: function(name, argCount) {
            return _this.createPipeConverter(expression, name, argCount);
          }
        }, expression.value)
      };
    };
    ViewBuilder.prototype._createNodeExpressions = function() {
      var self = this;
      var updateBindingCount = 0;
      var updateRendererStmts = [];
      var updateDirectivesStmts = [];
      var nodeDefExprs = this.nodes.map(function(factory, nodeIndex) {
        var _a = factory(),
            nodeDef = _a.nodeDef,
            nodeFlags = _a.nodeFlags,
            updateDirectives = _a.updateDirectives,
            updateRenderer = _a.updateRenderer,
            sourceSpan = _a.sourceSpan;
        if (updateRenderer) {
          updateRendererStmts.push.apply(updateRendererStmts, createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false));
        }
        if (updateDirectives) {
          updateDirectivesStmts.push.apply(updateDirectivesStmts, createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (262144 | 65536)) > 0));
        }
        var logWithNodeDef = nodeFlags & 3 ? new CommaExpr([LOG_VAR$1.callFn([]).callFn([]), nodeDef]) : nodeDef;
        return applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);
      });
      return {
        updateRendererStmts: updateRendererStmts,
        updateDirectivesStmts: updateDirectivesStmts,
        nodeDefExprs: nodeDefExprs
      };
      function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {
        var updateStmts = [];
        var exprs = expressions.map(function(_a) {
          var sourceSpan = _a.sourceSpan,
              context = _a.context,
              value = _a.value;
          var bindingId = "" + updateBindingCount++;
          var nameResolver = context === COMP_VAR ? self : null;
          var _b = convertPropertyBinding(nameResolver, context, value, bindingId),
              stmts = _b.stmts,
              currValExpr = _b.currValExpr;
          updateStmts.push.apply(updateStmts, stmts.map(function(stmt) {
            return applySourceSpanToStatementIfNeeded(stmt, sourceSpan);
          }));
          return applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);
        });
        if (expressions.length || allowEmptyExprs) {
          updateStmts.push(applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));
        }
        return updateStmts;
      }
    };
    ViewBuilder.prototype._createElementHandleEventFn = function(nodeIndex, handlers) {
      var _this = this;
      var handleEventStmts = [];
      var handleEventBindingCount = 0;
      handlers.forEach(function(_a) {
        var context = _a.context,
            eventAst = _a.eventAst,
            dirAst = _a.dirAst;
        var bindingId = "" + handleEventBindingCount++;
        var nameResolver = context === COMP_VAR ? _this : null;
        var _b = convertActionBinding(nameResolver, context, eventAst.handler, bindingId),
            stmts = _b.stmts,
            allowDefault = _b.allowDefault;
        var trueStmts = stmts;
        if (allowDefault) {
          trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());
        }
        var _c = elementEventNameAndTarget(eventAst, dirAst),
            eventTarget = _c.target,
            eventName = _c.name;
        var fullEventName = _angular_core.ɵelementEventFullName(eventTarget, eventName);
        handleEventStmts.push(applySourceSpanToStatementIfNeeded(new IfStmt(literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));
      });
      var handleEventFn;
      if (handleEventStmts.length > 0) {
        var preStmts = [ALLOW_DEFAULT_VAR.set(literal(true)).toDeclStmt(BOOL_TYPE)];
        if (!this.component.isHost && findReadVarNames(handleEventStmts).has(((COMP_VAR.name)))) {
          preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));
        }
        handleEventFn = fn([new FnParam(((VIEW_VAR.name)), INFERRED_TYPE), new FnParam(((EVENT_NAME_VAR.name)), INFERRED_TYPE), new FnParam(((EventHandlerVars.event.name)), INFERRED_TYPE)], preStmts.concat(handleEventStmts, [new ReturnStatement(ALLOW_DEFAULT_VAR)]), INFERRED_TYPE);
      } else {
        handleEventFn = NULL_EXPR;
      }
      return handleEventFn;
    };
    ViewBuilder.prototype.visitDirective = function(ast, context) {};
    ViewBuilder.prototype.visitDirectiveProperty = function(ast, context) {};
    ViewBuilder.prototype.visitReference = function(ast, context) {};
    ViewBuilder.prototype.visitVariable = function(ast, context) {};
    ViewBuilder.prototype.visitEvent = function(ast, context) {};
    ViewBuilder.prototype.visitElementProperty = function(ast, context) {};
    ViewBuilder.prototype.visitAttr = function(ast, context) {};
    return ViewBuilder;
  }());
  function needsAdditionalRootNode(astNodes) {
    var lastAstNode = astNodes[astNodes.length - 1];
    if (lastAstNode instanceof EmbeddedTemplateAst) {
      return lastAstNode.hasViewContainer;
    }
    if (lastAstNode instanceof ElementAst) {
      if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {
        return needsAdditionalRootNode(lastAstNode.children);
      }
      return lastAstNode.hasViewContainer;
    }
    return lastAstNode instanceof NgContentAst;
  }
  function elementBindingDef(inputAst, dirAst) {
    switch (inputAst.type) {
      case PropertyBindingType.Attribute:
        return literalArr([literal(1), literal(inputAst.name), literal(inputAst.securityContext)]);
      case PropertyBindingType.Property:
        return literalArr([literal(8), literal(inputAst.name), literal(inputAst.securityContext)]);
      case PropertyBindingType.Animation:
        var bindingType = 8 | (dirAst && dirAst.directive.isComponent ? 32 : 16);
        return literalArr([literal(bindingType), literal('@' + inputAst.name), literal(inputAst.securityContext)]);
      case PropertyBindingType.Class:
        return literalArr([literal(2), literal(inputAst.name), NULL_EXPR]);
      case PropertyBindingType.Style:
        return literalArr([literal(4), literal(inputAst.name), literal(inputAst.unit)]);
    }
  }
  function fixedAttrsDef(elementAst) {
    var mapResult = Object.create(null);
    elementAst.attrs.forEach(function(attrAst) {
      mapResult[attrAst.name] = attrAst.value;
    });
    elementAst.directives.forEach(function(dirAst) {
      Object.keys(dirAst.directive.hostAttributes).forEach(function(name) {
        var value = dirAst.directive.hostAttributes[name];
        var prevValue = mapResult[name];
        mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;
      });
    });
    return literalArr(Object.keys(mapResult).sort().map(function(attrName) {
      return literalArr([literal(attrName), literal(mapResult[attrName])]);
    }));
  }
  function mergeAttributeValue(attrName, attrValue1, attrValue2) {
    if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {
      return attrValue1 + " " + attrValue2;
    } else {
      return attrValue2;
    }
  }
  function callCheckStmt(nodeIndex, exprs) {
    if (exprs.length > 10) {
      return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(1), literalArr(exprs)]);
    } else {
      return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(0)].concat(exprs));
    }
  }
  function callUnwrapValue(nodeIndex, bindingIdx, expr) {
    return importExpr(Identifiers.unwrapValue).callFn([VIEW_VAR, literal(nodeIndex), literal(bindingIdx), expr]);
  }
  function findStaticQueryIds(nodes, result) {
    if (result === void 0) {
      result = new Map();
    }
    nodes.forEach(function(node) {
      var staticQueryIds = new Set();
      var dynamicQueryIds = new Set();
      var queryMatches = ((undefined));
      if (node instanceof ElementAst) {
        findStaticQueryIds(node.children, result);
        node.children.forEach(function(child) {
          var childData = ((result.get(child)));
          childData.staticQueryIds.forEach(function(queryId) {
            return staticQueryIds.add(queryId);
          });
          childData.dynamicQueryIds.forEach(function(queryId) {
            return dynamicQueryIds.add(queryId);
          });
        });
        queryMatches = node.queryMatches;
      } else if (node instanceof EmbeddedTemplateAst) {
        findStaticQueryIds(node.children, result);
        node.children.forEach(function(child) {
          var childData = ((result.get(child)));
          childData.staticQueryIds.forEach(function(queryId) {
            return dynamicQueryIds.add(queryId);
          });
          childData.dynamicQueryIds.forEach(function(queryId) {
            return dynamicQueryIds.add(queryId);
          });
        });
        queryMatches = node.queryMatches;
      }
      if (queryMatches) {
        queryMatches.forEach(function(match) {
          return staticQueryIds.add(match.queryId);
        });
      }
      dynamicQueryIds.forEach(function(queryId) {
        return staticQueryIds.delete(queryId);
      });
      result.set(node, {
        staticQueryIds: staticQueryIds,
        dynamicQueryIds: dynamicQueryIds
      });
    });
    return result;
  }
  function staticViewQueryIds(nodeStaticQueryIds) {
    var staticQueryIds = new Set();
    var dynamicQueryIds = new Set();
    Array.from(nodeStaticQueryIds.values()).forEach(function(entry) {
      entry.staticQueryIds.forEach(function(queryId) {
        return staticQueryIds.add(queryId);
      });
      entry.dynamicQueryIds.forEach(function(queryId) {
        return dynamicQueryIds.add(queryId);
      });
    });
    dynamicQueryIds.forEach(function(queryId) {
      return staticQueryIds.delete(queryId);
    });
    return {
      staticQueryIds: staticQueryIds,
      dynamicQueryIds: dynamicQueryIds
    };
  }
  function elementEventNameAndTarget(eventAst, dirAst) {
    if (eventAst.isAnimation) {
      return {
        name: "@" + eventAst.name + "." + eventAst.phase,
        target: dirAst && dirAst.directive.isComponent ? 'component' : null
      };
    } else {
      return eventAst;
    }
  }
  function calcStaticDynamicQueryFlags(queryIds, queryId, isFirst) {
    var flags = 0;
    if (isFirst && (queryIds.staticQueryIds.has(queryId) || !queryIds.dynamicQueryIds.has(queryId))) {
      flags |= 268435456;
    } else {
      flags |= 536870912;
    }
    return flags;
  }
  var GeneratedFile = (function() {
    function GeneratedFile(srcFileUrl, genFileUrl, sourceOrStmts) {
      this.srcFileUrl = srcFileUrl;
      this.genFileUrl = genFileUrl;
      if (typeof sourceOrStmts === 'string') {
        this.source = sourceOrStmts;
        this.stmts = null;
      } else {
        this.source = null;
        this.stmts = sourceOrStmts;
      }
    }
    return GeneratedFile;
  }());
  function toTypeScript(file, preamble) {
    if (preamble === void 0) {
      preamble = '';
    }
    if (!file.stmts) {
      throw new Error("Illegal state: No stmts present on GeneratedFile " + file.genFileUrl);
    }
    return new TypeScriptEmitter().emitStatements(sourceUrl(file.srcFileUrl), file.genFileUrl, file.stmts, preamble);
  }
  function serializeSummaries(forJitCtx, summaryResolver, symbolResolver, symbols, types) {
    var toJsonSerializer = new ToJsonSerializer(symbolResolver, summaryResolver);
    var forJitSerializer = new ForJitSerializer(forJitCtx, symbolResolver);
    symbols.forEach(function(resolvedSymbol) {
      return toJsonSerializer.addOrMergeSummary({
        symbol: resolvedSymbol.symbol,
        metadata: resolvedSymbol.metadata
      });
    });
    for (var processedIndex = 0; processedIndex < toJsonSerializer.symbols.length; processedIndex++) {
      var symbol = toJsonSerializer.symbols[processedIndex];
      if (summaryResolver.isLibraryFile(symbol.filePath)) {
        var summary = summaryResolver.resolveSummary(symbol);
        if (!summary) {
          var resolvedSymbol = symbolResolver.resolveSymbol(symbol);
          if (resolvedSymbol) {
            summary = {
              symbol: resolvedSymbol.symbol,
              metadata: resolvedSymbol.metadata
            };
          }
        }
        if (summary) {
          if (summary.type) {
            forJitSerializer.addLibType(summary.type);
          }
          toJsonSerializer.addOrMergeSummary(summary);
        }
      }
    }
    types.forEach(function(_a) {
      var summary = _a.summary,
          metadata = _a.metadata;
      forJitSerializer.addSourceType(summary, metadata);
      toJsonSerializer.addOrMergeSummary({
        symbol: summary.type.reference,
        metadata: null,
        type: summary
      });
      if (summary.summaryKind === CompileSummaryKind.NgModule) {
        var ngModuleSummary = (summary);
        ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function(id) {
          var symbol = id.reference;
          if (summaryResolver.isLibraryFile(symbol.filePath)) {
            var summary_1 = summaryResolver.resolveSummary(symbol);
            if (summary_1) {
              toJsonSerializer.addOrMergeSummary(summary_1);
            }
          }
        });
      }
    });
    var _a = toJsonSerializer.serialize(),
        json = _a.json,
        exportAs = _a.exportAs;
    forJitSerializer.serialize(exportAs);
    return {
      json: json,
      exportAs: exportAs
    };
  }
  function deserializeSummaries(symbolCache, json) {
    var deserializer = new FromJsonDeserializer(symbolCache);
    return deserializer.deserialize(json);
  }
  function createForJitStub(outputCtx, reference) {
    return createSummaryForJitFunction(outputCtx, reference, NULL_EXPR);
  }
  function createSummaryForJitFunction(outputCtx, reference, value) {
    var fnName = summaryForJitName(reference.name);
    outputCtx.statements.push(fn([], [new ReturnStatement(value)], new ArrayType(DYNAMIC_TYPE)).toDeclStmt(fnName, [StmtModifier.Final, StmtModifier.Exported]));
  }
  var ToJsonSerializer = (function(_super) {
    __extends(ToJsonSerializer, _super);
    function ToJsonSerializer(symbolResolver, summaryResolver) {
      var _this = _super.call(this) || this;
      _this.symbolResolver = symbolResolver;
      _this.summaryResolver = summaryResolver;
      _this.symbols = [];
      _this.indexBySymbol = new Map();
      _this.processedSummaryBySymbol = new Map();
      _this.processedSummaries = [];
      return _this;
    }
    ToJsonSerializer.prototype.addOrMergeSummary = function(summary) {
      var symbolMeta = summary.metadata;
      if (symbolMeta && symbolMeta.__symbolic === 'class') {
        var clone_1 = {};
        Object.keys(symbolMeta).forEach(function(propName) {
          if (propName !== 'decorators') {
            clone_1[propName] = symbolMeta[propName];
          }
        });
        symbolMeta = clone_1;
      }
      var processedSummary = this.processedSummaryBySymbol.get(summary.symbol);
      if (!processedSummary) {
        processedSummary = this.processValue({symbol: summary.symbol});
        this.processedSummaries.push(processedSummary);
        this.processedSummaryBySymbol.set(summary.symbol, processedSummary);
      }
      if (processedSummary.metadata == null && symbolMeta != null) {
        processedSummary.metadata = this.processValue(symbolMeta);
      }
      if (processedSummary.type == null && summary.type != null) {
        processedSummary.type = this.processValue(summary.type);
      }
    };
    ToJsonSerializer.prototype.serialize = function() {
      var _this = this;
      var exportAs = [];
      var json = JSON.stringify({
        summaries: this.processedSummaries,
        symbols: this.symbols.map(function(symbol, index) {
          symbol.assertNoMembers();
          var importAs = ((undefined));
          if (_this.summaryResolver.isLibraryFile(symbol.filePath)) {
            importAs = symbol.name + "_" + index;
            exportAs.push({
              symbol: symbol,
              exportAs: importAs
            });
          }
          return {
            __symbol: index,
            name: symbol.name,
            filePath: _this.summaryResolver.getLibraryFileName(symbol.filePath),
            importAs: importAs
          };
        })
      });
      return {
        json: json,
        exportAs: exportAs
      };
    };
    ToJsonSerializer.prototype.processValue = function(value) {
      return visitValue(value, this, null);
    };
    ToJsonSerializer.prototype.visitOther = function(value, context) {
      if (value instanceof StaticSymbol) {
        var baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);
        var index = this.indexBySymbol.get(baseSymbol);
        if (index == null) {
          index = this.indexBySymbol.size;
          this.indexBySymbol.set(baseSymbol, index);
          this.symbols.push(baseSymbol);
        }
        return {
          __symbol: index,
          members: value.members
        };
      }
    };
    return ToJsonSerializer;
  }(ValueTransformer));
  var ForJitSerializer = (function() {
    function ForJitSerializer(outputCtx, symbolResolver) {
      this.outputCtx = outputCtx;
      this.symbolResolver = symbolResolver;
      this.data = new Map();
    }
    ForJitSerializer.prototype.addSourceType = function(summary, metadata) {
      this.data.set(summary.type.reference, {
        summary: summary,
        metadata: metadata,
        isLibrary: false
      });
    };
    ForJitSerializer.prototype.addLibType = function(summary) {
      this.data.set(summary.type.reference, {
        summary: summary,
        metadata: null,
        isLibrary: true
      });
    };
    ForJitSerializer.prototype.serialize = function(exportAs) {
      var _this = this;
      var ngModuleSymbols = new Set();
      Array.from(this.data.values()).forEach(function(_a) {
        var summary = _a.summary,
            metadata = _a.metadata,
            isLibrary = _a.isLibrary;
        if (summary.summaryKind === CompileSummaryKind.NgModule) {
          ngModuleSymbols.add(summary.type.reference);
          var modSummary = (summary);
          modSummary.modules.forEach(function(mod) {
            ngModuleSymbols.add(mod.reference);
          });
        }
        if (!isLibrary) {
          var fnName = summaryForJitName(summary.type.reference.name);
          createSummaryForJitFunction(_this.outputCtx, summary.type.reference, _this.serializeSummaryWithDeps(summary, ((metadata))));
        }
      });
      exportAs.forEach(function(entry) {
        var symbol = entry.symbol;
        if (ngModuleSymbols.has(symbol)) {
          var jitExportAsName = summaryForJitName(entry.exportAs);
          _this.outputCtx.statements.push(variable(jitExportAsName).set(_this.serializeSummaryRef(symbol)).toDeclStmt(null, [StmtModifier.Exported]));
        }
      });
    };
    ForJitSerializer.prototype.serializeSummaryWithDeps = function(summary, metadata) {
      var _this = this;
      var expressions = [this.serializeSummary(summary)];
      var providers = [];
      if (metadata instanceof CompileNgModuleMetadata) {
        expressions.push.apply(expressions, metadata.declaredDirectives.concat(metadata.declaredPipes).map(function(type) {
          return type.reference;
        }).concat(metadata.transitiveModule.modules.map(function(type) {
          return type.reference;
        }).filter(function(ref) {
          return ref !== metadata.type.reference;
        })).map(function(ref) {
          return _this.serializeSummaryRef(ref);
        }));
        providers = metadata.providers;
      } else if (summary.summaryKind === CompileSummaryKind.Directive) {
        var dirSummary = (summary);
        providers = dirSummary.providers.concat(dirSummary.viewProviders);
      }
      expressions.push.apply(expressions, providers.filter(function(provider) {
        return !!provider.useClass;
      }).map(function(provider) {
        return _this.serializeSummary(({
          summaryKind: CompileSummaryKind.Injectable,
          type: provider.useClass
        }));
      }));
      return literalArr(expressions);
    };
    ForJitSerializer.prototype.serializeSummaryRef = function(typeSymbol) {
      var jitImportedSymbol = this.symbolResolver.getStaticSymbol(summaryForJitFileName(typeSymbol.filePath), summaryForJitName(typeSymbol.name));
      return this.outputCtx.importExpr(jitImportedSymbol);
    };
    ForJitSerializer.prototype.serializeSummary = function(data) {
      var outputCtx = this.outputCtx;
      var Transformer = (function() {
        function Transformer() {}
        Transformer.prototype.visitArray = function(arr, context) {
          var _this = this;
          return literalArr(arr.map(function(entry) {
            return visitValue(entry, _this, context);
          }));
        };
        Transformer.prototype.visitStringMap = function(map, context) {
          var _this = this;
          return new LiteralMapExpr(Object.keys(map).map(function(key) {
            return new LiteralMapEntry(key, visitValue(map[key], _this, context), false);
          }));
        };
        Transformer.prototype.visitPrimitive = function(value, context) {
          return literal(value);
        };
        Transformer.prototype.visitOther = function(value, context) {
          if (value instanceof StaticSymbol) {
            return outputCtx.importExpr(value);
          } else {
            throw new Error("Illegal State: Encountered value " + value);
          }
        };
        return Transformer;
      }());
      return visitValue(data, new Transformer(), null);
    };
    return ForJitSerializer;
  }());
  var FromJsonDeserializer = (function(_super) {
    __extends(FromJsonDeserializer, _super);
    function FromJsonDeserializer(symbolCache) {
      var _this = _super.call(this) || this;
      _this.symbolCache = symbolCache;
      return _this;
    }
    FromJsonDeserializer.prototype.deserialize = function(json) {
      var _this = this;
      var data = JSON.parse(json);
      var importAs = [];
      this.symbols = [];
      data.symbols.forEach(function(serializedSymbol) {
        var symbol = _this.symbolCache.get(serializedSymbol.filePath, serializedSymbol.name);
        _this.symbols.push(symbol);
        if (serializedSymbol.importAs) {
          importAs.push({
            symbol: symbol,
            importAs: serializedSymbol.importAs
          });
        }
      });
      var summaries = visitValue(data.summaries, this, null);
      return {
        summaries: summaries,
        importAs: importAs
      };
    };
    FromJsonDeserializer.prototype.visitStringMap = function(map, context) {
      if ('__symbol' in map) {
        var baseSymbol = this.symbols[map['__symbol']];
        var members = map['members'];
        return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) : baseSymbol;
      } else {
        return _super.prototype.visitStringMap.call(this, map, context);
      }
    };
    return FromJsonDeserializer;
  }(ValueTransformer));
  var AotCompiler = (function() {
    function AotCompiler(_config, _host, _reflector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _outputEmitter, _summaryResolver, _localeId, _translationFormat, _enableSummariesForJit, _symbolResolver) {
      this._config = _config;
      this._host = _host;
      this._reflector = _reflector;
      this._metadataResolver = _metadataResolver;
      this._templateParser = _templateParser;
      this._styleCompiler = _styleCompiler;
      this._viewCompiler = _viewCompiler;
      this._ngModuleCompiler = _ngModuleCompiler;
      this._outputEmitter = _outputEmitter;
      this._summaryResolver = _summaryResolver;
      this._localeId = _localeId;
      this._translationFormat = _translationFormat;
      this._enableSummariesForJit = _enableSummariesForJit;
      this._symbolResolver = _symbolResolver;
    }
    AotCompiler.prototype.clearCache = function() {
      this._metadataResolver.clearCache();
    };
    AotCompiler.prototype.analyzeModulesSync = function(rootFiles) {
      var _this = this;
      var programSymbols = extractProgramSymbols(this._symbolResolver, rootFiles, this._host);
      var analyzeResult = analyzeAndValidateNgModules(programSymbols, this._host, this._metadataResolver);
      analyzeResult.ngModules.forEach(function(ngModule) {
        return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true);
      });
      return analyzeResult;
    };
    AotCompiler.prototype.analyzeModulesAsync = function(rootFiles) {
      var _this = this;
      var programSymbols = extractProgramSymbols(this._symbolResolver, rootFiles, this._host);
      var analyzeResult = analyzeAndValidateNgModules(programSymbols, this._host, this._metadataResolver);
      return Promise.all(analyzeResult.ngModules.map(function(ngModule) {
        return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false);
      })).then(function() {
        return analyzeResult;
      });
    };
    AotCompiler.prototype.emitAllStubs = function(analyzeResult) {
      var _this = this;
      var files = analyzeResult.files;
      var sourceModules = files.map(function(file) {
        return _this._compileStubFile(file.srcUrl, file.directives, file.pipes, file.ngModules, false);
      });
      return flatten(sourceModules);
    };
    AotCompiler.prototype.emitPartialStubs = function(analyzeResult) {
      var _this = this;
      var files = analyzeResult.files;
      var sourceModules = files.map(function(file) {
        return _this._compileStubFile(file.srcUrl, file.directives, file.pipes, file.ngModules, true);
      });
      return flatten(sourceModules);
    };
    AotCompiler.prototype.emitAllImpls = function(analyzeResult) {
      var _this = this;
      var ngModuleByPipeOrDirective = analyzeResult.ngModuleByPipeOrDirective,
          files = analyzeResult.files;
      var sourceModules = files.map(function(file) {
        return _this._compileImplFile(file.srcUrl, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables);
      });
      return flatten(sourceModules);
    };
    AotCompiler.prototype._compileStubFile = function(srcFileUrl, directives, pipes, ngModules, partial) {
      var _this = this;
      var fileSuffix = splitTypescriptSuffix(srcFileUrl, true)[1];
      var generatedFiles = [];
      var ngFactoryOutputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));
      var jitSummaryOutputCtx = this._createOutputContext(summaryForJitFileName(srcFileUrl, true));
      ngModules.forEach(function(ngModuleReference) {
        _this._ngModuleCompiler.createStub(ngFactoryOutputCtx, ngModuleReference);
        createForJitStub(jitSummaryOutputCtx, ngModuleReference);
      });
      var partialJitStubRequired = false;
      var partialFactoryStubRequired = false;
      directives.forEach(function(dirType) {
        var compMeta = _this._metadataResolver.getDirectiveMetadata((dirType));
        partialJitStubRequired = true;
        if (!compMeta.isComponent) {
          return;
        }
        ((compMeta.template)).externalStylesheets.forEach(function(stylesheetMeta) {
          var styleContext = _this._createOutputContext(_stylesModuleUrl(((stylesheetMeta.moduleUrl)), _this._styleCompiler.needsStyleShim(compMeta), fileSuffix));
          _createTypeReferenceStub(styleContext, Identifiers.ComponentFactory);
          generatedFiles.push(_this._codegenSourceModule(((stylesheetMeta.moduleUrl)), styleContext));
        });
        partialFactoryStubRequired = true;
      });
      if ((partialFactoryStubRequired || !partial) && ngFactoryOutputCtx.statements.length <= 0) {
        _createTypeReferenceStub(ngFactoryOutputCtx, Identifiers.ComponentFactory);
      }
      if ((partialJitStubRequired || !partial || (pipes && pipes.length > 0)) && jitSummaryOutputCtx.statements.length <= 0) {
        _createTypeReferenceStub(jitSummaryOutputCtx, Identifiers.ComponentFactory);
      }
      generatedFiles.push(this._codegenSourceModule(srcFileUrl, ngFactoryOutputCtx));
      if (this._enableSummariesForJit) {
        generatedFiles.push(this._codegenSourceModule(srcFileUrl, jitSummaryOutputCtx));
      }
      return generatedFiles;
    };
    AotCompiler.prototype._compileImplFile = function(srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {
      var _this = this;
      var fileSuffix = splitTypescriptSuffix(srcFileUrl, true)[1];
      var generatedFiles = [];
      var outputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));
      generatedFiles.push.apply(generatedFiles, this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx));
      ngModules.forEach(function(ngModuleType) {
        return _this._compileModule(outputCtx, ngModuleType);
      });
      directives.forEach(function(dirType) {
        var compMeta = _this._metadataResolver.getDirectiveMetadata((dirType));
        if (!compMeta.isComponent) {
          return;
        }
        var ngModule = ngModuleByPipeOrDirective.get(dirType);
        if (!ngModule) {
          throw new Error("Internal Error: cannot determine the module for component " + identifierName(compMeta.type) + "!");
        }
        var componentStylesheet = _this._styleCompiler.compileComponent(outputCtx, compMeta);
        ((compMeta.template)).externalStylesheets.forEach(function(stylesheetMeta) {
          generatedFiles.push(_this._codegenStyles(((stylesheetMeta.moduleUrl)), compMeta, stylesheetMeta, fileSuffix));
        });
        var compViewVars = _this._compileComponent(outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet, fileSuffix);
        _this._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);
      });
      if (outputCtx.statements.length > 0) {
        var srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);
        generatedFiles.unshift(srcModule);
      }
      return generatedFiles;
    };
    AotCompiler.prototype._createSummary = function(srcFileUrl, directives, pipes, ngModules, injectables, ngFactoryCtx) {
      var _this = this;
      var symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileUrl).map(function(symbol) {
        return _this._symbolResolver.resolveSymbol(symbol);
      });
      var typeData = ngModules.map(function(ref) {
        return ({
          summary: ((_this._metadataResolver.getNgModuleSummary(ref))),
          metadata: ((_this._metadataResolver.getNgModuleMetadata(ref)))
        });
      }).concat(directives.map(function(ref) {
        return ({
          summary: ((_this._metadataResolver.getDirectiveSummary(ref))),
          metadata: ((_this._metadataResolver.getDirectiveMetadata(ref)))
        });
      }), pipes.map(function(ref) {
        return ({
          summary: ((_this._metadataResolver.getPipeSummary(ref))),
          metadata: ((_this._metadataResolver.getPipeMetadata(ref)))
        });
      }), injectables.map(function(ref) {
        return ({
          summary: ((_this._metadataResolver.getInjectableSummary(ref))),
          metadata: ((_this._metadataResolver.getInjectableSummary(ref))).type
        });
      }));
      var forJitOutputCtx = this._createOutputContext(summaryForJitFileName(srcFileUrl, true));
      var _a = serializeSummaries(forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries, typeData),
          json = _a.json,
          exportAs = _a.exportAs;
      exportAs.forEach(function(entry) {
        ngFactoryCtx.statements.push(variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [StmtModifier.Exported]));
      });
      var summaryJson = new GeneratedFile(srcFileUrl, summaryFileName(srcFileUrl), json);
      if (this._enableSummariesForJit) {
        return [summaryJson, this._codegenSourceModule(srcFileUrl, forJitOutputCtx)];
      }
      return [summaryJson];
    };
    AotCompiler.prototype._compileModule = function(outputCtx, ngModuleType) {
      var ngModule = ((this._metadataResolver.getNgModuleMetadata(ngModuleType)));
      var providers = [];
      if (this._localeId) {
        providers.push({
          token: createTokenForExternalReference(this._reflector, Identifiers.LOCALE_ID),
          useValue: this._localeId
        });
      }
      if (this._translationFormat) {
        providers.push({
          token: createTokenForExternalReference(this._reflector, Identifiers.TRANSLATIONS_FORMAT),
          useValue: this._translationFormat
        });
      }
      this._ngModuleCompiler.compile(outputCtx, ngModule, providers);
    };
    AotCompiler.prototype._compileComponentFactory = function(outputCtx, compMeta, ngModule, fileSuffix) {
      var hostType = this._metadataResolver.getHostComponentType(compMeta.type.reference);
      var hostMeta = createHostComponentMeta(hostType, compMeta, this._metadataResolver.getHostComponentViewClass(hostType));
      var hostViewFactoryVar = this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix).viewClassVar;
      var compFactoryVar = componentFactoryName(compMeta.type.reference);
      var inputsExprs = [];
      for (var propName in compMeta.inputs) {
        var templateName = compMeta.inputs[propName];
        inputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));
      }
      var outputsExprs = [];
      for (var propName in compMeta.outputs) {
        var templateName = compMeta.outputs[propName];
        outputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));
      }
      outputCtx.statements.push(variable(compFactoryVar).set(importExpr(Identifiers.createComponentFactory).callFn([literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference), variable(hostViewFactoryVar), new LiteralMapExpr(inputsExprs), new LiteralMapExpr(outputsExprs), literalArr(((compMeta.template)).ngContentSelectors.map(function(selector) {
        return literal(selector);
      }))])).toDeclStmt(importType(Identifiers.ComponentFactory, [((expressionType(outputCtx.importExpr(compMeta.type.reference))))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]));
    };
    AotCompiler.prototype._compileComponent = function(outputCtx, compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix) {
      var _this = this;
      var directives = directiveIdentifiers.map(function(dir) {
        return _this._metadataResolver.getDirectiveSummary(dir.reference);
      });
      var pipes = ngModule.transitiveModule.pipes.map(function(pipe) {
        return _this._metadataResolver.getPipeSummary(pipe.reference);
      });
      var _a = this._templateParser.parse(compMeta, ((((compMeta.template)).template)), directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, ((compMeta.template)))),
          parsedTemplate = _a.template,
          usedPipes = _a.pipes;
      var stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);
      var viewResult = this._viewCompiler.compileComponent(outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);
      if (componentStyles) {
        _resolveStyleStatements(this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta), fileSuffix);
      }
      return viewResult;
    };
    AotCompiler.prototype._createOutputContext = function(genFilePath) {
      var _this = this;
      var importExpr$$1 = function(symbol, typeParams) {
        if (typeParams === void 0) {
          typeParams = null;
        }
        if (!(symbol instanceof StaticSymbol)) {
          throw new Error("Internal error: unknown identifier " + JSON.stringify(symbol));
        }
        var arity = _this._symbolResolver.getTypeArity(symbol) || 0;
        var _a = _this._symbolResolver.getImportAs(symbol) || symbol,
            filePath = _a.filePath,
            name = _a.name,
            members = _a.members;
        var importModule = _this._symbolResolver.fileNameToModuleName(filePath, genFilePath);
        var selfReference = _this._symbolResolver.fileNameToModuleName(genFilePath, genFilePath);
        var moduleName = importModule === selfReference ? null : importModule;
        var suppliedTypeParams = typeParams || [];
        var missingTypeParamsCount = arity - suppliedTypeParams.length;
        var allTypeParams = suppliedTypeParams.concat(new Array(missingTypeParamsCount).fill(DYNAMIC_TYPE));
        return members.reduce(function(expr, memberName) {
          return expr.prop(memberName);
        }, (importExpr(new ExternalReference(moduleName, name, null), allTypeParams)));
      };
      return {
        statements: [],
        genFilePath: genFilePath,
        importExpr: importExpr$$1
      };
    };
    AotCompiler.prototype._codegenStyles = function(srcFileUrl, compMeta, stylesheetMetadata, fileSuffix) {
      var outputCtx = this._createOutputContext(_stylesModuleUrl(((stylesheetMetadata.moduleUrl)), this._styleCompiler.needsStyleShim(compMeta), fileSuffix));
      var compiledStylesheet = this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata);
      _resolveStyleStatements(this._symbolResolver, compiledStylesheet, this._styleCompiler.needsStyleShim(compMeta), fileSuffix);
      return this._codegenSourceModule(srcFileUrl, outputCtx);
    };
    AotCompiler.prototype._codegenSourceModule = function(srcFileUrl, ctx) {
      return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);
    };
    return AotCompiler;
  }());
  function _createTypeReferenceStub(outputCtx, reference) {
    outputCtx.statements.push(importExpr(reference).toStmt());
  }
  function _resolveStyleStatements(symbolResolver, compileResult, needsShim, fileSuffix) {
    compileResult.dependencies.forEach(function(dep) {
      dep.setValue(symbolResolver.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));
    });
  }
  function _stylesModuleUrl(stylesheetUrl, shim, suffix) {
    return "" + stylesheetUrl + (shim ? '.shim' : '') + ".ngstyle" + suffix;
  }
  function analyzeNgModules(programStaticSymbols, host, metadataResolver) {
    var _a = _createNgModules(programStaticSymbols, host, metadataResolver),
        ngModules = _a.ngModules,
        symbolsMissingModule = _a.symbolsMissingModule;
    return _analyzeNgModules(programStaticSymbols, ngModules, symbolsMissingModule, metadataResolver);
  }
  function analyzeAndValidateNgModules(programStaticSymbols, host, metadataResolver) {
    var result = analyzeNgModules(programStaticSymbols, host, metadataResolver);
    if (result.symbolsMissingModule && result.symbolsMissingModule.length) {
      var messages = result.symbolsMissingModule.map(function(s) {
        return "Cannot determine the module for class " + s.name + " in " + s.filePath + "! Add " + s.name + " to the NgModule to fix it.";
      });
      throw syntaxError(messages.join('\n'));
    }
    return result;
  }
  function _analyzeNgModules(programSymbols, ngModuleMetas, symbolsMissingModule, metadataResolver) {
    var moduleMetasByRef = new Map();
    ngModuleMetas.forEach(function(ngModule) {
      return moduleMetasByRef.set(ngModule.type.reference, ngModule);
    });
    var ngModuleByPipeOrDirective = new Map();
    var ngModulesByFile = new Map();
    var ngDirectivesByFile = new Map();
    var ngPipesByFile = new Map();
    var ngInjectablesByFile = new Map();
    var filePaths = new Set();
    programSymbols.forEach(function(symbol) {
      var filePath = symbol.filePath;
      filePaths.add(filePath);
      if (metadataResolver.isInjectable(symbol)) {
        ngInjectablesByFile.set(filePath, (ngInjectablesByFile.get(filePath) || []).concat(symbol));
      }
    });
    ngModuleMetas.forEach(function(ngModuleMeta) {
      var srcFileUrl = ngModuleMeta.type.reference.filePath;
      filePaths.add(srcFileUrl);
      ngModulesByFile.set(srcFileUrl, (ngModulesByFile.get(srcFileUrl) || []).concat(ngModuleMeta.type.reference));
      ngModuleMeta.declaredDirectives.forEach(function(dirIdentifier) {
        var fileUrl = dirIdentifier.reference.filePath;
        filePaths.add(fileUrl);
        ngDirectivesByFile.set(fileUrl, (ngDirectivesByFile.get(fileUrl) || []).concat(dirIdentifier.reference));
        ngModuleByPipeOrDirective.set(dirIdentifier.reference, ngModuleMeta);
      });
      ngModuleMeta.declaredPipes.forEach(function(pipeIdentifier) {
        var fileUrl = pipeIdentifier.reference.filePath;
        filePaths.add(fileUrl);
        ngPipesByFile.set(fileUrl, (ngPipesByFile.get(fileUrl) || []).concat(pipeIdentifier.reference));
        ngModuleByPipeOrDirective.set(pipeIdentifier.reference, ngModuleMeta);
      });
    });
    var files = [];
    filePaths.forEach(function(srcUrl) {
      var directives = ngDirectivesByFile.get(srcUrl) || [];
      var pipes = ngPipesByFile.get(srcUrl) || [];
      var ngModules = ngModulesByFile.get(srcUrl) || [];
      var injectables = ngInjectablesByFile.get(srcUrl) || [];
      files.push({
        srcUrl: srcUrl,
        directives: directives,
        pipes: pipes,
        ngModules: ngModules,
        injectables: injectables
      });
    });
    return {
      ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,
      files: files,
      ngModules: ngModuleMetas,
      symbolsMissingModule: symbolsMissingModule
    };
  }
  function extractProgramSymbols(staticSymbolResolver, files, host) {
    var staticSymbols = [];
    files.filter(function(fileName) {
      return host.isSourceFile(fileName);
    }).forEach(function(sourceFile) {
      staticSymbolResolver.getSymbolsOf(sourceFile).forEach(function(symbol) {
        var resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);
        var symbolMeta = resolvedSymbol.metadata;
        if (symbolMeta) {
          if (symbolMeta.__symbolic != 'error') {
            staticSymbols.push(resolvedSymbol.symbol);
          }
        }
      });
    });
    return staticSymbols;
  }
  function _createNgModules(programStaticSymbols, host, metadataResolver) {
    var ngModules = new Map();
    var programPipesAndDirectives = [];
    var ngModulePipesAndDirective = new Set();
    var addNgModule = function(staticSymbol) {
      if (ngModules.has(staticSymbol) || !host.isSourceFile(staticSymbol.filePath)) {
        return false;
      }
      var ngModule = metadataResolver.getNgModuleMetadata(staticSymbol, false);
      if (ngModule) {
        ngModules.set(ngModule.type.reference, ngModule);
        ngModule.declaredDirectives.forEach(function(dir) {
          return ngModulePipesAndDirective.add(dir.reference);
        });
        ngModule.declaredPipes.forEach(function(pipe) {
          return ngModulePipesAndDirective.add(pipe.reference);
        });
        ngModule.transitiveModule.modules.forEach(function(modMeta) {
          return addNgModule(modMeta.reference);
        });
      }
      return !!ngModule;
    };
    programStaticSymbols.forEach(function(staticSymbol) {
      if (!addNgModule(staticSymbol) && (metadataResolver.isDirective(staticSymbol) || metadataResolver.isPipe(staticSymbol))) {
        programPipesAndDirectives.push(staticSymbol);
      }
    });
    var symbolsMissingModule = programPipesAndDirectives.filter(function(s) {
      return !ngModulePipesAndDirective.has(s);
    });
    return {
      ngModules: Array.from(ngModules.values()),
      symbolsMissingModule: symbolsMissingModule
    };
  }
  var ANGULAR_CORE = '@angular/core';
  var ANGULAR_ROUTER = '@angular/router';
  var HIDDEN_KEY = /^\$.*\$$/;
  var IGNORE = {__symbolic: 'ignore'};
  var USE_VALUE = 'useValue';
  var PROVIDE = 'provide';
  var REFERENCE_SET = new Set([USE_VALUE, 'useFactory', 'data']);
  function shouldIgnore(value) {
    return value && value.__symbolic == 'ignore';
  }
  var StaticReflector = (function() {
    function StaticReflector(summaryResolver, symbolResolver, knownMetadataClasses, knownMetadataFunctions, errorRecorder) {
      if (knownMetadataClasses === void 0) {
        knownMetadataClasses = [];
      }
      if (knownMetadataFunctions === void 0) {
        knownMetadataFunctions = [];
      }
      var _this = this;
      this.summaryResolver = summaryResolver;
      this.symbolResolver = symbolResolver;
      this.errorRecorder = errorRecorder;
      this.annotationCache = new Map();
      this.propertyCache = new Map();
      this.parameterCache = new Map();
      this.methodCache = new Map();
      this.conversionMap = new Map();
      this.annotationForParentClassWithSummaryKind = new Map();
      this.annotationNames = new Map();
      this.initializeConversionMap();
      knownMetadataClasses.forEach(function(kc) {
        return _this._registerDecoratorOrConstructor(_this.getStaticSymbol(kc.filePath, kc.name), kc.ctor);
      });
      knownMetadataFunctions.forEach(function(kf) {
        return _this._registerFunction(_this.getStaticSymbol(kf.filePath, kf.name), kf.fn);
      });
      this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [_angular_core.Directive, _angular_core.Component]);
      this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [_angular_core.Pipe]);
      this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [_angular_core.NgModule]);
      this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [_angular_core.Injectable, _angular_core.Pipe, _angular_core.Directive, _angular_core.Component, _angular_core.NgModule]);
      this.annotationNames.set(_angular_core.Directive, 'Directive');
      this.annotationNames.set(_angular_core.Component, 'Component');
      this.annotationNames.set(_angular_core.Pipe, 'Pipe');
      this.annotationNames.set(_angular_core.NgModule, 'NgModule');
      this.annotationNames.set(_angular_core.Injectable, 'Injectable');
    }
    StaticReflector.prototype.componentModuleUrl = function(typeOrFunc) {
      var staticSymbol = this.findSymbolDeclaration(typeOrFunc);
      return this.symbolResolver.getResourcePath(staticSymbol);
    };
    StaticReflector.prototype.resolveExternalReference = function(ref) {
      var importSymbol = this.getStaticSymbol(((ref.moduleName)), ((ref.name)));
      var rootSymbol = this.findDeclaration(((ref.moduleName)), ((ref.name)));
      if (importSymbol != rootSymbol) {
        this.symbolResolver.recordImportAs(rootSymbol, importSymbol);
      }
      return rootSymbol;
    };
    StaticReflector.prototype.findDeclaration = function(moduleUrl, name, containingFile) {
      return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));
    };
    StaticReflector.prototype.tryFindDeclaration = function(moduleUrl, name) {
      var _this = this;
      return this.symbolResolver.ignoreErrorsFor(function() {
        return _this.findDeclaration(moduleUrl, name);
      });
    };
    StaticReflector.prototype.findSymbolDeclaration = function(symbol) {
      var resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);
      if (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {
        return this.findSymbolDeclaration(resolvedSymbol.metadata);
      } else {
        return symbol;
      }
    };
    StaticReflector.prototype.annotations = function(type) {
      var _this = this;
      var annotations = this.annotationCache.get(type);
      if (!annotations) {
        annotations = [];
        var classMetadata = this.getTypeMetadata(type);
        var parentType = this.findParentType(type, classMetadata);
        if (parentType) {
          var parentAnnotations = this.annotations(parentType);
          annotations.push.apply(annotations, parentAnnotations);
        }
        var ownAnnotations_1 = [];
        if (classMetadata['decorators']) {
          ownAnnotations_1 = this.simplify(type, classMetadata['decorators']);
          annotations.push.apply(annotations, ownAnnotations_1);
        }
        if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) && this.summaryResolver.isLibraryFile(parentType.filePath)) {
          var summary = this.summaryResolver.resolveSummary(parentType);
          if (summary && summary.type) {
            var requiredAnnotationTypes = ((this.annotationForParentClassWithSummaryKind.get(((summary.type.summaryKind)))));
            var typeHasRequiredAnnotation = requiredAnnotationTypes.some(function(requiredType) {
              return ownAnnotations_1.some(function(ann) {
                return ann instanceof requiredType;
              });
            });
            if (!typeHasRequiredAnnotation) {
              this.reportError(syntaxError("Class " + type.name + " in " + type.filePath + " extends from a " + CompileSummaryKind[((summary.type.summaryKind))] + " in another compilation unit without duplicating the decorator. " + ("Please add a " + requiredAnnotationTypes.map(function(type) {
                return _this.annotationNames.get(type);
              }).join(' or ') + " decorator to the class.")), type);
            }
          }
        }
        this.annotationCache.set(type, annotations.filter(function(ann) {
          return !!ann;
        }));
      }
      return annotations;
    };
    StaticReflector.prototype.propMetadata = function(type) {
      var _this = this;
      var propMetadata = this.propertyCache.get(type);
      if (!propMetadata) {
        var classMetadata = this.getTypeMetadata(type);
        propMetadata = {};
        var parentType = this.findParentType(type, classMetadata);
        if (parentType) {
          var parentPropMetadata_1 = this.propMetadata(parentType);
          Object.keys(parentPropMetadata_1).forEach(function(parentProp) {
            ((propMetadata))[parentProp] = parentPropMetadata_1[parentProp];
          });
        }
        var members_1 = classMetadata['members'] || {};
        Object.keys(members_1).forEach(function(propName) {
          var propData = members_1[propName];
          var prop = ((propData)).find(function(a) {
            return a['__symbolic'] == 'property' || a['__symbolic'] == 'method';
          });
          var decorators = [];
          if (((propMetadata))[propName]) {
            decorators.push.apply(decorators, ((propMetadata))[propName]);
          }
          ((propMetadata))[propName] = decorators;
          if (prop && prop['decorators']) {
            decorators.push.apply(decorators, _this.simplify(type, prop['decorators']));
          }
        });
        this.propertyCache.set(type, propMetadata);
      }
      return propMetadata;
    };
    StaticReflector.prototype.parameters = function(type) {
      var _this = this;
      if (!(type instanceof StaticSymbol)) {
        this.reportError(new Error("parameters received " + JSON.stringify(type) + " which is not a StaticSymbol"), type);
        return [];
      }
      try {
        var parameters_1 = this.parameterCache.get(type);
        if (!parameters_1) {
          var classMetadata = this.getTypeMetadata(type);
          var parentType = this.findParentType(type, classMetadata);
          var members = classMetadata ? classMetadata['members'] : null;
          var ctorData = members ? members['__ctor__'] : null;
          if (ctorData) {
            var ctor = ((ctorData)).find(function(a) {
              return a['__symbolic'] == 'constructor';
            });
            var rawParameterTypes = (ctor['parameters']) || [];
            var parameterDecorators_1 = (this.simplify(type, ctor['parameterDecorators'] || []));
            parameters_1 = [];
            rawParameterTypes.forEach(function(rawParamType, index) {
              var nestedResult = [];
              var paramType = _this.trySimplify(type, rawParamType);
              if (paramType)
                nestedResult.push(paramType);
              var decorators = parameterDecorators_1 ? parameterDecorators_1[index] : null;
              if (decorators) {
                nestedResult.push.apply(nestedResult, decorators);
              }
              ((parameters_1)).push(nestedResult);
            });
          } else if (parentType) {
            parameters_1 = this.parameters(parentType);
          }
          if (!parameters_1) {
            parameters_1 = [];
          }
          this.parameterCache.set(type, parameters_1);
        }
        return parameters_1;
      } catch (e) {
        console.error("Failed on type " + JSON.stringify(type) + " with error " + e);
        throw e;
      }
    };
    StaticReflector.prototype._methodNames = function(type) {
      var methodNames = this.methodCache.get(type);
      if (!methodNames) {
        var classMetadata = this.getTypeMetadata(type);
        methodNames = {};
        var parentType = this.findParentType(type, classMetadata);
        if (parentType) {
          var parentMethodNames_1 = this._methodNames(parentType);
          Object.keys(parentMethodNames_1).forEach(function(parentProp) {
            ((methodNames))[parentProp] = parentMethodNames_1[parentProp];
          });
        }
        var members_2 = classMetadata['members'] || {};
        Object.keys(members_2).forEach(function(propName) {
          var propData = members_2[propName];
          var isMethod = ((propData)).some(function(a) {
            return a['__symbolic'] == 'method';
          });
          ((methodNames))[propName] = ((methodNames))[propName] || isMethod;
        });
        this.methodCache.set(type, methodNames);
      }
      return methodNames;
    };
    StaticReflector.prototype.findParentType = function(type, classMetadata) {
      var parentType = this.trySimplify(type, classMetadata['extends']);
      if (parentType instanceof StaticSymbol) {
        return parentType;
      }
    };
    StaticReflector.prototype.hasLifecycleHook = function(type, lcProperty) {
      if (!(type instanceof StaticSymbol)) {
        this.reportError(new Error("hasLifecycleHook received " + JSON.stringify(type) + " which is not a StaticSymbol"), type);
      }
      try {
        return !!this._methodNames(type)[lcProperty];
      } catch (e) {
        console.error("Failed on type " + JSON.stringify(type) + " with error " + e);
        throw e;
      }
    };
    StaticReflector.prototype._registerDecoratorOrConstructor = function(type, ctor) {
      this.conversionMap.set(type, function(context, args) {
        return new (ctor.bind.apply(ctor, [void 0].concat(args)))();
      });
    };
    StaticReflector.prototype._registerFunction = function(type, fn) {
      this.conversionMap.set(type, function(context, args) {
        return fn.apply(undefined, args);
      });
    };
    StaticReflector.prototype.initializeConversionMap = function() {
      this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');
      this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');
      this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');
      this.ANALYZE_FOR_ENTRY_COMPONENTS = this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), _angular_core.Host);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), _angular_core.Injectable);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), _angular_core.Self);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), _angular_core.SkipSelf);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), _angular_core.Inject);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), _angular_core.Optional);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), _angular_core.Attribute);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), _angular_core.ContentChild);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), _angular_core.ContentChildren);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), _angular_core.ViewChild);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), _angular_core.ViewChildren);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), _angular_core.Input);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), _angular_core.Output);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), _angular_core.Pipe);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), _angular_core.HostBinding);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), _angular_core.HostListener);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), _angular_core.Directive);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), _angular_core.Component);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), _angular_core.NgModule);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), _angular_core.Host);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), _angular_core.Self);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), _angular_core.SkipSelf);
      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), _angular_core.Optional);
      this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'trigger'), _angular_core.trigger);
      this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'state'), _angular_core.state);
      this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'transition'), _angular_core.transition);
      this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'style'), _angular_core.style);
      this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'animate'), _angular_core.animate);
      this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'keyframes'), _angular_core.keyframes);
      this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'sequence'), _angular_core.sequence);
      this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'group'), _angular_core.group);
    };
    StaticReflector.prototype.getStaticSymbol = function(declarationFile, name, members) {
      return this.symbolResolver.getStaticSymbol(declarationFile, name, members);
    };
    StaticReflector.prototype.reportError = function(error, context, path) {
      if (this.errorRecorder) {
        this.errorRecorder(error, (context && context.filePath) || path);
      } else {
        throw error;
      }
    };
    StaticReflector.prototype.trySimplify = function(context, value) {
      var originalRecorder = this.errorRecorder;
      this.errorRecorder = function(error, fileName) {};
      var result = this.simplify(context, value);
      this.errorRecorder = originalRecorder;
      return result;
    };
    StaticReflector.prototype.simplify = function(context, value) {
      var _this = this;
      var self = this;
      var scope = BindingScope.empty;
      var calling = new Map();
      function simplifyInContext(context, value, depth, references) {
        function resolveReferenceValue(staticSymbol) {
          var resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);
          return resolvedSymbol ? resolvedSymbol.metadata : null;
        }
        function simplifyCall(functionSymbol, targetFunction, args) {
          if (targetFunction && targetFunction['__symbolic'] == 'function') {
            if (calling.get(functionSymbol)) {
              throw new Error('Recursion not supported');
            }
            calling.set(functionSymbol, true);
            try {
              var value_1 = targetFunction['value'];
              if (value_1 && (depth != 0 || value_1.__symbolic != 'error')) {
                var parameters = targetFunction['parameters'];
                var defaults = targetFunction.defaults;
                args = args.map(function(arg) {
                  return simplifyInContext(context, arg, depth + 1, references);
                }).map(function(arg) {
                  return shouldIgnore(arg) ? undefined : arg;
                });
                if (defaults && defaults.length > args.length) {
                  args.push.apply(args, defaults.slice(args.length).map(function(value) {
                    return simplify(value);
                  }));
                }
                var functionScope = BindingScope.build();
                for (var i = 0; i < parameters.length; i++) {
                  functionScope.define(parameters[i], args[i]);
                }
                var oldScope = scope;
                var result_1;
                try {
                  scope = functionScope.done();
                  result_1 = simplifyInContext(functionSymbol, value_1, depth + 1, references);
                } finally {
                  scope = oldScope;
                }
                return result_1;
              }
            } finally {
              calling.delete(functionSymbol);
            }
          }
          if (depth === 0) {
            return IGNORE;
          }
          return simplify({
            __symbolic: 'error',
            message: 'Function call not supported',
            context: functionSymbol
          });
        }
        function simplify(expression) {
          if (isPrimitive(expression)) {
            return expression;
          }
          if (expression instanceof Array) {
            var result_2 = [];
            for (var _i = 0,
                _a = ((expression)); _i < _a.length; _i++) {
              var item = _a[_i];
              if (item && item.__symbolic === 'spread') {
                var spreadArray = simplify(item.expression);
                if (Array.isArray(spreadArray)) {
                  for (var _b = 0,
                      spreadArray_1 = spreadArray; _b < spreadArray_1.length; _b++) {
                    var spreadItem = spreadArray_1[_b];
                    result_2.push(spreadItem);
                  }
                  continue;
                }
              }
              var value_2 = simplify(item);
              if (shouldIgnore(value_2)) {
                continue;
              }
              result_2.push(value_2);
            }
            return result_2;
          }
          if (expression instanceof StaticSymbol) {
            if (expression === self.injectionToken || expression === self.opaqueToken || self.conversionMap.has(expression) || references > 0) {
              return expression;
            } else {
              var staticSymbol = expression;
              var declarationValue = resolveReferenceValue(staticSymbol);
              if (declarationValue) {
                return simplifyInContext(staticSymbol, declarationValue, depth + 1, references);
              } else {
                return staticSymbol;
              }
            }
          }
          if (expression) {
            if (expression['__symbolic']) {
              var staticSymbol = void 0;
              switch (expression['__symbolic']) {
                case 'binop':
                  var left = simplify(expression['left']);
                  if (shouldIgnore(left))
                    return left;
                  var right = simplify(expression['right']);
                  if (shouldIgnore(right))
                    return right;
                  switch (expression['operator']) {
                    case '&&':
                      return left && right;
                    case '||':
                      return left || right;
                    case '|':
                      return left | right;
                    case '^':
                      return left ^ right;
                    case '&':
                      return left & right;
                    case '==':
                      return left == right;
                    case '!=':
                      return left != right;
                    case '===':
                      return left === right;
                    case '!==':
                      return left !== right;
                    case '<':
                      return left < right;
                    case '>':
                      return left > right;
                    case '<=':
                      return left <= right;
                    case '>=':
                      return left >= right;
                    case '<<':
                      return left << right;
                    case '>>':
                      return left >> right;
                    case '+':
                      return left + right;
                    case '-':
                      return left - right;
                    case '*':
                      return left * right;
                    case '/':
                      return left / right;
                    case '%':
                      return left % right;
                  }
                  return null;
                case 'if':
                  var condition = simplify(expression['condition']);
                  return condition ? simplify(expression['thenExpression']) : simplify(expression['elseExpression']);
                case 'pre':
                  var operand = simplify(expression['operand']);
                  if (shouldIgnore(operand))
                    return operand;
                  switch (expression['operator']) {
                    case '+':
                      return operand;
                    case '-':
                      return -operand;
                    case '!':
                      return !operand;
                    case '~':
                      return ~operand;
                  }
                  return null;
                case 'index':
                  var indexTarget = simplify(expression['expression']);
                  var index = simplify(expression['index']);
                  if (indexTarget && isPrimitive(index))
                    return indexTarget[index];
                  return null;
                case 'select':
                  var member = expression['member'];
                  var selectContext = context;
                  var selectTarget = simplify(expression['expression']);
                  if (selectTarget instanceof StaticSymbol) {
                    var members = selectTarget.members.concat(member);
                    selectContext = self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);
                    var declarationValue = resolveReferenceValue(selectContext);
                    if (declarationValue) {
                      return simplifyInContext(selectContext, declarationValue, depth + 1, references);
                    } else {
                      return selectContext;
                    }
                  }
                  if (selectTarget && isPrimitive(member))
                    return simplifyInContext(selectContext, selectTarget[member], depth + 1, references);
                  return null;
                case 'reference':
                  var name = expression['name'];
                  var localValue = scope.resolve(name);
                  if (localValue != BindingScope.missing) {
                    return localValue;
                  }
                  break;
                case 'class':
                  return context;
                case 'function':
                  return context;
                case 'new':
                case 'call':
                  staticSymbol = simplifyInContext(context, expression['expression'], depth + 1, 0);
                  if (staticSymbol instanceof StaticSymbol) {
                    if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {
                      return context;
                    }
                    var argExpressions = expression['arguments'] || [];
                    var converter = self.conversionMap.get(staticSymbol);
                    if (converter) {
                      var args = argExpressions.map(function(arg) {
                        return simplifyInContext(context, arg, depth + 1, references);
                      }).map(function(arg) {
                        return shouldIgnore(arg) ? undefined : arg;
                      });
                      return converter(context, args);
                    } else {
                      var targetFunction = resolveReferenceValue(staticSymbol);
                      return simplifyCall(staticSymbol, targetFunction, argExpressions);
                    }
                  }
                  return IGNORE;
                case 'error':
                  var message = produceErrorMessage(expression);
                  if (expression['line']) {
                    message = message + " (position " + (expression['line'] + 1) + ":" + (expression['character'] + 1) + " in the original .ts file)";
                    self.reportError(positionalError(message, context.filePath, expression['line'], expression['character']), context);
                  } else {
                    self.reportError(new Error(message), context);
                  }
                  return IGNORE;
                case 'ignore':
                  return expression;
              }
              return null;
            }
            return mapStringMap(expression, function(value, name) {
              if (REFERENCE_SET.has(name)) {
                if (name === USE_VALUE && PROVIDE in expression) {
                  var provide = simplify(expression.provide);
                  if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {
                    return simplify(value);
                  }
                }
                return simplifyInContext(context, value, depth, references + 1);
              }
              return simplify(value);
            });
          }
          return IGNORE;
        }
        try {
          return simplify(value);
        } catch (e) {
          var members = context.members.length ? "." + context.members.join('.') : '';
          var message = e.message + ", resolving symbol " + context.name + members + " in " + context.filePath;
          if (e.fileName) {
            throw positionalError(message, e.fileName, e.line, e.column);
          }
          throw syntaxError(message);
        }
      }
      var recordedSimplifyInContext = function(context, value) {
        try {
          return simplifyInContext(context, value, 0, 0);
        } catch (e) {
          _this.reportError(e, context);
        }
      };
      var result = this.errorRecorder ? recordedSimplifyInContext(context, value) : simplifyInContext(context, value, 0, 0);
      if (shouldIgnore(result)) {
        return undefined;
      }
      return result;
    };
    StaticReflector.prototype.getTypeMetadata = function(type) {
      var resolvedSymbol = this.symbolResolver.resolveSymbol(type);
      return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata : {__symbolic: 'class'};
    };
    return StaticReflector;
  }());
  function expandedMessage(error) {
    switch (error.message) {
      case 'Reference to non-exported class':
        if (error.context && error.context.className) {
          return "Reference to a non-exported class " + error.context.className + ". Consider exporting the class";
        }
        break;
      case 'Variable not initialized':
        return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';
      case 'Destructuring not supported':
        return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';
      case 'Could not resolve type':
        if (error.context && error.context.typeName) {
          return "Could not resolve type " + error.context.typeName;
        }
        break;
      case 'Function call not supported':
        var prefix = error.context && error.context.name ? "Calling function '" + error.context.name + "', f" : 'F';
        return prefix + 'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';
      case 'Reference to a local symbol':
        if (error.context && error.context.name) {
          return "Reference to a local (non-exported) symbol '" + error.context.name + "'. Consider exporting the symbol";
        }
        break;
    }
    return error.message;
  }
  function produceErrorMessage(error) {
    return "Error encountered resolving symbol values statically. " + expandedMessage(error);
  }
  function mapStringMap(input, transform) {
    if (!input)
      return {};
    var result = {};
    Object.keys(input).forEach(function(key) {
      var value = transform(input[key], key);
      if (!shouldIgnore(value)) {
        if (HIDDEN_KEY.test(key)) {
          Object.defineProperty(result, key, {
            enumerable: false,
            configurable: true,
            value: value
          });
        } else {
          result[key] = value;
        }
      }
    });
    return result;
  }
  function isPrimitive(o) {
    return o === null || (typeof o !== 'function' && typeof o !== 'object');
  }
  var BindingScope = (function() {
    function BindingScope() {}
    BindingScope.prototype.resolve = function(name) {};
    BindingScope.build = function() {
      var current = new Map();
      return {
        define: function(name, value) {
          current.set(name, value);
          return this;
        },
        done: function() {
          return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;
        }
      };
    };
    return BindingScope;
  }());
  BindingScope.missing = {};
  BindingScope.empty = {resolve: function(name) {
      return BindingScope.missing;
    }};
  var PopulatedScope = (function(_super) {
    __extends(PopulatedScope, _super);
    function PopulatedScope(bindings) {
      var _this = _super.call(this) || this;
      _this.bindings = bindings;
      return _this;
    }
    PopulatedScope.prototype.resolve = function(name) {
      return this.bindings.has(name) ? this.bindings.get(name) : BindingScope.missing;
    };
    return PopulatedScope;
  }(BindingScope));
  function positionalError(message, fileName, line, column) {
    var result = new Error(message);
    ((result)).fileName = fileName;
    ((result)).line = line;
    ((result)).column = column;
    return result;
  }
  var ResolvedStaticSymbol = (function() {
    function ResolvedStaticSymbol(symbol, metadata) {
      this.symbol = symbol;
      this.metadata = metadata;
    }
    return ResolvedStaticSymbol;
  }());
  var SUPPORTED_SCHEMA_VERSION = 3;
  var StaticSymbolResolver = (function() {
    function StaticSymbolResolver(host, staticSymbolCache, summaryResolver, errorRecorder) {
      this.host = host;
      this.staticSymbolCache = staticSymbolCache;
      this.summaryResolver = summaryResolver;
      this.errorRecorder = errorRecorder;
      this.metadataCache = new Map();
      this.resolvedSymbols = new Map();
      this.resolvedFilePaths = new Set();
      this.importAs = new Map();
      this.symbolResourcePaths = new Map();
      this.symbolFromFile = new Map();
      this.knownFileNameToModuleNames = new Map();
    }
    StaticSymbolResolver.prototype.resolveSymbol = function(staticSymbol) {
      if (staticSymbol.members.length > 0) {
        return ((this._resolveSymbolMembers(staticSymbol)));
      }
      var result = this.resolvedSymbols.get(staticSymbol);
      if (result) {
        return result;
      }
      result = ((this._resolveSymbolFromSummary(staticSymbol)));
      if (result) {
        return result;
      }
      this._createSymbolsOf(staticSymbol.filePath);
      result = ((this.resolvedSymbols.get(staticSymbol)));
      return result;
    };
    StaticSymbolResolver.prototype.getImportAs = function(staticSymbol) {
      if (staticSymbol.members.length) {
        var baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);
        var baseImportAs = this.getImportAs(baseSymbol);
        return baseImportAs ? this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) : null;
      }
      var summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);
      if (summarizedFileName !== staticSymbol.filePath) {
        var summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);
        var baseSymbol = this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);
        var baseImportAs = this.getImportAs(baseSymbol);
        return baseImportAs ? this.getStaticSymbol(summaryForJitFileName(baseImportAs.filePath), summaryForJitName(baseImportAs.name), baseSymbol.members) : null;
      }
      var result = this.summaryResolver.getImportAs(staticSymbol);
      if (!result) {
        result = ((this.importAs.get(staticSymbol)));
      }
      return result;
    };
    StaticSymbolResolver.prototype.getResourcePath = function(staticSymbol) {
      return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;
    };
    StaticSymbolResolver.prototype.getTypeArity = function(staticSymbol) {
      if (isGeneratedFile(staticSymbol.filePath)) {
        return null;
      }
      var resolvedSymbol = this.resolveSymbol(staticSymbol);
      while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {
        resolvedSymbol = this.resolveSymbol(resolvedSymbol.metadata);
      }
      return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;
    };
    StaticSymbolResolver.prototype.fileNameToModuleName = function(importedFilePath, containingFilePath) {
      return this.knownFileNameToModuleNames.get(importedFilePath) || this.host.fileNameToModuleName(importedFilePath, containingFilePath);
    };
    StaticSymbolResolver.prototype.recordImportAs = function(sourceSymbol, targetSymbol) {
      sourceSymbol.assertNoMembers();
      targetSymbol.assertNoMembers();
      this.importAs.set(sourceSymbol, targetSymbol);
    };
    StaticSymbolResolver.prototype.invalidateFile = function(fileName) {
      this.metadataCache.delete(fileName);
      this.resolvedFilePaths.delete(fileName);
      var symbols = this.symbolFromFile.get(fileName);
      if (symbols) {
        this.symbolFromFile.delete(fileName);
        for (var _i = 0,
            symbols_1 = symbols; _i < symbols_1.length; _i++) {
          var symbol = symbols_1[_i];
          this.resolvedSymbols.delete(symbol);
          this.importAs.delete(symbol);
          this.symbolResourcePaths.delete(symbol);
        }
      }
    };
    StaticSymbolResolver.prototype.ignoreErrorsFor = function(cb) {
      var recorder = this.errorRecorder;
      this.errorRecorder = function() {};
      try {
        return cb();
      } finally {
        this.errorRecorder = recorder;
      }
    };
    StaticSymbolResolver.prototype._resolveSymbolMembers = function(staticSymbol) {
      var members = staticSymbol.members;
      var baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));
      if (!baseResolvedSymbol) {
        return null;
      }
      var baseMetadata = baseResolvedSymbol.metadata;
      if (baseMetadata instanceof StaticSymbol) {
        return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));
      } else if (baseMetadata && baseMetadata.__symbolic === 'class') {
        if (baseMetadata.statics && members.length === 1) {
          return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);
        }
      } else {
        var value = baseMetadata;
        for (var i = 0; i < members.length && value; i++) {
          value = value[members[i]];
        }
        return new ResolvedStaticSymbol(staticSymbol, value);
      }
      return null;
    };
    StaticSymbolResolver.prototype._resolveSymbolFromSummary = function(staticSymbol) {
      var summary = this.summaryResolver.resolveSummary(staticSymbol);
      return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;
    };
    StaticSymbolResolver.prototype.getStaticSymbol = function(declarationFile, name, members) {
      return this.staticSymbolCache.get(declarationFile, name, members);
    };
    StaticSymbolResolver.prototype.getSymbolsOf = function(filePath) {
      var symbols = new Set(this.summaryResolver.getSymbolsOf(filePath));
      this._createSymbolsOf(filePath);
      this.resolvedSymbols.forEach(function(resolvedSymbol) {
        if (resolvedSymbol.symbol.filePath === filePath) {
          symbols.add(resolvedSymbol.symbol);
        }
      });
      return Array.from(symbols);
    };
    StaticSymbolResolver.prototype._createSymbolsOf = function(filePath) {
      var _this = this;
      if (this.resolvedFilePaths.has(filePath)) {
        return;
      }
      this.resolvedFilePaths.add(filePath);
      var resolvedSymbols = [];
      var metadata = this.getModuleMetadata(filePath);
      if (metadata['importAs']) {
        this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);
      }
      if (metadata['metadata']) {
        var topLevelSymbolNames_1 = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));
        var origins_1 = metadata['origins'] || {};
        Object.keys(metadata['metadata']).forEach(function(metadataKey) {
          var symbolMeta = metadata['metadata'][metadataKey];
          var name = unescapeIdentifier(metadataKey);
          var symbol = _this.getStaticSymbol(filePath, name);
          var origin = origins_1.hasOwnProperty(metadataKey) && origins_1[metadataKey];
          if (origin) {
            var originFilePath = _this.resolveModule(origin, filePath);
            if (!originFilePath) {
              _this.reportError(new Error("Couldn't resolve original symbol for " + origin + " from " + filePath));
            } else {
              _this.symbolResourcePaths.set(symbol, originFilePath);
            }
          }
          resolvedSymbols.push(_this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames_1, symbolMeta));
        });
      }
      if (metadata['exports']) {
        var _loop_1 = function(moduleExport) {
          if (moduleExport.export) {
            moduleExport.export.forEach(function(exportSymbol) {
              var symbolName;
              if (typeof exportSymbol === 'string') {
                symbolName = exportSymbol;
              } else {
                symbolName = exportSymbol.as;
              }
              symbolName = unescapeIdentifier(symbolName);
              var symName = symbolName;
              if (typeof exportSymbol !== 'string') {
                symName = unescapeIdentifier(exportSymbol.name);
              }
              var resolvedModule = _this.resolveModule(moduleExport.from, filePath);
              if (resolvedModule) {
                var targetSymbol = _this.getStaticSymbol(resolvedModule, symName);
                var sourceSymbol = _this.getStaticSymbol(filePath, symbolName);
                resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));
              }
            });
          } else {
            var resolvedModule = this_1.resolveModule(moduleExport.from, filePath);
            if (resolvedModule) {
              var nestedExports = this_1.getSymbolsOf(resolvedModule);
              nestedExports.forEach(function(targetSymbol) {
                var sourceSymbol = _this.getStaticSymbol(filePath, targetSymbol.name);
                resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));
              });
            }
          }
        };
        var this_1 = this;
        for (var _i = 0,
            _a = metadata['exports']; _i < _a.length; _i++) {
          var moduleExport = _a[_i];
          _loop_1(moduleExport);
        }
      }
      resolvedSymbols.forEach(function(resolvedSymbol) {
        return _this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol);
      });
      this.symbolFromFile.set(filePath, resolvedSymbols.map(function(resolvedSymbol) {
        return resolvedSymbol.symbol;
      }));
    };
    StaticSymbolResolver.prototype.createResolvedSymbol = function(sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {
      if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && metadata && metadata['__symbolic'] === 'class') {
        var transformedMeta_1 = {
          __symbolic: 'class',
          arity: metadata.arity
        };
        return new ResolvedStaticSymbol(sourceSymbol, transformedMeta_1);
      }
      var self = this;
      var ReferenceTransformer = (function(_super) {
        __extends(ReferenceTransformer, _super);
        function ReferenceTransformer() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        ReferenceTransformer.prototype.visitStringMap = function(map, functionParams) {
          var symbolic = map['__symbolic'];
          if (symbolic === 'function') {
            var oldLen = functionParams.length;
            functionParams.push.apply(functionParams, (map['parameters'] || []));
            var result = _super.prototype.visitStringMap.call(this, map, functionParams);
            functionParams.length = oldLen;
            return result;
          } else if (symbolic === 'reference') {
            var module_1 = map['module'];
            var name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];
            if (!name) {
              return null;
            }
            var filePath = void 0;
            if (module_1) {
              filePath = ((self.resolveModule(module_1, sourceSymbol.filePath)));
              if (!filePath) {
                return {
                  __symbolic: 'error',
                  message: "Could not resolve " + module_1 + " relative to " + sourceSymbol.filePath + "."
                };
              }
              return self.getStaticSymbol(filePath, name);
            } else if (functionParams.indexOf(name) >= 0) {
              return {
                __symbolic: 'reference',
                name: name
              };
            } else {
              if (topLevelSymbolNames.has(name)) {
                return self.getStaticSymbol(topLevelPath, name);
              }
              null;
            }
          } else {
            return _super.prototype.visitStringMap.call(this, map, functionParams);
          }
        };
        return ReferenceTransformer;
      }(ValueTransformer));
      var transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);
      if (transformedMeta instanceof StaticSymbol) {
        return this.createExport(sourceSymbol, transformedMeta);
      }
      return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);
    };
    StaticSymbolResolver.prototype.createExport = function(sourceSymbol, targetSymbol) {
      sourceSymbol.assertNoMembers();
      targetSymbol.assertNoMembers();
      if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath)) {
        this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);
      }
      return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);
    };
    StaticSymbolResolver.prototype.reportError = function(error, context, path) {
      if (this.errorRecorder) {
        this.errorRecorder(error, (context && context.filePath) || path);
      } else {
        throw error;
      }
    };
    StaticSymbolResolver.prototype.getModuleMetadata = function(module) {
      var moduleMetadata = this.metadataCache.get(module);
      if (!moduleMetadata) {
        var moduleMetadatas = this.host.getMetadataFor(module);
        if (moduleMetadatas) {
          var maxVersion_1 = -1;
          moduleMetadatas.forEach(function(md) {
            if (md['version'] > maxVersion_1) {
              maxVersion_1 = md['version'];
              moduleMetadata = md;
            }
          });
        }
        if (!moduleMetadata) {
          moduleMetadata = {
            __symbolic: 'module',
            version: SUPPORTED_SCHEMA_VERSION,
            module: module,
            metadata: {}
          };
        }
        if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {
          var errorMessage = moduleMetadata['version'] == 2 ? "Unsupported metadata version " + moduleMetadata['version'] + " for module " + module + ". This module should be compiled with a newer version of ngc" : "Metadata version mismatch for module " + module + ", found version " + moduleMetadata['version'] + ", expected " + SUPPORTED_SCHEMA_VERSION;
          this.reportError(new Error(errorMessage));
        }
        this.metadataCache.set(module, moduleMetadata);
      }
      return moduleMetadata;
    };
    StaticSymbolResolver.prototype.getSymbolByModule = function(module, symbolName, containingFile) {
      var filePath = this.resolveModule(module, containingFile);
      if (!filePath) {
        this.reportError(new Error("Could not resolve module " + module + (containingFile ? " relative to $ {\n            containingFile\n          } " : '')));
        return this.getStaticSymbol("ERROR:" + module, symbolName);
      }
      return this.getStaticSymbol(filePath, symbolName);
    };
    StaticSymbolResolver.prototype.resolveModule = function(module, containingFile) {
      try {
        return this.host.moduleNameToFileName(module, containingFile);
      } catch (e) {
        console.error("Could not resolve module '" + module + "' relative to file " + containingFile);
        this.reportError(e, undefined, containingFile);
      }
      return null;
    };
    return StaticSymbolResolver;
  }());
  function unescapeIdentifier(identifier) {
    return identifier.startsWith('___') ? identifier.substr(1) : identifier;
  }
  var AotSummaryResolver = (function() {
    function AotSummaryResolver(host, staticSymbolCache) {
      this.host = host;
      this.staticSymbolCache = staticSymbolCache;
      this.summaryCache = new Map();
      this.loadedFilePaths = new Set();
      this.importAs = new Map();
    }
    AotSummaryResolver.prototype.isLibraryFile = function(filePath) {
      return !this.host.isSourceFile(stripGeneratedFileSuffix(filePath));
    };
    AotSummaryResolver.prototype.getLibraryFileName = function(filePath) {
      return this.host.getOutputFileName(filePath);
    };
    AotSummaryResolver.prototype.resolveSummary = function(staticSymbol) {
      staticSymbol.assertNoMembers();
      var summary = this.summaryCache.get(staticSymbol);
      if (!summary) {
        this._loadSummaryFile(staticSymbol.filePath);
        summary = ((this.summaryCache.get(staticSymbol)));
      }
      return summary;
    };
    AotSummaryResolver.prototype.getSymbolsOf = function(filePath) {
      this._loadSummaryFile(filePath);
      return Array.from(this.summaryCache.keys()).filter(function(symbol) {
        return symbol.filePath === filePath;
      });
    };
    AotSummaryResolver.prototype.getImportAs = function(staticSymbol) {
      staticSymbol.assertNoMembers();
      return ((this.importAs.get(staticSymbol)));
    };
    AotSummaryResolver.prototype.addSummary = function(summary) {
      this.summaryCache.set(summary.symbol, summary);
    };
    AotSummaryResolver.prototype._loadSummaryFile = function(filePath) {
      var _this = this;
      if (this.loadedFilePaths.has(filePath)) {
        return;
      }
      this.loadedFilePaths.add(filePath);
      if (this.isLibraryFile(filePath)) {
        var summaryFilePath = summaryFileName(filePath);
        var json = void 0;
        try {
          json = this.host.loadSummary(summaryFilePath);
        } catch (e) {
          console.error("Error loading summary file " + summaryFilePath);
          throw e;
        }
        if (json) {
          var _a = deserializeSummaries(this.staticSymbolCache, json),
              summaries = _a.summaries,
              importAs = _a.importAs;
          summaries.forEach(function(summary) {
            return _this.summaryCache.set(summary.symbol, summary);
          });
          importAs.forEach(function(importAs) {
            _this.importAs.set(importAs.symbol, _this.staticSymbolCache.get(ngfactoryFilePath(filePath), importAs.importAs));
          });
        }
      }
    };
    return AotSummaryResolver;
  }());
  function createAotCompiler(compilerHost, options) {
    var translations = options.translations || '';
    var urlResolver = createOfflineCompileUrlResolver();
    var symbolCache = new StaticSymbolCache();
    var summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);
    var symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);
    var staticReflector = new StaticReflector(summaryResolver, symbolResolver);
    var console = new _angular_core.ɵConsole();
    var htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, options.missingTranslation, console);
    var config = new CompilerConfig({
      defaultEncapsulation: _angular_core.ViewEncapsulation.Emulated,
      useJit: false,
      enableLegacyTemplate: options.enableLegacyTemplate !== false,
      missingTranslation: options.missingTranslation
    });
    var normalizer = new DirectiveNormalizer({get: function(url) {
        return compilerHost.loadResource(url);
      }}, urlResolver, htmlParser, config);
    var expressionParser = new Parser(new Lexer());
    var elementSchemaRegistry = new DomElementSchemaRegistry();
    var tmplParser = new TemplateParser(config, staticReflector, expressionParser, elementSchemaRegistry, htmlParser, console, []);
    var resolver = new CompileMetadataResolver(config, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector);
    var viewCompiler = new ViewCompiler(config, staticReflector, elementSchemaRegistry);
    var compiler = new AotCompiler(config, compilerHost, staticReflector, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, new NgModuleCompiler(staticReflector), new TypeScriptEmitter(), summaryResolver, options.locale || null, options.i18nFormat || null, options.enableSummariesForJit || null, symbolResolver);
    return {
      compiler: compiler,
      reflector: staticReflector
    };
  }
  function interpretStatements(statements) {
    var ctx = new _ExecutionContext(null, null, null, new Map());
    var visitor = new StatementInterpreter();
    visitor.visitAllStatements(statements, ctx);
    var result = {};
    ctx.exports.forEach(function(exportName) {
      result[exportName] = ctx.vars.get(exportName);
    });
    return result;
  }
  function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {
    var childCtx = ctx.createChildWihtLocalVars();
    for (var i = 0; i < varNames.length; i++) {
      childCtx.vars.set(varNames[i], varValues[i]);
    }
    var result = visitor.visitAllStatements(statements, childCtx);
    return result ? result.value : null;
  }
  var _ExecutionContext = (function() {
    function _ExecutionContext(parent, instance, className, vars) {
      this.parent = parent;
      this.instance = instance;
      this.className = className;
      this.vars = vars;
      this.exports = [];
    }
    _ExecutionContext.prototype.createChildWihtLocalVars = function() {
      return new _ExecutionContext(this, this.instance, this.className, new Map());
    };
    return _ExecutionContext;
  }());
  var ReturnValue = (function() {
    function ReturnValue(value) {
      this.value = value;
    }
    return ReturnValue;
  }());
  function createDynamicClass(_classStmt, _ctx, _visitor) {
    var propertyDescriptors = {};
    _classStmt.getters.forEach(function(getter) {
      propertyDescriptors[getter.name] = {
        configurable: false,
        get: function() {
          var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
          return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);
        }
      };
    });
    _classStmt.methods.forEach(function(method) {
      var paramNames = method.params.map(function(param) {
        return param.name;
      });
      propertyDescriptors[((method.name))] = {
        writable: false,
        configurable: false,
        value: function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
          return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);
        }
      };
    });
    var ctorParamNames = _classStmt.constructorMethod.params.map(function(param) {
      return param.name;
    });
    var ctor = function() {
      var _this = this;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
      _classStmt.fields.forEach(function(field) {
        _this[field.name] = undefined;
      });
      _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);
    };
    var superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;
    ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);
    return ctor;
  }
  var StatementInterpreter = (function() {
    function StatementInterpreter() {}
    StatementInterpreter.prototype.debugAst = function(ast) {
      return debugOutputAstAsTypeScript(ast);
    };
    StatementInterpreter.prototype.visitDeclareVarStmt = function(stmt, ctx) {
      ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));
      if (stmt.hasModifier(StmtModifier.Exported)) {
        ctx.exports.push(stmt.name);
      }
      return null;
    };
    StatementInterpreter.prototype.visitWriteVarExpr = function(expr, ctx) {
      var value = expr.value.visitExpression(this, ctx);
      var currCtx = ctx;
      while (currCtx != null) {
        if (currCtx.vars.has(expr.name)) {
          currCtx.vars.set(expr.name, value);
          return value;
        }
        currCtx = ((currCtx.parent));
      }
      throw new Error("Not declared variable " + expr.name);
    };
    StatementInterpreter.prototype.visitReadVarExpr = function(ast, ctx) {
      var varName = ((ast.name));
      if (ast.builtin != null) {
        switch (ast.builtin) {
          case BuiltinVar.Super:
            return ctx.instance.__proto__;
          case BuiltinVar.This:
            return ctx.instance;
          case BuiltinVar.CatchError:
            varName = CATCH_ERROR_VAR$2;
            break;
          case BuiltinVar.CatchStack:
            varName = CATCH_STACK_VAR$2;
            break;
          default:
            throw new Error("Unknown builtin variable " + ast.builtin);
        }
      }
      var currCtx = ctx;
      while (currCtx != null) {
        if (currCtx.vars.has(varName)) {
          return currCtx.vars.get(varName);
        }
        currCtx = ((currCtx.parent));
      }
      throw new Error("Not declared variable " + varName);
    };
    StatementInterpreter.prototype.visitWriteKeyExpr = function(expr, ctx) {
      var receiver = expr.receiver.visitExpression(this, ctx);
      var index = expr.index.visitExpression(this, ctx);
      var value = expr.value.visitExpression(this, ctx);
      receiver[index] = value;
      return value;
    };
    StatementInterpreter.prototype.visitWritePropExpr = function(expr, ctx) {
      var receiver = expr.receiver.visitExpression(this, ctx);
      var value = expr.value.visitExpression(this, ctx);
      receiver[expr.name] = value;
      return value;
    };
    StatementInterpreter.prototype.visitInvokeMethodExpr = function(expr, ctx) {
      var receiver = expr.receiver.visitExpression(this, ctx);
      var args = this.visitAllExpressions(expr.args, ctx);
      var result;
      if (expr.builtin != null) {
        switch (expr.builtin) {
          case BuiltinMethod.ConcatArray:
            result = receiver.concat.apply(receiver, args);
            break;
          case BuiltinMethod.SubscribeObservable:
            result = receiver.subscribe({next: args[0]});
            break;
          case BuiltinMethod.Bind:
            result = receiver.bind.apply(receiver, args);
            break;
          default:
            throw new Error("Unknown builtin method " + expr.builtin);
        }
      } else {
        result = receiver[((expr.name))].apply(receiver, args);
      }
      return result;
    };
    StatementInterpreter.prototype.visitInvokeFunctionExpr = function(stmt, ctx) {
      var args = this.visitAllExpressions(stmt.args, ctx);
      var fnExpr = stmt.fn;
      if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
        ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);
        return null;
      } else {
        var fn$$1 = stmt.fn.visitExpression(this, ctx);
        return fn$$1.apply(null, args);
      }
    };
    StatementInterpreter.prototype.visitReturnStmt = function(stmt, ctx) {
      return new ReturnValue(stmt.value.visitExpression(this, ctx));
    };
    StatementInterpreter.prototype.visitDeclareClassStmt = function(stmt, ctx) {
      var clazz = createDynamicClass(stmt, ctx, this);
      ctx.vars.set(stmt.name, clazz);
      if (stmt.hasModifier(StmtModifier.Exported)) {
        ctx.exports.push(stmt.name);
      }
      return null;
    };
    StatementInterpreter.prototype.visitExpressionStmt = function(stmt, ctx) {
      return stmt.expr.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitIfStmt = function(stmt, ctx) {
      var condition = stmt.condition.visitExpression(this, ctx);
      if (condition) {
        return this.visitAllStatements(stmt.trueCase, ctx);
      } else if (stmt.falseCase != null) {
        return this.visitAllStatements(stmt.falseCase, ctx);
      }
      return null;
    };
    StatementInterpreter.prototype.visitTryCatchStmt = function(stmt, ctx) {
      try {
        return this.visitAllStatements(stmt.bodyStmts, ctx);
      } catch (e) {
        var childCtx = ctx.createChildWihtLocalVars();
        childCtx.vars.set(CATCH_ERROR_VAR$2, e);
        childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);
        return this.visitAllStatements(stmt.catchStmts, childCtx);
      }
    };
    StatementInterpreter.prototype.visitThrowStmt = function(stmt, ctx) {
      throw stmt.error.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitCommentStmt = function(stmt, context) {
      return null;
    };
    StatementInterpreter.prototype.visitInstantiateExpr = function(ast, ctx) {
      var args = this.visitAllExpressions(ast.args, ctx);
      var clazz = ast.classExpr.visitExpression(this, ctx);
      return new (clazz.bind.apply(clazz, [void 0].concat(args)))();
    };
    StatementInterpreter.prototype.visitLiteralExpr = function(ast, ctx) {
      return ast.value;
    };
    StatementInterpreter.prototype.visitExternalExpr = function(ast, ctx) {
      return ast.value.runtime;
    };
    StatementInterpreter.prototype.visitConditionalExpr = function(ast, ctx) {
      if (ast.condition.visitExpression(this, ctx)) {
        return ast.trueCase.visitExpression(this, ctx);
      } else if (ast.falseCase != null) {
        return ast.falseCase.visitExpression(this, ctx);
      }
      return null;
    };
    StatementInterpreter.prototype.visitNotExpr = function(ast, ctx) {
      return !ast.condition.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitAssertNotNullExpr = function(ast, ctx) {
      return ast.condition.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitCastExpr = function(ast, ctx) {
      return ast.value.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitFunctionExpr = function(ast, ctx) {
      var paramNames = ast.params.map(function(param) {
        return param.name;
      });
      return _declareFn(paramNames, ast.statements, ctx, this);
    };
    StatementInterpreter.prototype.visitDeclareFunctionStmt = function(stmt, ctx) {
      var paramNames = stmt.params.map(function(param) {
        return param.name;
      });
      ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));
      if (stmt.hasModifier(StmtModifier.Exported)) {
        ctx.exports.push(stmt.name);
      }
      return null;
    };
    StatementInterpreter.prototype.visitBinaryOperatorExpr = function(ast, ctx) {
      var _this = this;
      var lhs = function() {
        return ast.lhs.visitExpression(_this, ctx);
      };
      var rhs = function() {
        return ast.rhs.visitExpression(_this, ctx);
      };
      switch (ast.operator) {
        case BinaryOperator.Equals:
          return lhs() == rhs();
        case BinaryOperator.Identical:
          return lhs() === rhs();
        case BinaryOperator.NotEquals:
          return lhs() != rhs();
        case BinaryOperator.NotIdentical:
          return lhs() !== rhs();
        case BinaryOperator.And:
          return lhs() && rhs();
        case BinaryOperator.Or:
          return lhs() || rhs();
        case BinaryOperator.Plus:
          return lhs() + rhs();
        case BinaryOperator.Minus:
          return lhs() - rhs();
        case BinaryOperator.Divide:
          return lhs() / rhs();
        case BinaryOperator.Multiply:
          return lhs() * rhs();
        case BinaryOperator.Modulo:
          return lhs() % rhs();
        case BinaryOperator.Lower:
          return lhs() < rhs();
        case BinaryOperator.LowerEquals:
          return lhs() <= rhs();
        case BinaryOperator.Bigger:
          return lhs() > rhs();
        case BinaryOperator.BiggerEquals:
          return lhs() >= rhs();
        default:
          throw new Error("Unknown operator " + ast.operator);
      }
    };
    StatementInterpreter.prototype.visitReadPropExpr = function(ast, ctx) {
      var result;
      var receiver = ast.receiver.visitExpression(this, ctx);
      result = receiver[ast.name];
      return result;
    };
    StatementInterpreter.prototype.visitReadKeyExpr = function(ast, ctx) {
      var receiver = ast.receiver.visitExpression(this, ctx);
      var prop = ast.index.visitExpression(this, ctx);
      return receiver[prop];
    };
    StatementInterpreter.prototype.visitLiteralArrayExpr = function(ast, ctx) {
      return this.visitAllExpressions(ast.entries, ctx);
    };
    StatementInterpreter.prototype.visitLiteralMapExpr = function(ast, ctx) {
      var _this = this;
      var result = {};
      ast.entries.forEach(function(entry) {
        return result[entry.key] = entry.value.visitExpression(_this, ctx);
      });
      return result;
    };
    StatementInterpreter.prototype.visitCommaExpr = function(ast, context) {
      var values = this.visitAllExpressions(ast.parts, context);
      return values[values.length - 1];
    };
    StatementInterpreter.prototype.visitAllExpressions = function(expressions, ctx) {
      var _this = this;
      return expressions.map(function(expr) {
        return expr.visitExpression(_this, ctx);
      });
    };
    StatementInterpreter.prototype.visitAllStatements = function(statements, ctx) {
      for (var i = 0; i < statements.length; i++) {
        var stmt = statements[i];
        var val = stmt.visitStatement(this, ctx);
        if (val instanceof ReturnValue) {
          return val;
        }
      }
      return null;
    };
    return StatementInterpreter;
  }());
  function _declareFn(varNames, statements, ctx, visitor) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return _executeFunctionStatements(varNames, args, statements, ctx, visitor);
    };
  }
  var CATCH_ERROR_VAR$2 = 'error';
  var CATCH_STACK_VAR$2 = 'stack';
  var AbstractJsEmitterVisitor = (function(_super) {
    __extends(AbstractJsEmitterVisitor, _super);
    function AbstractJsEmitterVisitor() {
      return _super.call(this, false) || this;
    }
    AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function(stmt, ctx) {
      var _this = this;
      ctx.pushClass(stmt);
      this._visitClassConstructor(stmt, ctx);
      if (stmt.parent != null) {
        ctx.print(stmt, stmt.name + ".prototype = Object.create(");
        stmt.parent.visitExpression(this, ctx);
        ctx.println(stmt, ".prototype);");
      }
      stmt.getters.forEach(function(getter) {
        return _this._visitClassGetter(stmt, getter, ctx);
      });
      stmt.methods.forEach(function(method) {
        return _this._visitClassMethod(stmt, method, ctx);
      });
      ctx.popClass();
      return null;
    };
    AbstractJsEmitterVisitor.prototype._visitClassConstructor = function(stmt, ctx) {
      ctx.print(stmt, "function " + stmt.name + "(");
      if (stmt.constructorMethod != null) {
        this._visitParams(stmt.constructorMethod.params, ctx);
      }
      ctx.println(stmt, ") {");
      ctx.incIndent();
      if (stmt.constructorMethod != null) {
        if (stmt.constructorMethod.body.length > 0) {
          ctx.println(stmt, "var self = this;");
          this.visitAllStatements(stmt.constructorMethod.body, ctx);
        }
      }
      ctx.decIndent();
      ctx.println(stmt, "}");
    };
    AbstractJsEmitterVisitor.prototype._visitClassGetter = function(stmt, getter, ctx) {
      ctx.println(stmt, "Object.defineProperty(" + stmt.name + ".prototype, '" + getter.name + "', { get: function() {");
      ctx.incIndent();
      if (getter.body.length > 0) {
        ctx.println(stmt, "var self = this;");
        this.visitAllStatements(getter.body, ctx);
      }
      ctx.decIndent();
      ctx.println(stmt, "}});");
    };
    AbstractJsEmitterVisitor.prototype._visitClassMethod = function(stmt, method, ctx) {
      ctx.print(stmt, stmt.name + ".prototype." + method.name + " = function(");
      this._visitParams(method.params, ctx);
      ctx.println(stmt, ") {");
      ctx.incIndent();
      if (method.body.length > 0) {
        ctx.println(stmt, "var self = this;");
        this.visitAllStatements(method.body, ctx);
      }
      ctx.decIndent();
      ctx.println(stmt, "};");
    };
    AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function(ast, ctx) {
      if (ast.builtin === BuiltinVar.This) {
        ctx.print(ast, 'self');
      } else if (ast.builtin === BuiltinVar.Super) {
        throw new Error("'super' needs to be handled at a parent ast node, not at the variable level!");
      } else {
        _super.prototype.visitReadVarExpr.call(this, ast, ctx);
      }
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function(stmt, ctx) {
      ctx.print(stmt, "var " + stmt.name + " = ");
      stmt.value.visitExpression(this, ctx);
      ctx.println(stmt, ";");
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitCastExpr = function(ast, ctx) {
      ast.value.visitExpression(this, ctx);
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function(expr, ctx) {
      var fnExpr = expr.fn;
      if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
        ((((ctx.currentClass)).parent)).visitExpression(this, ctx);
        ctx.print(expr, ".call(this");
        if (expr.args.length > 0) {
          ctx.print(expr, ", ");
          this.visitAllExpressions(expr.args, ctx, ',');
        }
        ctx.print(expr, ")");
      } else {
        _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);
      }
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function(ast, ctx) {
      ctx.print(ast, "function(");
      this._visitParams(ast.params, ctx);
      ctx.println(ast, ") {");
      ctx.incIndent();
      this.visitAllStatements(ast.statements, ctx);
      ctx.decIndent();
      ctx.print(ast, "}");
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function(stmt, ctx) {
      ctx.print(stmt, "function " + stmt.name + "(");
      this._visitParams(stmt.params, ctx);
      ctx.println(stmt, ") {");
      ctx.incIndent();
      this.visitAllStatements(stmt.statements, ctx);
      ctx.decIndent();
      ctx.println(stmt, "}");
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function(stmt, ctx) {
      ctx.println(stmt, "try {");
      ctx.incIndent();
      this.visitAllStatements(stmt.bodyStmts, ctx);
      ctx.decIndent();
      ctx.println(stmt, "} catch (" + CATCH_ERROR_VAR$1.name + ") {");
      ctx.incIndent();
      var catchStmts = [(CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [StmtModifier.Final]))].concat(stmt.catchStmts);
      this.visitAllStatements(catchStmts, ctx);
      ctx.decIndent();
      ctx.println(stmt, "}");
      return null;
    };
    AbstractJsEmitterVisitor.prototype._visitParams = function(params, ctx) {
      this.visitAllObjects(function(param) {
        return ctx.print(null, param.name);
      }, params, ctx, ',');
    };
    AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function(method) {
      var name;
      switch (method) {
        case BuiltinMethod.ConcatArray:
          name = 'concat';
          break;
        case BuiltinMethod.SubscribeObservable:
          name = 'subscribe';
          break;
        case BuiltinMethod.Bind:
          name = 'bind';
          break;
        default:
          throw new Error("Unknown builtin method: " + method);
      }
      return name;
    };
    return AbstractJsEmitterVisitor;
  }(AbstractEmitterVisitor));
  function evalExpression(sourceUrl$$1, ctx, vars) {
    var fnBody = ctx.toSource() + "\n//# sourceURL=" + sourceUrl$$1;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
      fnArgNames.push(argName);
      fnArgValues.push(vars[argName]);
    }
    if (_angular_core.isDevMode()) {
      var emptyFn = new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat('return null;'))))().toString();
      var headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\n').length - 1;
      fnBody += "\n" + ctx.toSourceMapGenerator(sourceUrl$$1, sourceUrl$$1, headerLines).toJsComment();
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
  }
  function jitStatements(sourceUrl$$1, statements) {
    var converter = new JitEmitterVisitor();
    var ctx = EmitterVisitorContext.createRoot();
    converter.visitAllStatements(statements, ctx);
    converter.createReturnStmt(ctx);
    return evalExpression(sourceUrl$$1, ctx, converter.getArgs());
  }
  var JitEmitterVisitor = (function(_super) {
    __extends(JitEmitterVisitor, _super);
    function JitEmitterVisitor() {
      var _this = _super.apply(this, arguments) || this;
      _this._evalArgNames = [];
      _this._evalArgValues = [];
      _this._evalExportedVars = [];
      return _this;
    }
    JitEmitterVisitor.prototype.createReturnStmt = function(ctx) {
      var stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(function(resultVar) {
        return new LiteralMapEntry(resultVar, variable(resultVar), false);
      })));
      stmt.visitStatement(this, ctx);
    };
    JitEmitterVisitor.prototype.getArgs = function() {
      var result = {};
      for (var i = 0; i < this._evalArgNames.length; i++) {
        result[this._evalArgNames[i]] = this._evalArgValues[i];
      }
      return result;
    };
    JitEmitterVisitor.prototype.visitExternalExpr = function(ast, ctx) {
      var value = ast.value.runtime;
      var id = this._evalArgValues.indexOf(value);
      if (id === -1) {
        id = this._evalArgValues.length;
        this._evalArgValues.push(value);
        var name = identifierName({reference: ast.value.runtime}) || 'val';
        this._evalArgNames.push("jit_" + name + "_" + id);
      }
      ctx.print(ast, this._evalArgNames[id]);
      return null;
    };
    JitEmitterVisitor.prototype.visitDeclareVarStmt = function(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported)) {
        this._evalExportedVars.push(stmt.name);
      }
      return _super.prototype.visitDeclareVarStmt.call(this, stmt, ctx);
    };
    JitEmitterVisitor.prototype.visitDeclareFunctionStmt = function(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported)) {
        this._evalExportedVars.push(stmt.name);
      }
      return _super.prototype.visitDeclareFunctionStmt.call(this, stmt, ctx);
    };
    JitEmitterVisitor.prototype.visitDeclareClassStmt = function(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported)) {
        this._evalExportedVars.push(stmt.name);
      }
      return _super.prototype.visitDeclareClassStmt.call(this, stmt, ctx);
    };
    return JitEmitterVisitor;
  }(AbstractJsEmitterVisitor));
  var JitCompiler = (function() {
    function JitCompiler(_injector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _summaryResolver, _compilerConfig, _console) {
      this._injector = _injector;
      this._metadataResolver = _metadataResolver;
      this._templateParser = _templateParser;
      this._styleCompiler = _styleCompiler;
      this._viewCompiler = _viewCompiler;
      this._ngModuleCompiler = _ngModuleCompiler;
      this._summaryResolver = _summaryResolver;
      this._compilerConfig = _compilerConfig;
      this._console = _console;
      this._compiledTemplateCache = new Map();
      this._compiledHostTemplateCache = new Map();
      this._compiledDirectiveWrapperCache = new Map();
      this._compiledNgModuleCache = new Map();
      this._sharedStylesheetCount = 0;
    }
    Object.defineProperty(JitCompiler.prototype, "injector", {
      get: function() {
        return this._injector;
      },
      enumerable: true,
      configurable: true
    });
    JitCompiler.prototype.compileModuleSync = function(moduleType) {
      return SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));
    };
    JitCompiler.prototype.compileModuleAsync = function(moduleType) {
      return Promise.resolve(this._compileModuleAndComponents(moduleType, false));
    };
    JitCompiler.prototype.compileModuleAndAllComponentsSync = function(moduleType) {
      return SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));
    };
    JitCompiler.prototype.compileModuleAndAllComponentsAsync = function(moduleType) {
      return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));
    };
    JitCompiler.prototype.getNgContentSelectors = function(component) {
      this._console.warn('Compiler.getNgContentSelectors is deprecated. Use ComponentFactory.ngContentSelectors instead!');
      var template = this._compiledTemplateCache.get(component);
      if (!template) {
        throw new Error("The component " + _angular_core.ɵstringify(component) + " is not yet compiled!");
      }
      return ((template.compMeta.template)).ngContentSelectors;
    };
    JitCompiler.prototype.getComponentFactory = function(component) {
      var summary = this._metadataResolver.getDirectiveSummary(component);
      return (summary.componentFactory);
    };
    JitCompiler.prototype.loadAotSummaries = function(summaries) {
      var _this = this;
      this.clearCache();
      flattenSummaries(summaries).forEach(function(summary) {
        _this._summaryResolver.addSummary({
          symbol: summary.type.reference,
          metadata: null,
          type: summary
        });
      });
    };
    JitCompiler.prototype.hasAotSummary = function(ref) {
      return !!this._summaryResolver.resolveSummary(ref);
    };
    JitCompiler.prototype._filterJitIdentifiers = function(ids) {
      var _this = this;
      return ids.map(function(mod) {
        return mod.reference;
      }).filter(function(ref) {
        return !_this.hasAotSummary(ref);
      });
    };
    JitCompiler.prototype._compileModuleAndComponents = function(moduleType, isSync) {
      var _this = this;
      return SyncAsync.then(this._loadModules(moduleType, isSync), function() {
        _this._compileComponents(moduleType, null);
        return _this._compileModule(moduleType);
      });
    };
    JitCompiler.prototype._compileModuleAndAllComponents = function(moduleType, isSync) {
      var _this = this;
      return SyncAsync.then(this._loadModules(moduleType, isSync), function() {
        var componentFactories = [];
        _this._compileComponents(moduleType, componentFactories);
        return new _angular_core.ModuleWithComponentFactories(_this._compileModule(moduleType), componentFactories);
      });
    };
    JitCompiler.prototype._loadModules = function(mainModule, isSync) {
      var _this = this;
      var loading = [];
      var mainNgModule = ((this._metadataResolver.getNgModuleMetadata(mainModule)));
      this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach(function(nestedNgModule) {
        var moduleMeta = ((_this._metadataResolver.getNgModuleMetadata(nestedNgModule)));
        _this._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach(function(ref) {
          var promise = _this._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);
          if (promise) {
            loading.push(promise);
          }
        });
        _this._filterJitIdentifiers(moduleMeta.declaredPipes).forEach(function(ref) {
          return _this._metadataResolver.getOrLoadPipeMetadata(ref);
        });
      });
      return SyncAsync.all(loading);
    };
    JitCompiler.prototype._compileModule = function(moduleType) {
      var _this = this;
      var ngModuleFactory = ((this._compiledNgModuleCache.get(moduleType)));
      if (!ngModuleFactory) {
        var moduleMeta_1 = ((this._metadataResolver.getNgModuleMetadata(moduleType)));
        var extraProviders = [this._metadataResolver.getProviderMetadata(new ProviderMeta(_angular_core.Compiler, {useFactory: function() {
            return new ModuleBoundCompiler(_this, moduleMeta_1.type.reference);
          }}))];
        var outputCtx = createOutputContext();
        var compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta_1, extraProviders);
        if (!this._compilerConfig.useJit) {
          ngModuleFactory = interpretStatements(outputCtx.statements)[compileResult.ngModuleFactoryVar];
        } else {
          ngModuleFactory = jitStatements(ngModuleJitUrl(moduleMeta_1), outputCtx.statements)[compileResult.ngModuleFactoryVar];
        }
        this._compiledNgModuleCache.set(moduleMeta_1.type.reference, ngModuleFactory);
      }
      return ngModuleFactory;
    };
    JitCompiler.prototype._compileComponents = function(mainModule, allComponentFactories) {
      var _this = this;
      var ngModule = ((this._metadataResolver.getNgModuleMetadata(mainModule)));
      var moduleByJitDirective = new Map();
      var templates = new Set();
      var transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);
      transJitModules.forEach(function(localMod) {
        var localModuleMeta = ((_this._metadataResolver.getNgModuleMetadata(localMod)));
        _this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function(dirRef) {
          moduleByJitDirective.set(dirRef, localModuleMeta);
          var dirMeta = _this._metadataResolver.getDirectiveMetadata(dirRef);
          if (dirMeta.isComponent) {
            templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));
            if (allComponentFactories) {
              var template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);
              templates.add(template);
              allComponentFactories.push((dirMeta.componentFactory));
            }
          }
        });
      });
      transJitModules.forEach(function(localMod) {
        var localModuleMeta = ((_this._metadataResolver.getNgModuleMetadata(localMod)));
        _this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function(dirRef) {
          var dirMeta = _this._metadataResolver.getDirectiveMetadata(dirRef);
          if (dirMeta.isComponent) {
            dirMeta.entryComponents.forEach(function(entryComponentType) {
              var moduleMeta = ((moduleByJitDirective.get(entryComponentType.componentType)));
              templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));
            });
          }
        });
        localModuleMeta.entryComponents.forEach(function(entryComponentType) {
          if (!_this.hasAotSummary(entryComponentType.componentType.reference)) {
            var moduleMeta = ((moduleByJitDirective.get(entryComponentType.componentType)));
            templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));
          }
        });
      });
      templates.forEach(function(template) {
        return _this._compileTemplate(template);
      });
    };
    JitCompiler.prototype.clearCacheFor = function(type) {
      this._compiledNgModuleCache.delete(type);
      this._metadataResolver.clearCacheFor(type);
      this._compiledHostTemplateCache.delete(type);
      var compiledTemplate = this._compiledTemplateCache.get(type);
      if (compiledTemplate) {
        this._compiledTemplateCache.delete(type);
      }
    };
    JitCompiler.prototype.clearCache = function() {
      this._metadataResolver.clearCache();
      this._compiledTemplateCache.clear();
      this._compiledHostTemplateCache.clear();
      this._compiledNgModuleCache.clear();
    };
    JitCompiler.prototype._createCompiledHostTemplate = function(compType, ngModule) {
      if (!ngModule) {
        throw new Error("Component " + _angular_core.ɵstringify(compType) + " is not part of any NgModule or the module has not been imported into your module.");
      }
      var compiledTemplate = this._compiledHostTemplateCache.get(compType);
      if (!compiledTemplate) {
        var compMeta = this._metadataResolver.getDirectiveMetadata(compType);
        assertComponent(compMeta);
        var componentFactory = (compMeta.componentFactory);
        var hostClass = this._metadataResolver.getHostComponentType(compType);
        var hostMeta = createHostComponentMeta(hostClass, compMeta, (_angular_core.ɵgetComponentViewDefinitionFactory(componentFactory)));
        compiledTemplate = new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);
        this._compiledHostTemplateCache.set(compType, compiledTemplate);
      }
      return compiledTemplate;
    };
    JitCompiler.prototype._createCompiledTemplate = function(compMeta, ngModule) {
      var compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);
      if (!compiledTemplate) {
        assertComponent(compMeta);
        compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);
        this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);
      }
      return compiledTemplate;
    };
    JitCompiler.prototype._compileTemplate = function(template) {
      var _this = this;
      if (template.isCompiled) {
        return;
      }
      var compMeta = template.compMeta;
      var externalStylesheetsByModuleUrl = new Map();
      var outputContext = createOutputContext();
      var componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta);
      ((compMeta.template)).externalStylesheets.forEach(function(stylesheetMeta) {
        var compiledStylesheet = _this._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);
        externalStylesheetsByModuleUrl.set(((stylesheetMeta.moduleUrl)), compiledStylesheet);
      });
      this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);
      var directives = template.directives.map(function(dir) {
        return _this._metadataResolver.getDirectiveSummary(dir.reference);
      });
      var pipes = template.ngModule.transitiveModule.pipes.map(function(pipe) {
        return _this._metadataResolver.getPipeSummary(pipe.reference);
      });
      var _a = this._templateParser.parse(compMeta, ((((compMeta.template)).template)), directives, pipes, template.ngModule.schemas, templateSourceUrl(template.ngModule.type, template.compMeta, ((template.compMeta.template)))),
          parsedTemplate = _a.template,
          usedPipes = _a.pipes;
      var compileResult = this._viewCompiler.compileComponent(outputContext, compMeta, parsedTemplate, variable(componentStylesheet.stylesVar), usedPipes);
      var evalResult;
      if (!this._compilerConfig.useJit) {
        evalResult = interpretStatements(outputContext.statements);
      } else {
        evalResult = jitStatements(templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);
      }
      var viewClass = evalResult[compileResult.viewClassVar];
      var rendererType = evalResult[compileResult.rendererTypeVar];
      template.compiled(viewClass, rendererType);
    };
    JitCompiler.prototype._resolveStylesCompileResult = function(result, externalStylesheetsByModuleUrl) {
      var _this = this;
      result.dependencies.forEach(function(dep, i) {
        var nestedCompileResult = ((externalStylesheetsByModuleUrl.get(dep.moduleUrl)));
        var nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);
        dep.setValue(nestedStylesArr);
      });
    };
    JitCompiler.prototype._resolveAndEvalStylesCompileResult = function(result, externalStylesheetsByModuleUrl) {
      this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);
      if (!this._compilerConfig.useJit) {
        return interpretStatements(result.outputCtx.statements)[result.stylesVar];
      } else {
        return jitStatements(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.outputCtx.statements)[result.stylesVar];
      }
    };
    return JitCompiler;
  }());
  JitCompiler.decorators = [{type: CompilerInjectable}];
  JitCompiler.ctorParameters = function() {
    return [{type: _angular_core.Injector}, {type: CompileMetadataResolver}, {type: TemplateParser}, {type: StyleCompiler}, {type: ViewCompiler}, {type: NgModuleCompiler}, {type: SummaryResolver}, {type: CompilerConfig}, {type: _angular_core.ɵConsole}];
  };
  var CompiledTemplate = (function() {
    function CompiledTemplate(isHost, compType, compMeta, ngModule, directives) {
      this.isHost = isHost;
      this.compType = compType;
      this.compMeta = compMeta;
      this.ngModule = ngModule;
      this.directives = directives;
      this._viewClass = ((null));
      this.isCompiled = false;
    }
    CompiledTemplate.prototype.compiled = function(viewClass, rendererType) {
      this._viewClass = viewClass;
      ((this.compMeta.componentViewType)).setDelegate(viewClass);
      for (var prop in rendererType) {
        ((this.compMeta.rendererType))[prop] = rendererType[prop];
      }
      this.isCompiled = true;
    };
    return CompiledTemplate;
  }());
  function assertComponent(meta) {
    if (!meta.isComponent) {
      throw new Error("Could not compile '" + identifierName(meta.type) + "' because it is not a component.");
    }
  }
  var ModuleBoundCompiler = (function() {
    function ModuleBoundCompiler(_delegate, _ngModule) {
      this._delegate = _delegate;
      this._ngModule = _ngModule;
    }
    Object.defineProperty(ModuleBoundCompiler.prototype, "_injector", {
      get: function() {
        return this._delegate.injector;
      },
      enumerable: true,
      configurable: true
    });
    ModuleBoundCompiler.prototype.compileModuleSync = function(moduleType) {
      return this._delegate.compileModuleSync(moduleType);
    };
    ModuleBoundCompiler.prototype.compileModuleAsync = function(moduleType) {
      return this._delegate.compileModuleAsync(moduleType);
    };
    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsSync = function(moduleType) {
      return this._delegate.compileModuleAndAllComponentsSync(moduleType);
    };
    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsAsync = function(moduleType) {
      return this._delegate.compileModuleAndAllComponentsAsync(moduleType);
    };
    ModuleBoundCompiler.prototype.getNgContentSelectors = function(component) {
      return this._delegate.getNgContentSelectors(component);
    };
    ModuleBoundCompiler.prototype.clearCache = function() {
      this._delegate.clearCache();
    };
    ModuleBoundCompiler.prototype.clearCacheFor = function(type) {
      this._delegate.clearCacheFor(type);
    };
    return ModuleBoundCompiler;
  }());
  function flattenSummaries(fn$$1, out) {
    if (out === void 0) {
      out = [];
    }
    fn$$1().forEach(function(entry) {
      if (typeof entry === 'function') {
        flattenSummaries(entry, out);
      } else {
        out.push(entry);
      }
    });
    return out;
  }
  function createOutputContext() {
    var importExpr$$1 = function(symbol) {
      return importExpr({
        name: identifierName(symbol),
        moduleName: null,
        runtime: symbol
      });
    };
    return {
      statements: [],
      genFilePath: '',
      importExpr: importExpr$$1
    };
  }
  var MessageBundle = (function() {
    function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs, _locale) {
      if (_locale === void 0) {
        _locale = null;
      }
      this._htmlParser = _htmlParser;
      this._implicitTags = _implicitTags;
      this._implicitAttrs = _implicitAttrs;
      this._locale = _locale;
      this._messages = [];
    }
    MessageBundle.prototype.updateFromTemplate = function(html, url, interpolationConfig) {
      var htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);
      if (htmlParserResult.errors.length) {
        return htmlParserResult.errors;
      }
      var i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);
      if (i18nParserResult.errors.length) {
        return i18nParserResult.errors;
      }
      (_a = this._messages).push.apply(_a, i18nParserResult.messages);
      return [];
      var _a;
    };
    MessageBundle.prototype.getMessages = function() {
      return this._messages;
    };
    MessageBundle.prototype.write = function(serializer, filterSources) {
      var messages = {};
      var mapperVisitor = new MapPlaceholderNames();
      this._messages.forEach(function(message) {
        var id = serializer.digest(message);
        if (!messages.hasOwnProperty(id)) {
          messages[id] = message;
        } else {
          (_a = messages[id].sources).push.apply(_a, message.sources);
        }
        var _a;
      });
      var msgList = Object.keys(messages).map(function(id) {
        var mapper = serializer.createNameMapper(messages[id]);
        var src = messages[id];
        var nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;
        var transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);
        transformedMessage.sources = src.sources;
        if (filterSources) {
          transformedMessage.sources.forEach(function(source) {
            return source.filePath = filterSources(source.filePath);
          });
        }
        return transformedMessage;
      });
      return serializer.write(msgList, this._locale);
    };
    return MessageBundle;
  }());
  var MapPlaceholderNames = (function(_super) {
    __extends(MapPlaceholderNames, _super);
    function MapPlaceholderNames() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MapPlaceholderNames.prototype.convert = function(nodes, mapper) {
      var _this = this;
      return mapper ? nodes.map(function(n) {
        return n.visit(_this, mapper);
      }) : nodes;
    };
    MapPlaceholderNames.prototype.visitTagPlaceholder = function(ph, mapper) {
      var _this = this;
      var startName = ((mapper.toPublicName(ph.startName)));
      var closeName = ph.closeName ? ((mapper.toPublicName(ph.closeName))) : ph.closeName;
      var children = ph.children.map(function(n) {
        return n.visit(_this, mapper);
      });
      return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan);
    };
    MapPlaceholderNames.prototype.visitPlaceholder = function(ph, mapper) {
      return new Placeholder(ph.value, ((mapper.toPublicName(ph.name))), ph.sourceSpan);
    };
    MapPlaceholderNames.prototype.visitIcuPlaceholder = function(ph, mapper) {
      return new IcuPlaceholder(ph.value, ((mapper.toPublicName(ph.name))), ph.sourceSpan);
    };
    return MapPlaceholderNames;
  }(CloneVisitor));
  var Extractor = (function() {
    function Extractor(host, staticSymbolResolver, messageBundle, metadataResolver) {
      this.host = host;
      this.staticSymbolResolver = staticSymbolResolver;
      this.messageBundle = messageBundle;
      this.metadataResolver = metadataResolver;
    }
    Extractor.prototype.extract = function(rootFiles) {
      var _this = this;
      var programSymbols = extractProgramSymbols(this.staticSymbolResolver, rootFiles, this.host);
      var _a = analyzeAndValidateNgModules(programSymbols, this.host, this.metadataResolver),
          files = _a.files,
          ngModules = _a.ngModules;
      return Promise.all(ngModules.map(function(ngModule) {
        return _this.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false);
      })).then(function() {
        var errors = [];
        files.forEach(function(file) {
          var compMetas = [];
          file.directives.forEach(function(directiveType) {
            var dirMeta = _this.metadataResolver.getDirectiveMetadata(directiveType);
            if (dirMeta && dirMeta.isComponent) {
              compMetas.push(dirMeta);
            }
          });
          compMetas.forEach(function(compMeta) {
            var html = ((((compMeta.template)).template));
            var interpolationConfig = InterpolationConfig.fromArray(((compMeta.template)).interpolation);
            errors.push.apply(errors, ((_this.messageBundle.updateFromTemplate(html, file.srcUrl, interpolationConfig))));
          });
        });
        if (errors.length) {
          throw new Error(errors.map(function(e) {
            return e.toString();
          }).join('\n'));
        }
        return _this.messageBundle;
      });
    };
    Extractor.create = function(host, locale) {
      var htmlParser = new HtmlParser();
      var urlResolver = createOfflineCompileUrlResolver();
      var symbolCache = new StaticSymbolCache();
      var summaryResolver = new AotSummaryResolver(host, symbolCache);
      var staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);
      var staticReflector = new StaticReflector(summaryResolver, staticSymbolResolver);
      var config = new CompilerConfig({
        defaultEncapsulation: _angular_core.ViewEncapsulation.Emulated,
        useJit: false
      });
      var normalizer = new DirectiveNormalizer({get: function(url) {
          return host.loadResource(url);
        }}, urlResolver, htmlParser, config);
      var elementSchemaRegistry = new DomElementSchemaRegistry();
      var resolver = new CompileMetadataResolver(config, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, new _angular_core.ɵConsole(), symbolCache, staticReflector);
      var messageBundle = new MessageBundle(htmlParser, [], {}, locale);
      var extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);
      return {
        extractor: extractor,
        staticReflector: staticReflector
      };
    };
    return Extractor;
  }());
  var JitReflector = (function() {
    function JitReflector() {
      this.reflectionCapabilities = new _angular_core.ɵReflectionCapabilities();
    }
    JitReflector.prototype.componentModuleUrl = function(type, cmpMetadata) {
      var moduleId = cmpMetadata.moduleId;
      if (typeof moduleId === 'string') {
        var scheme = getUrlScheme(moduleId);
        return scheme ? moduleId : "package:" + moduleId + MODULE_SUFFIX;
      } else if (moduleId !== null && moduleId !== void 0) {
        throw syntaxError("moduleId should be a string in \"" + _angular_core.ɵstringify(type) + "\". See https://goo.gl/wIDDiL for more information.\n" + "If you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.");
      }
      return "./" + _angular_core.ɵstringify(type);
    };
    JitReflector.prototype.parameters = function(typeOrFunc) {
      return this.reflectionCapabilities.parameters(typeOrFunc);
    };
    JitReflector.prototype.annotations = function(typeOrFunc) {
      return this.reflectionCapabilities.annotations(typeOrFunc);
    };
    JitReflector.prototype.propMetadata = function(typeOrFunc) {
      return this.reflectionCapabilities.propMetadata(typeOrFunc);
    };
    JitReflector.prototype.hasLifecycleHook = function(type, lcProperty) {
      return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
    };
    JitReflector.prototype.resolveExternalReference = function(ref) {
      return ref.runtime;
    };
    return JitReflector;
  }());
  var _NO_RESOURCE_LOADER = {get: function(url) {
      throw new Error("No ResourceLoader implementation has been provided. Can't read the url \"" + url + "\"");
    }};
  var baseHtmlParser = new _angular_core.InjectionToken('HtmlParser');
  var COMPILER_PROVIDERS = [{
    provide: CompileReflector,
    useValue: new JitReflector()
  }, {
    provide: ResourceLoader,
    useValue: _NO_RESOURCE_LOADER
  }, JitSummaryResolver, {
    provide: SummaryResolver,
    useExisting: JitSummaryResolver
  }, _angular_core.ɵConsole, Lexer, Parser, {
    provide: baseHtmlParser,
    useClass: HtmlParser
  }, {
    provide: I18NHtmlParser,
    useFactory: function(parser, translations, format, config, console) {
      translations = translations || '';
      var missingTranslation = translations ? config.missingTranslation : _angular_core.MissingTranslationStrategy.Ignore;
      return new I18NHtmlParser(parser, translations, format, missingTranslation, console);
    },
    deps: [baseHtmlParser, [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS)], [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS_FORMAT)], [CompilerConfig], [_angular_core.ɵConsole]]
  }, {
    provide: HtmlParser,
    useExisting: I18NHtmlParser
  }, TemplateParser, DirectiveNormalizer, CompileMetadataResolver, DEFAULT_PACKAGE_URL_PROVIDER, StyleCompiler, ViewCompiler, NgModuleCompiler, {
    provide: CompilerConfig,
    useValue: new CompilerConfig()
  }, JitCompiler, {
    provide: _angular_core.Compiler,
    useExisting: JitCompiler
  }, DomElementSchemaRegistry, {
    provide: ElementSchemaRegistry,
    useExisting: DomElementSchemaRegistry
  }, UrlResolver, DirectiveResolver, PipeResolver, NgModuleResolver];
  var JitCompilerFactory = (function() {
    function JitCompilerFactory(defaultOptions) {
      var compilerOptions = {
        useDebug: _angular_core.isDevMode(),
        useJit: true,
        defaultEncapsulation: _angular_core.ViewEncapsulation.Emulated,
        missingTranslation: _angular_core.MissingTranslationStrategy.Warning,
        enableLegacyTemplate: true
      };
      this._defaultOptions = [compilerOptions].concat(defaultOptions);
    }
    JitCompilerFactory.prototype.createCompiler = function(options) {
      if (options === void 0) {
        options = [];
      }
      var opts = _mergeOptions(this._defaultOptions.concat(options));
      var injector = _angular_core.ReflectiveInjector.resolveAndCreate([COMPILER_PROVIDERS, {
        provide: CompilerConfig,
        useFactory: function() {
          return new CompilerConfig({
            useJit: opts.useJit,
            defaultEncapsulation: opts.defaultEncapsulation,
            missingTranslation: opts.missingTranslation,
            enableLegacyTemplate: opts.enableLegacyTemplate
          });
        },
        deps: []
      }, ((opts.providers))]);
      return injector.get(_angular_core.Compiler);
    };
    return JitCompilerFactory;
  }());
  JitCompilerFactory.decorators = [{type: CompilerInjectable}];
  JitCompilerFactory.ctorParameters = function() {
    return [{
      type: Array,
      decorators: [{
        type: _angular_core.Inject,
        args: [_angular_core.COMPILER_OPTIONS]
      }]
    }];
  };
  var platformCoreDynamic = _angular_core.createPlatformFactory(_angular_core.platformCore, 'coreDynamic', [{
    provide: _angular_core.COMPILER_OPTIONS,
    useValue: {},
    multi: true
  }, {
    provide: _angular_core.CompilerFactory,
    useClass: JitCompilerFactory
  }]);
  function _mergeOptions(optionsArr) {
    return {
      useJit: _lastDefined(optionsArr.map(function(options) {
        return options.useJit;
      })),
      defaultEncapsulation: _lastDefined(optionsArr.map(function(options) {
        return options.defaultEncapsulation;
      })),
      providers: _mergeArrays(optionsArr.map(function(options) {
        return ((options.providers));
      })),
      missingTranslation: _lastDefined(optionsArr.map(function(options) {
        return options.missingTranslation;
      })),
      enableLegacyTemplate: _lastDefined(optionsArr.map(function(options) {
        return options.enableLegacyTemplate;
      }))
    };
  }
  function _lastDefined(args) {
    for (var i = args.length - 1; i >= 0; i--) {
      if (args[i] !== undefined) {
        return args[i];
      }
    }
    return undefined;
  }
  function _mergeArrays(parts) {
    var result = [];
    parts.forEach(function(part) {
      return part && result.push.apply(result, part);
    });
    return result;
  }
  exports.VERSION = VERSION;
  exports.TEMPLATE_TRANSFORMS = TEMPLATE_TRANSFORMS;
  exports.CompilerConfig = CompilerConfig;
  exports.JitCompiler = JitCompiler;
  exports.DirectiveResolver = DirectiveResolver;
  exports.PipeResolver = PipeResolver;
  exports.NgModuleResolver = NgModuleResolver;
  exports.DEFAULT_INTERPOLATION_CONFIG = DEFAULT_INTERPOLATION_CONFIG;
  exports.InterpolationConfig = InterpolationConfig;
  exports.NgModuleCompiler = NgModuleCompiler;
  exports.AssertNotNull = AssertNotNull;
  exports.BinaryOperator = BinaryOperator;
  exports.BinaryOperatorExpr = BinaryOperatorExpr;
  exports.BuiltinMethod = BuiltinMethod;
  exports.BuiltinVar = BuiltinVar;
  exports.CastExpr = CastExpr;
  exports.ClassStmt = ClassStmt;
  exports.CommaExpr = CommaExpr;
  exports.CommentStmt = CommentStmt;
  exports.ConditionalExpr = ConditionalExpr;
  exports.DeclareFunctionStmt = DeclareFunctionStmt;
  exports.DeclareVarStmt = DeclareVarStmt;
  exports.ExpressionStatement = ExpressionStatement;
  exports.ExternalExpr = ExternalExpr;
  exports.ExternalReference = ExternalReference;
  exports.FunctionExpr = FunctionExpr;
  exports.IfStmt = IfStmt;
  exports.InstantiateExpr = InstantiateExpr;
  exports.InvokeFunctionExpr = InvokeFunctionExpr;
  exports.InvokeMethodExpr = InvokeMethodExpr;
  exports.LiteralArrayExpr = LiteralArrayExpr;
  exports.LiteralExpr = LiteralExpr;
  exports.LiteralMapExpr = LiteralMapExpr;
  exports.NotExpr = NotExpr;
  exports.ReadKeyExpr = ReadKeyExpr;
  exports.ReadPropExpr = ReadPropExpr;
  exports.ReadVarExpr = ReadVarExpr;
  exports.ReturnStatement = ReturnStatement;
  exports.ThrowStmt = ThrowStmt;
  exports.TryCatchStmt = TryCatchStmt;
  exports.WriteKeyExpr = WriteKeyExpr;
  exports.WritePropExpr = WritePropExpr;
  exports.WriteVarExpr = WriteVarExpr;
  exports.StmtModifier = StmtModifier;
  exports.Statement = Statement;
  exports.EmitterVisitorContext = EmitterVisitorContext;
  exports.ViewCompiler = ViewCompiler;
  exports.getParseErrors = getParseErrors;
  exports.isSyntaxError = isSyntaxError;
  exports.syntaxError = syntaxError;
  exports.TextAst = TextAst;
  exports.BoundTextAst = BoundTextAst;
  exports.AttrAst = AttrAst;
  exports.BoundElementPropertyAst = BoundElementPropertyAst;
  exports.BoundEventAst = BoundEventAst;
  exports.ReferenceAst = ReferenceAst;
  exports.VariableAst = VariableAst;
  exports.ElementAst = ElementAst;
  exports.EmbeddedTemplateAst = EmbeddedTemplateAst;
  exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;
  exports.DirectiveAst = DirectiveAst;
  exports.ProviderAst = ProviderAst;
  exports.ProviderAstType = ProviderAstType;
  exports.NgContentAst = NgContentAst;
  exports.PropertyBindingType = PropertyBindingType;
  exports.NullTemplateVisitor = NullTemplateVisitor;
  exports.RecursiveTemplateAstVisitor = RecursiveTemplateAstVisitor;
  exports.templateVisitAll = templateVisitAll;
  exports.CompileAnimationEntryMetadata = CompileAnimationEntryMetadata;
  exports.CompileAnimationStateMetadata = CompileAnimationStateMetadata;
  exports.CompileAnimationStateDeclarationMetadata = CompileAnimationStateDeclarationMetadata;
  exports.CompileAnimationStateTransitionMetadata = CompileAnimationStateTransitionMetadata;
  exports.CompileAnimationMetadata = CompileAnimationMetadata;
  exports.CompileAnimationKeyframesSequenceMetadata = CompileAnimationKeyframesSequenceMetadata;
  exports.CompileAnimationStyleMetadata = CompileAnimationStyleMetadata;
  exports.CompileAnimationAnimateMetadata = CompileAnimationAnimateMetadata;
  exports.CompileAnimationWithStepsMetadata = CompileAnimationWithStepsMetadata;
  exports.CompileAnimationSequenceMetadata = CompileAnimationSequenceMetadata;
  exports.CompileAnimationGroupMetadata = CompileAnimationGroupMetadata;
  exports.identifierName = identifierName;
  exports.identifierModuleUrl = identifierModuleUrl;
  exports.viewClassName = viewClassName;
  exports.rendererTypeName = rendererTypeName;
  exports.hostViewClassName = hostViewClassName;
  exports.componentFactoryName = componentFactoryName;
  exports.CompileSummaryKind = CompileSummaryKind;
  exports.tokenName = tokenName;
  exports.tokenReference = tokenReference;
  exports.CompileStylesheetMetadata = CompileStylesheetMetadata;
  exports.CompileTemplateMetadata = CompileTemplateMetadata;
  exports.CompileDirectiveMetadata = CompileDirectiveMetadata;
  exports.createHostComponentMeta = createHostComponentMeta;
  exports.CompilePipeMetadata = CompilePipeMetadata;
  exports.CompileNgModuleMetadata = CompileNgModuleMetadata;
  exports.TransitiveCompileNgModuleMetadata = TransitiveCompileNgModuleMetadata;
  exports.ProviderMeta = ProviderMeta;
  exports.flatten = flatten;
  exports.sourceUrl = sourceUrl;
  exports.templateSourceUrl = templateSourceUrl;
  exports.sharedStylesheetJitUrl = sharedStylesheetJitUrl;
  exports.ngModuleJitUrl = ngModuleJitUrl;
  exports.templateJitUrl = templateJitUrl;
  exports.createAotCompiler = createAotCompiler;
  exports.AotCompiler = AotCompiler;
  exports.analyzeNgModules = analyzeNgModules;
  exports.analyzeAndValidateNgModules = analyzeAndValidateNgModules;
  exports.extractProgramSymbols = extractProgramSymbols;
  exports.GeneratedFile = GeneratedFile;
  exports.toTypeScript = toTypeScript;
  exports.StaticReflector = StaticReflector;
  exports.StaticSymbol = StaticSymbol;
  exports.StaticSymbolCache = StaticSymbolCache;
  exports.ResolvedStaticSymbol = ResolvedStaticSymbol;
  exports.StaticSymbolResolver = StaticSymbolResolver;
  exports.unescapeIdentifier = unescapeIdentifier;
  exports.AotSummaryResolver = AotSummaryResolver;
  exports.AstPath = AstPath;
  exports.SummaryResolver = SummaryResolver;
  exports.JitSummaryResolver = JitSummaryResolver;
  exports.COMPILER_PROVIDERS = COMPILER_PROVIDERS;
  exports.JitCompilerFactory = JitCompilerFactory;
  exports.platformCoreDynamic = platformCoreDynamic;
  exports.JitReflector = JitReflector;
  exports.CompileReflector = CompileReflector;
  exports.createUrlResolverWithoutPackagePrefix = createUrlResolverWithoutPackagePrefix;
  exports.createOfflineCompileUrlResolver = createOfflineCompileUrlResolver;
  exports.DEFAULT_PACKAGE_URL_PROVIDER = DEFAULT_PACKAGE_URL_PROVIDER;
  exports.UrlResolver = UrlResolver;
  exports.getUrlScheme = getUrlScheme;
  exports.ResourceLoader = ResourceLoader;
  exports.ElementSchemaRegistry = ElementSchemaRegistry;
  exports.Extractor = Extractor;
  exports.I18NHtmlParser = I18NHtmlParser;
  exports.MessageBundle = MessageBundle;
  exports.Serializer = Serializer;
  exports.Xliff = Xliff;
  exports.Xliff2 = Xliff2;
  exports.Xmb = Xmb;
  exports.Xtb = Xtb;
  exports.DirectiveNormalizer = DirectiveNormalizer;
  exports.ParserError = ParserError;
  exports.ParseSpan = ParseSpan;
  exports.AST = AST;
  exports.Quote = Quote;
  exports.EmptyExpr = EmptyExpr;
  exports.ImplicitReceiver = ImplicitReceiver;
  exports.Chain = Chain;
  exports.Conditional = Conditional;
  exports.PropertyRead = PropertyRead;
  exports.PropertyWrite = PropertyWrite;
  exports.SafePropertyRead = SafePropertyRead;
  exports.KeyedRead = KeyedRead;
  exports.KeyedWrite = KeyedWrite;
  exports.BindingPipe = BindingPipe;
  exports.LiteralPrimitive = LiteralPrimitive;
  exports.LiteralArray = LiteralArray;
  exports.LiteralMap = LiteralMap;
  exports.Interpolation = Interpolation;
  exports.Binary = Binary;
  exports.PrefixNot = PrefixNot;
  exports.NonNullAssert = NonNullAssert;
  exports.MethodCall = MethodCall;
  exports.SafeMethodCall = SafeMethodCall;
  exports.FunctionCall = FunctionCall;
  exports.ASTWithSource = ASTWithSource;
  exports.TemplateBinding = TemplateBinding;
  exports.NullAstVisitor = NullAstVisitor;
  exports.RecursiveAstVisitor = RecursiveAstVisitor;
  exports.AstTransformer = AstTransformer;
  exports.visitAstChildren = visitAstChildren;
  exports.TokenType = TokenType;
  exports.Lexer = Lexer;
  exports.Token = Token;
  exports.EOF = EOF;
  exports.isIdentifier = isIdentifier;
  exports.isQuote = isQuote;
  exports.SplitInterpolation = SplitInterpolation;
  exports.TemplateBindingParseResult = TemplateBindingParseResult;
  exports.Parser = Parser;
  exports._ParseAST = _ParseAST;
  exports.ERROR_COLLECTOR_TOKEN = ERROR_COLLECTOR_TOKEN;
  exports.CompileMetadataResolver = CompileMetadataResolver;
  exports.Text = Text;
  exports.Expansion = Expansion;
  exports.ExpansionCase = ExpansionCase;
  exports.Attribute = Attribute$1;
  exports.Element = Element;
  exports.Comment = Comment;
  exports.visitAll = visitAll;
  exports.RecursiveVisitor = RecursiveVisitor;
  exports.findNode = findNode;
  exports.ParseTreeResult = ParseTreeResult;
  exports.TreeError = TreeError;
  exports.HtmlParser = HtmlParser;
  exports.HtmlTagDefinition = HtmlTagDefinition;
  exports.getHtmlTagDefinition = getHtmlTagDefinition;
  exports.TagContentType = TagContentType;
  exports.splitNsName = splitNsName;
  exports.isNgContainer = isNgContainer;
  exports.isNgContent = isNgContent;
  exports.isNgTemplate = isNgTemplate;
  exports.getNsPrefix = getNsPrefix;
  exports.mergeNsAndName = mergeNsAndName;
  exports.NAMED_ENTITIES = NAMED_ENTITIES;
  exports.debugOutputAstAsTypeScript = debugOutputAstAsTypeScript;
  exports.TypeScriptEmitter = TypeScriptEmitter;
  exports.ParseLocation = ParseLocation;
  exports.ParseSourceFile = ParseSourceFile;
  exports.ParseSourceSpan = ParseSourceSpan;
  exports.ParseErrorLevel = ParseErrorLevel;
  exports.ParseError = ParseError;
  exports.typeSourceSpan = typeSourceSpan;
  exports.DomElementSchemaRegistry = DomElementSchemaRegistry;
  exports.CssSelector = CssSelector;
  exports.SelectorMatcher = SelectorMatcher;
  exports.SelectorListContext = SelectorListContext;
  exports.SelectorContext = SelectorContext;
  exports.StylesCompileDependency = StylesCompileDependency;
  exports.CompiledStylesheet = CompiledStylesheet;
  exports.StyleCompiler = StyleCompiler;
  exports.TemplateParseError = TemplateParseError;
  exports.TemplateParseResult = TemplateParseResult;
  exports.TemplateParser = TemplateParser;
  exports.splitClasses = splitClasses;
  exports.createElementCssSelector = createElementCssSelector;
  exports.removeSummaryDuplicates = removeSummaryDuplicates;
  Object.defineProperty(exports, '__esModule', {value: true});
})));

})();
(function() {
var define = System.amdDefine;
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) : typeof define === 'function' && define.amd ? define("node_modules/@angular/common/bundles/common.umd.js", ["exports", "node_modules/@angular/core/bundles/core.umd.js"], factory) : (factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}), global.ng.core));
}(this, (function(exports, _angular_core) {
  'use strict';
  var extendStatics = Object.setPrototypeOf || ({__proto__: []} instanceof Array && function(d, b) {
    d.__proto__ = b;
  }) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
  };
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var PlatformLocation = (function() {
    function PlatformLocation() {}
    PlatformLocation.prototype.getBaseHrefFromDOM = function() {};
    PlatformLocation.prototype.onPopState = function(fn) {};
    PlatformLocation.prototype.onHashChange = function(fn) {};
    PlatformLocation.prototype.pathname = function() {};
    PlatformLocation.prototype.search = function() {};
    PlatformLocation.prototype.hash = function() {};
    PlatformLocation.prototype.replaceState = function(state, title, url) {};
    PlatformLocation.prototype.pushState = function(state, title, url) {};
    PlatformLocation.prototype.forward = function() {};
    PlatformLocation.prototype.back = function() {};
    return PlatformLocation;
  }());
  var LOCATION_INITIALIZED = new _angular_core.InjectionToken('Location Initialized');
  var LocationStrategy = (function() {
    function LocationStrategy() {}
    LocationStrategy.prototype.path = function(includeHash) {};
    LocationStrategy.prototype.prepareExternalUrl = function(internal) {};
    LocationStrategy.prototype.pushState = function(state, title, url, queryParams) {};
    LocationStrategy.prototype.replaceState = function(state, title, url, queryParams) {};
    LocationStrategy.prototype.forward = function() {};
    LocationStrategy.prototype.back = function() {};
    LocationStrategy.prototype.onPopState = function(fn) {};
    LocationStrategy.prototype.getBaseHref = function() {};
    return LocationStrategy;
  }());
  var APP_BASE_HREF = new _angular_core.InjectionToken('appBaseHref');
  var Location = (function() {
    function Location(platformStrategy) {
      var _this = this;
      this._subject = new _angular_core.EventEmitter();
      this._platformStrategy = platformStrategy;
      var browserBaseHref = this._platformStrategy.getBaseHref();
      this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
      this._platformStrategy.onPopState(function(ev) {
        _this._subject.emit({
          'url': _this.path(true),
          'pop': true,
          'type': ev.type
        });
      });
    }
    Location.prototype.path = function(includeHash) {
      if (includeHash === void 0) {
        includeHash = false;
      }
      return this.normalize(this._platformStrategy.path(includeHash));
    };
    Location.prototype.isCurrentPathEqualTo = function(path, query) {
      if (query === void 0) {
        query = '';
      }
      return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
    };
    Location.prototype.normalize = function(url) {
      return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
    };
    Location.prototype.prepareExternalUrl = function(url) {
      if (url && url[0] !== '/') {
        url = '/' + url;
      }
      return this._platformStrategy.prepareExternalUrl(url);
    };
    Location.prototype.go = function(path, query) {
      if (query === void 0) {
        query = '';
      }
      this._platformStrategy.pushState(null, '', path, query);
    };
    Location.prototype.replaceState = function(path, query) {
      if (query === void 0) {
        query = '';
      }
      this._platformStrategy.replaceState(null, '', path, query);
    };
    Location.prototype.forward = function() {
      this._platformStrategy.forward();
    };
    Location.prototype.back = function() {
      this._platformStrategy.back();
    };
    Location.prototype.subscribe = function(onNext, onThrow, onReturn) {
      return this._subject.subscribe({
        next: onNext,
        error: onThrow,
        complete: onReturn
      });
    };
    Location.normalizeQueryParams = function(params) {
      return params && params[0] !== '?' ? '?' + params : params;
    };
    Location.joinWithSlash = function(start, end) {
      if (start.length == 0) {
        return end;
      }
      if (end.length == 0) {
        return start;
      }
      var slashes = 0;
      if (start.endsWith('/')) {
        slashes++;
      }
      if (end.startsWith('/')) {
        slashes++;
      }
      if (slashes == 2) {
        return start + end.substring(1);
      }
      if (slashes == 1) {
        return start + end;
      }
      return start + '/' + end;
    };
    Location.stripTrailingSlash = function(url) {
      var match = url.match(/#|\?|$/);
      var pathEndIdx = match && match.index || url.length;
      var droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === '/' ? 1 : 0);
      return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
    };
    return Location;
  }());
  Location.decorators = [{type: _angular_core.Injectable}];
  Location.ctorParameters = function() {
    return [{type: LocationStrategy}];
  };
  function _stripBaseHref(baseHref, url) {
    return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
  }
  function _stripIndexHtml(url) {
    return url.replace(/\/index.html$/, '');
  }
  var HashLocationStrategy = (function(_super) {
    __extends(HashLocationStrategy, _super);
    function HashLocationStrategy(_platformLocation, _baseHref) {
      var _this = _super.call(this) || this;
      _this._platformLocation = _platformLocation;
      _this._baseHref = '';
      if (_baseHref != null) {
        _this._baseHref = _baseHref;
      }
      return _this;
    }
    HashLocationStrategy.prototype.onPopState = function(fn) {
      this._platformLocation.onPopState(fn);
      this._platformLocation.onHashChange(fn);
    };
    HashLocationStrategy.prototype.getBaseHref = function() {
      return this._baseHref;
    };
    HashLocationStrategy.prototype.path = function(includeHash) {
      if (includeHash === void 0) {
        includeHash = false;
      }
      var path = this._platformLocation.hash;
      if (path == null)
        path = '#';
      return path.length > 0 ? path.substring(1) : path;
    };
    HashLocationStrategy.prototype.prepareExternalUrl = function(internal) {
      var url = Location.joinWithSlash(this._baseHref, internal);
      return url.length > 0 ? ('#' + url) : url;
    };
    HashLocationStrategy.prototype.pushState = function(state, title, path, queryParams) {
      var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
      if (url.length == 0) {
        url = this._platformLocation.pathname;
      }
      this._platformLocation.pushState(state, title, url);
    };
    HashLocationStrategy.prototype.replaceState = function(state, title, path, queryParams) {
      var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
      if (url.length == 0) {
        url = this._platformLocation.pathname;
      }
      this._platformLocation.replaceState(state, title, url);
    };
    HashLocationStrategy.prototype.forward = function() {
      this._platformLocation.forward();
    };
    HashLocationStrategy.prototype.back = function() {
      this._platformLocation.back();
    };
    return HashLocationStrategy;
  }(LocationStrategy));
  HashLocationStrategy.decorators = [{type: _angular_core.Injectable}];
  HashLocationStrategy.ctorParameters = function() {
    return [{type: PlatformLocation}, {
      type: undefined,
      decorators: [{type: _angular_core.Optional}, {
        type: _angular_core.Inject,
        args: [APP_BASE_HREF]
      }]
    }];
  };
  var PathLocationStrategy = (function(_super) {
    __extends(PathLocationStrategy, _super);
    function PathLocationStrategy(_platformLocation, href) {
      var _this = _super.call(this) || this;
      _this._platformLocation = _platformLocation;
      if (href == null) {
        href = _this._platformLocation.getBaseHrefFromDOM();
      }
      if (href == null) {
        throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
      }
      _this._baseHref = href;
      return _this;
    }
    PathLocationStrategy.prototype.onPopState = function(fn) {
      this._platformLocation.onPopState(fn);
      this._platformLocation.onHashChange(fn);
    };
    PathLocationStrategy.prototype.getBaseHref = function() {
      return this._baseHref;
    };
    PathLocationStrategy.prototype.prepareExternalUrl = function(internal) {
      return Location.joinWithSlash(this._baseHref, internal);
    };
    PathLocationStrategy.prototype.path = function(includeHash) {
      if (includeHash === void 0) {
        includeHash = false;
      }
      var pathname = this._platformLocation.pathname + Location.normalizeQueryParams(this._platformLocation.search);
      var hash = this._platformLocation.hash;
      return hash && includeHash ? "" + pathname + hash : pathname;
    };
    PathLocationStrategy.prototype.pushState = function(state, title, url, queryParams) {
      var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
      this._platformLocation.pushState(state, title, externalUrl);
    };
    PathLocationStrategy.prototype.replaceState = function(state, title, url, queryParams) {
      var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
      this._platformLocation.replaceState(state, title, externalUrl);
    };
    PathLocationStrategy.prototype.forward = function() {
      this._platformLocation.forward();
    };
    PathLocationStrategy.prototype.back = function() {
      this._platformLocation.back();
    };
    return PathLocationStrategy;
  }(LocationStrategy));
  PathLocationStrategy.decorators = [{type: _angular_core.Injectable}];
  PathLocationStrategy.ctorParameters = function() {
    return [{type: PlatformLocation}, {
      type: undefined,
      decorators: [{type: _angular_core.Optional}, {
        type: _angular_core.Inject,
        args: [APP_BASE_HREF]
      }]
    }];
  };
  var NgLocalization = (function() {
    function NgLocalization() {}
    NgLocalization.prototype.getPluralCategory = function(value) {};
    return NgLocalization;
  }());
  function getPluralCategory(value, cases, ngLocalization) {
    var key = "=" + value;
    if (cases.indexOf(key) > -1) {
      return key;
    }
    key = ngLocalization.getPluralCategory(value);
    if (cases.indexOf(key) > -1) {
      return key;
    }
    if (cases.indexOf('other') > -1) {
      return 'other';
    }
    throw new Error("No plural message found for value \"" + value + "\"");
  }
  var NgLocaleLocalization = (function(_super) {
    __extends(NgLocaleLocalization, _super);
    function NgLocaleLocalization(locale) {
      var _this = _super.call(this) || this;
      _this.locale = locale;
      return _this;
    }
    NgLocaleLocalization.prototype.getPluralCategory = function(value) {
      var plural = getPluralCase(this.locale, value);
      switch (plural) {
        case Plural.Zero:
          return 'zero';
        case Plural.One:
          return 'one';
        case Plural.Two:
          return 'two';
        case Plural.Few:
          return 'few';
        case Plural.Many:
          return 'many';
        default:
          return 'other';
      }
    };
    return NgLocaleLocalization;
  }(NgLocalization));
  NgLocaleLocalization.decorators = [{type: _angular_core.Injectable}];
  NgLocaleLocalization.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [_angular_core.LOCALE_ID]
      }]
    }];
  };
  var Plural = {};
  Plural.Zero = 0;
  Plural.One = 1;
  Plural.Two = 2;
  Plural.Few = 3;
  Plural.Many = 4;
  Plural.Other = 5;
  Plural[Plural.Zero] = "Zero";
  Plural[Plural.One] = "One";
  Plural[Plural.Two] = "Two";
  Plural[Plural.Few] = "Few";
  Plural[Plural.Many] = "Many";
  Plural[Plural.Other] = "Other";
  function getPluralCase(locale, nLike) {
    if (typeof nLike === 'string') {
      nLike = parseInt((nLike), 10);
    }
    var n = (nLike);
    var nDecimal = n.toString().replace(/^[^.]*\.?/, '');
    var i = Math.floor(Math.abs(n));
    var v = nDecimal.length;
    var f = parseInt(nDecimal, 10);
    var t = parseInt(n.toString().replace(/^[^.]*\.?|0+$/g, ''), 10) || 0;
    var lang = locale.split('-')[0].toLowerCase();
    switch (lang) {
      case 'af':
      case 'asa':
      case 'az':
      case 'bem':
      case 'bez':
      case 'bg':
      case 'brx':
      case 'ce':
      case 'cgg':
      case 'chr':
      case 'ckb':
      case 'ee':
      case 'el':
      case 'eo':
      case 'es':
      case 'eu':
      case 'fo':
      case 'fur':
      case 'gsw':
      case 'ha':
      case 'haw':
      case 'hu':
      case 'jgo':
      case 'jmc':
      case 'ka':
      case 'kk':
      case 'kkj':
      case 'kl':
      case 'ks':
      case 'ksb':
      case 'ky':
      case 'lb':
      case 'lg':
      case 'mas':
      case 'mgo':
      case 'ml':
      case 'mn':
      case 'nb':
      case 'nd':
      case 'ne':
      case 'nn':
      case 'nnh':
      case 'nyn':
      case 'om':
      case 'or':
      case 'os':
      case 'ps':
      case 'rm':
      case 'rof':
      case 'rwk':
      case 'saq':
      case 'seh':
      case 'sn':
      case 'so':
      case 'sq':
      case 'ta':
      case 'te':
      case 'teo':
      case 'tk':
      case 'tr':
      case 'ug':
      case 'uz':
      case 'vo':
      case 'vun':
      case 'wae':
      case 'xog':
        if (n === 1)
          return Plural.One;
        return Plural.Other;
      case 'ak':
      case 'ln':
      case 'mg':
      case 'pa':
      case 'ti':
        if (n === Math.floor(n) && n >= 0 && n <= 1)
          return Plural.One;
        return Plural.Other;
      case 'am':
      case 'as':
      case 'bn':
      case 'fa':
      case 'gu':
      case 'hi':
      case 'kn':
      case 'mr':
      case 'zu':
        if (i === 0 || n === 1)
          return Plural.One;
        return Plural.Other;
      case 'ar':
        if (n === 0)
          return Plural.Zero;
        if (n === 1)
          return Plural.One;
        if (n === 2)
          return Plural.Two;
        if (n % 100 === Math.floor(n % 100) && n % 100 >= 3 && n % 100 <= 10)
          return Plural.Few;
        if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 99)
          return Plural.Many;
        return Plural.Other;
      case 'ast':
      case 'ca':
      case 'de':
      case 'en':
      case 'et':
      case 'fi':
      case 'fy':
      case 'gl':
      case 'it':
      case 'nl':
      case 'sv':
      case 'sw':
      case 'ur':
      case 'yi':
        if (i === 1 && v === 0)
          return Plural.One;
        return Plural.Other;
      case 'be':
        if (n % 10 === 1 && !(n % 100 === 11))
          return Plural.One;
        if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 4 && !(n % 100 >= 12 && n % 100 <= 14))
          return Plural.Few;
        if (n % 10 === 0 || n % 10 === Math.floor(n % 10) && n % 10 >= 5 && n % 10 <= 9 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 14)
          return Plural.Many;
        return Plural.Other;
      case 'br':
        if (n % 10 === 1 && !(n % 100 === 11 || n % 100 === 71 || n % 100 === 91))
          return Plural.One;
        if (n % 10 === 2 && !(n % 100 === 12 || n % 100 === 72 || n % 100 === 92))
          return Plural.Two;
        if (n % 10 === Math.floor(n % 10) && (n % 10 >= 3 && n % 10 <= 4 || n % 10 === 9) && !(n % 100 >= 10 && n % 100 <= 19 || n % 100 >= 70 && n % 100 <= 79 || n % 100 >= 90 && n % 100 <= 99))
          return Plural.Few;
        if (!(n === 0) && n % 1e6 === 0)
          return Plural.Many;
        return Plural.Other;
      case 'bs':
      case 'hr':
      case 'sr':
        if (v === 0 && i % 10 === 1 && !(i % 100 === 11) || f % 10 === 1 && !(f % 100 === 11))
          return Plural.One;
        if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 && !(i % 100 >= 12 && i % 100 <= 14) || f % 10 === Math.floor(f % 10) && f % 10 >= 2 && f % 10 <= 4 && !(f % 100 >= 12 && f % 100 <= 14))
          return Plural.Few;
        return Plural.Other;
      case 'cs':
      case 'sk':
        if (i === 1 && v === 0)
          return Plural.One;
        if (i === Math.floor(i) && i >= 2 && i <= 4 && v === 0)
          return Plural.Few;
        if (!(v === 0))
          return Plural.Many;
        return Plural.Other;
      case 'cy':
        if (n === 0)
          return Plural.Zero;
        if (n === 1)
          return Plural.One;
        if (n === 2)
          return Plural.Two;
        if (n === 3)
          return Plural.Few;
        if (n === 6)
          return Plural.Many;
        return Plural.Other;
      case 'da':
        if (n === 1 || !(t === 0) && (i === 0 || i === 1))
          return Plural.One;
        return Plural.Other;
      case 'dsb':
      case 'hsb':
        if (v === 0 && i % 100 === 1 || f % 100 === 1)
          return Plural.One;
        if (v === 0 && i % 100 === 2 || f % 100 === 2)
          return Plural.Two;
        if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || f % 100 === Math.floor(f % 100) && f % 100 >= 3 && f % 100 <= 4)
          return Plural.Few;
        return Plural.Other;
      case 'ff':
      case 'fr':
      case 'hy':
      case 'kab':
        if (i === 0 || i === 1)
          return Plural.One;
        return Plural.Other;
      case 'fil':
        if (v === 0 && (i === 1 || i === 2 || i === 3) || v === 0 && !(i % 10 === 4 || i % 10 === 6 || i % 10 === 9) || !(v === 0) && !(f % 10 === 4 || f % 10 === 6 || f % 10 === 9))
          return Plural.One;
        return Plural.Other;
      case 'ga':
        if (n === 1)
          return Plural.One;
        if (n === 2)
          return Plural.Two;
        if (n === Math.floor(n) && n >= 3 && n <= 6)
          return Plural.Few;
        if (n === Math.floor(n) && n >= 7 && n <= 10)
          return Plural.Many;
        return Plural.Other;
      case 'gd':
        if (n === 1 || n === 11)
          return Plural.One;
        if (n === 2 || n === 12)
          return Plural.Two;
        if (n === Math.floor(n) && (n >= 3 && n <= 10 || n >= 13 && n <= 19))
          return Plural.Few;
        return Plural.Other;
      case 'gv':
        if (v === 0 && i % 10 === 1)
          return Plural.One;
        if (v === 0 && i % 10 === 2)
          return Plural.Two;
        if (v === 0 && (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80))
          return Plural.Few;
        if (!(v === 0))
          return Plural.Many;
        return Plural.Other;
      case 'he':
        if (i === 1 && v === 0)
          return Plural.One;
        if (i === 2 && v === 0)
          return Plural.Two;
        if (v === 0 && !(n >= 0 && n <= 10) && n % 10 === 0)
          return Plural.Many;
        return Plural.Other;
      case 'is':
        if (t === 0 && i % 10 === 1 && !(i % 100 === 11) || !(t === 0))
          return Plural.One;
        return Plural.Other;
      case 'ksh':
        if (n === 0)
          return Plural.Zero;
        if (n === 1)
          return Plural.One;
        return Plural.Other;
      case 'kw':
      case 'naq':
      case 'se':
      case 'smn':
        if (n === 1)
          return Plural.One;
        if (n === 2)
          return Plural.Two;
        return Plural.Other;
      case 'lag':
        if (n === 0)
          return Plural.Zero;
        if ((i === 0 || i === 1) && !(n === 0))
          return Plural.One;
        return Plural.Other;
      case 'lt':
        if (n % 10 === 1 && !(n % 100 >= 11 && n % 100 <= 19))
          return Plural.One;
        if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 9 && !(n % 100 >= 11 && n % 100 <= 19))
          return Plural.Few;
        if (!(f === 0))
          return Plural.Many;
        return Plural.Other;
      case 'lv':
      case 'prg':
        if (n % 10 === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19 || v === 2 && f % 100 === Math.floor(f % 100) && f % 100 >= 11 && f % 100 <= 19)
          return Plural.Zero;
        if (n % 10 === 1 && !(n % 100 === 11) || v === 2 && f % 10 === 1 && !(f % 100 === 11) || !(v === 2) && f % 10 === 1)
          return Plural.One;
        return Plural.Other;
      case 'mk':
        if (v === 0 && i % 10 === 1 || f % 10 === 1)
          return Plural.One;
        return Plural.Other;
      case 'mt':
        if (n === 1)
          return Plural.One;
        if (n === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 2 && n % 100 <= 10)
          return Plural.Few;
        if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19)
          return Plural.Many;
        return Plural.Other;
      case 'pl':
        if (i === 1 && v === 0)
          return Plural.One;
        if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 && !(i % 100 >= 12 && i % 100 <= 14))
          return Plural.Few;
        if (v === 0 && !(i === 1) && i % 10 === Math.floor(i % 10) && i % 10 >= 0 && i % 10 <= 1 || v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 || v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 12 && i % 100 <= 14)
          return Plural.Many;
        return Plural.Other;
      case 'pt':
        if (n === Math.floor(n) && n >= 0 && n <= 2 && !(n === 2))
          return Plural.One;
        return Plural.Other;
      case 'ro':
        if (i === 1 && v === 0)
          return Plural.One;
        if (!(v === 0) || n === 0 || !(n === 1) && n % 100 === Math.floor(n % 100) && n % 100 >= 1 && n % 100 <= 19)
          return Plural.Few;
        return Plural.Other;
      case 'ru':
      case 'uk':
        if (v === 0 && i % 10 === 1 && !(i % 100 === 11))
          return Plural.One;
        if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 && !(i % 100 >= 12 && i % 100 <= 14))
          return Plural.Few;
        if (v === 0 && i % 10 === 0 || v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 || v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 11 && i % 100 <= 14)
          return Plural.Many;
        return Plural.Other;
      case 'shi':
        if (i === 0 || n === 1)
          return Plural.One;
        if (n === Math.floor(n) && n >= 2 && n <= 10)
          return Plural.Few;
        return Plural.Other;
      case 'si':
        if (n === 0 || n === 1 || i === 0 && f === 1)
          return Plural.One;
        return Plural.Other;
      case 'sl':
        if (v === 0 && i % 100 === 1)
          return Plural.One;
        if (v === 0 && i % 100 === 2)
          return Plural.Two;
        if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || !(v === 0))
          return Plural.Few;
        return Plural.Other;
      case 'tzm':
        if (n === Math.floor(n) && n >= 0 && n <= 1 || n === Math.floor(n) && n >= 11 && n <= 99)
          return Plural.One;
        return Plural.Other;
      default:
        return Plural.Other;
    }
  }
  function parseCookieValue(cookieStr, name) {
    name = encodeURIComponent(name);
    for (var _i = 0,
        _a = cookieStr.split(';'); _i < _a.length; _i++) {
      var cookie = _a[_i];
      var eqIndex = cookie.indexOf('=');
      var _b = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)],
          cookieName = _b[0],
          cookieValue = _b[1];
      if (cookieName.trim() === name) {
        return decodeURIComponent(cookieValue);
      }
    }
    return null;
  }
  var NgClass = (function() {
    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
      this._iterableDiffers = _iterableDiffers;
      this._keyValueDiffers = _keyValueDiffers;
      this._ngEl = _ngEl;
      this._renderer = _renderer;
      this._initialClasses = [];
    }
    Object.defineProperty(NgClass.prototype, "klass", {
      set: function(v) {
        this._applyInitialClasses(true);
        this._initialClasses = typeof v === 'string' ? v.split(/\s+/) : [];
        this._applyInitialClasses(false);
        this._applyClasses(this._rawClass, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgClass.prototype, "ngClass", {
      set: function(v) {
        this._cleanupClasses(this._rawClass);
        this._iterableDiffer = null;
        this._keyValueDiffer = null;
        this._rawClass = typeof v === 'string' ? v.split(/\s+/) : v;
        if (this._rawClass) {
          if (_angular_core.ɵisListLikeIterable(this._rawClass)) {
            this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create();
          } else {
            this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create();
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    NgClass.prototype.ngDoCheck = function() {
      if (this._iterableDiffer) {
        var iterableChanges = this._iterableDiffer.diff((this._rawClass));
        if (iterableChanges) {
          this._applyIterableChanges(iterableChanges);
        }
      } else if (this._keyValueDiffer) {
        var keyValueChanges = this._keyValueDiffer.diff((this._rawClass));
        if (keyValueChanges) {
          this._applyKeyValueChanges(keyValueChanges);
        }
      }
    };
    NgClass.prototype._cleanupClasses = function(rawClassVal) {
      this._applyClasses(rawClassVal, true);
      this._applyInitialClasses(false);
    };
    NgClass.prototype._applyKeyValueChanges = function(changes) {
      var _this = this;
      changes.forEachAddedItem(function(record) {
        return _this._toggleClass(record.key, record.currentValue);
      });
      changes.forEachChangedItem(function(record) {
        return _this._toggleClass(record.key, record.currentValue);
      });
      changes.forEachRemovedItem(function(record) {
        if (record.previousValue) {
          _this._toggleClass(record.key, false);
        }
      });
    };
    NgClass.prototype._applyIterableChanges = function(changes) {
      var _this = this;
      changes.forEachAddedItem(function(record) {
        if (typeof record.item === 'string') {
          _this._toggleClass(record.item, true);
        } else {
          throw new Error("NgClass can only toggle CSS classes expressed as strings, got " + _angular_core.ɵstringify(record.item));
        }
      });
      changes.forEachRemovedItem(function(record) {
        return _this._toggleClass(record.item, false);
      });
    };
    NgClass.prototype._applyInitialClasses = function(isCleanup) {
      var _this = this;
      this._initialClasses.forEach(function(klass) {
        return _this._toggleClass(klass, !isCleanup);
      });
    };
    NgClass.prototype._applyClasses = function(rawClassVal, isCleanup) {
      var _this = this;
      if (rawClassVal) {
        if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
          ((rawClassVal)).forEach(function(klass) {
            return _this._toggleClass(klass, !isCleanup);
          });
        } else {
          Object.keys(rawClassVal).forEach(function(klass) {
            if (rawClassVal[klass] != null)
              _this._toggleClass(klass, !isCleanup);
          });
        }
      }
    };
    NgClass.prototype._toggleClass = function(klass, enabled) {
      var _this = this;
      klass = klass.trim();
      if (klass) {
        klass.split(/\s+/g).forEach(function(klass) {
          _this._renderer.setElementClass(_this._ngEl.nativeElement, klass, !!enabled);
        });
      }
    };
    return NgClass;
  }());
  NgClass.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngClass]'}]
  }];
  NgClass.ctorParameters = function() {
    return [{type: _angular_core.IterableDiffers}, {type: _angular_core.KeyValueDiffers}, {type: _angular_core.ElementRef}, {type: _angular_core.Renderer}];
  };
  NgClass.propDecorators = {
    'klass': [{
      type: _angular_core.Input,
      args: ['class']
    }],
    'ngClass': [{type: _angular_core.Input}]
  };
  var NgComponentOutlet = (function() {
    function NgComponentOutlet(_viewContainerRef) {
      this._viewContainerRef = _viewContainerRef;
      this._componentRef = null;
      this._moduleRef = null;
    }
    NgComponentOutlet.prototype.ngOnChanges = function(changes) {
      this._viewContainerRef.clear();
      this._componentRef = null;
      if (this.ngComponentOutlet) {
        var elInjector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
        if (changes['ngComponentOutletNgModuleFactory']) {
          if (this._moduleRef)
            this._moduleRef.destroy();
          if (this.ngComponentOutletNgModuleFactory) {
            var parentModule = elInjector.get(_angular_core.NgModuleRef);
            this._moduleRef = this.ngComponentOutletNgModuleFactory.create(parentModule.injector);
          } else {
            this._moduleRef = null;
          }
        }
        var componentFactoryResolver = this._moduleRef ? this._moduleRef.componentFactoryResolver : elInjector.get(_angular_core.ComponentFactoryResolver);
        var componentFactory = componentFactoryResolver.resolveComponentFactory(this.ngComponentOutlet);
        this._componentRef = this._viewContainerRef.createComponent(componentFactory, this._viewContainerRef.length, elInjector, this.ngComponentOutletContent);
      }
    };
    NgComponentOutlet.prototype.ngOnDestroy = function() {
      if (this._moduleRef)
        this._moduleRef.destroy();
    };
    return NgComponentOutlet;
  }());
  NgComponentOutlet.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngComponentOutlet]'}]
  }];
  NgComponentOutlet.ctorParameters = function() {
    return [{type: _angular_core.ViewContainerRef}];
  };
  NgComponentOutlet.propDecorators = {
    'ngComponentOutlet': [{type: _angular_core.Input}],
    'ngComponentOutletInjector': [{type: _angular_core.Input}],
    'ngComponentOutletContent': [{type: _angular_core.Input}],
    'ngComponentOutletNgModuleFactory': [{type: _angular_core.Input}]
  };
  var NgForOfContext = (function() {
    function NgForOfContext($implicit, ngForOf, index, count) {
      this.$implicit = $implicit;
      this.ngForOf = ngForOf;
      this.index = index;
      this.count = count;
    }
    Object.defineProperty(NgForOfContext.prototype, "first", {
      get: function() {
        return this.index === 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForOfContext.prototype, "last", {
      get: function() {
        return this.index === this.count - 1;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForOfContext.prototype, "even", {
      get: function() {
        return this.index % 2 === 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForOfContext.prototype, "odd", {
      get: function() {
        return !this.even;
      },
      enumerable: true,
      configurable: true
    });
    return NgForOfContext;
  }());
  var NgForOf = (function() {
    function NgForOf(_viewContainer, _template, _differs) {
      this._viewContainer = _viewContainer;
      this._template = _template;
      this._differs = _differs;
      this._differ = null;
    }
    Object.defineProperty(NgForOf.prototype, "ngForTrackBy", {
      get: function() {
        return this._trackByFn;
      },
      set: function(fn) {
        if (_angular_core.isDevMode() && fn != null && typeof fn !== 'function') {
          if ((console) && (console.warn)) {
            console.warn("trackBy must be a function, but received " + JSON.stringify(fn) + ". " + "See https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html#!#change-propagation for more information.");
          }
        }
        this._trackByFn = fn;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForOf.prototype, "ngForTemplate", {
      set: function(value) {
        if (value) {
          this._template = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    NgForOf.prototype.ngOnChanges = function(changes) {
      if ('ngForOf' in changes) {
        var value = changes['ngForOf'].currentValue;
        if (!this._differ && value) {
          try {
            this._differ = this._differs.find(value).create(this.ngForTrackBy);
          } catch (e) {
            throw new Error("Cannot find a differ supporting object '" + value + "' of type '" + getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
          }
        }
      }
    };
    NgForOf.prototype.ngDoCheck = function() {
      if (this._differ) {
        var changes = this._differ.diff(this.ngForOf);
        if (changes)
          this._applyChanges(changes);
      }
    };
    NgForOf.prototype._applyChanges = function(changes) {
      var _this = this;
      var insertTuples = [];
      changes.forEachOperation(function(item, adjustedPreviousIndex, currentIndex) {
        if (item.previousIndex == null) {
          var view = _this._viewContainer.createEmbeddedView(_this._template, new NgForOfContext(((null)), _this.ngForOf, -1, -1), currentIndex);
          var tuple = new RecordViewTuple(item, view);
          insertTuples.push(tuple);
        } else if (currentIndex == null) {
          _this._viewContainer.remove(adjustedPreviousIndex);
        } else {
          var view = ((_this._viewContainer.get(adjustedPreviousIndex)));
          _this._viewContainer.move(view, currentIndex);
          var tuple = new RecordViewTuple(item, (view));
          insertTuples.push(tuple);
        }
      });
      for (var i = 0; i < insertTuples.length; i++) {
        this._perViewChange(insertTuples[i].view, insertTuples[i].record);
      }
      for (var i = 0,
          ilen = this._viewContainer.length; i < ilen; i++) {
        var viewRef = (this._viewContainer.get(i));
        viewRef.context.index = i;
        viewRef.context.count = ilen;
      }
      changes.forEachIdentityChange(function(record) {
        var viewRef = (_this._viewContainer.get(record.currentIndex));
        viewRef.context.$implicit = record.item;
      });
    };
    NgForOf.prototype._perViewChange = function(view, record) {
      view.context.$implicit = record.item;
    };
    return NgForOf;
  }());
  NgForOf.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngFor][ngForOf]'}]
  }];
  NgForOf.ctorParameters = function() {
    return [{type: _angular_core.ViewContainerRef}, {type: _angular_core.TemplateRef}, {type: _angular_core.IterableDiffers}];
  };
  NgForOf.propDecorators = {
    'ngForOf': [{type: _angular_core.Input}],
    'ngForTrackBy': [{type: _angular_core.Input}],
    'ngForTemplate': [{type: _angular_core.Input}]
  };
  var RecordViewTuple = (function() {
    function RecordViewTuple(record, view) {
      this.record = record;
      this.view = view;
    }
    return RecordViewTuple;
  }());
  var NgFor = NgForOf;
  function getTypeNameForDebugging(type) {
    return type['name'] || typeof type;
  }
  var NgIf = (function() {
    function NgIf(_viewContainer, templateRef) {
      this._viewContainer = _viewContainer;
      this._context = new NgIfContext();
      this._thenTemplateRef = null;
      this._elseTemplateRef = null;
      this._thenViewRef = null;
      this._elseViewRef = null;
      this._thenTemplateRef = templateRef;
    }
    Object.defineProperty(NgIf.prototype, "ngIf", {
      set: function(condition) {
        this._context.$implicit = this._context.ngIf = condition;
        this._updateView();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgIf.prototype, "ngIfThen", {
      set: function(templateRef) {
        this._thenTemplateRef = templateRef;
        this._thenViewRef = null;
        this._updateView();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgIf.prototype, "ngIfElse", {
      set: function(templateRef) {
        this._elseTemplateRef = templateRef;
        this._elseViewRef = null;
        this._updateView();
      },
      enumerable: true,
      configurable: true
    });
    NgIf.prototype._updateView = function() {
      if (this._context.$implicit) {
        if (!this._thenViewRef) {
          this._viewContainer.clear();
          this._elseViewRef = null;
          if (this._thenTemplateRef) {
            this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
          }
        }
      } else {
        if (!this._elseViewRef) {
          this._viewContainer.clear();
          this._thenViewRef = null;
          if (this._elseTemplateRef) {
            this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
          }
        }
      }
    };
    return NgIf;
  }());
  NgIf.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngIf]'}]
  }];
  NgIf.ctorParameters = function() {
    return [{type: _angular_core.ViewContainerRef}, {type: _angular_core.TemplateRef}];
  };
  NgIf.propDecorators = {
    'ngIf': [{type: _angular_core.Input}],
    'ngIfThen': [{type: _angular_core.Input}],
    'ngIfElse': [{type: _angular_core.Input}]
  };
  var NgIfContext = (function() {
    function NgIfContext() {
      this.$implicit = null;
      this.ngIf = null;
    }
    return NgIfContext;
  }());
  var SwitchView = (function() {
    function SwitchView(_viewContainerRef, _templateRef) {
      this._viewContainerRef = _viewContainerRef;
      this._templateRef = _templateRef;
      this._created = false;
    }
    SwitchView.prototype.create = function() {
      this._created = true;
      this._viewContainerRef.createEmbeddedView(this._templateRef);
    };
    SwitchView.prototype.destroy = function() {
      this._created = false;
      this._viewContainerRef.clear();
    };
    SwitchView.prototype.enforceState = function(created) {
      if (created && !this._created) {
        this.create();
      } else if (!created && this._created) {
        this.destroy();
      }
    };
    return SwitchView;
  }());
  var NgSwitch = (function() {
    function NgSwitch() {
      this._defaultUsed = false;
      this._caseCount = 0;
      this._lastCaseCheckIndex = 0;
      this._lastCasesMatched = false;
    }
    Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
      set: function(newValue) {
        this._ngSwitch = newValue;
        if (this._caseCount === 0) {
          this._updateDefaultCases(true);
        }
      },
      enumerable: true,
      configurable: true
    });
    NgSwitch.prototype._addCase = function() {
      return this._caseCount++;
    };
    NgSwitch.prototype._addDefault = function(view) {
      if (!this._defaultViews) {
        this._defaultViews = [];
      }
      this._defaultViews.push(view);
    };
    NgSwitch.prototype._matchCase = function(value) {
      var matched = value == this._ngSwitch;
      this._lastCasesMatched = this._lastCasesMatched || matched;
      this._lastCaseCheckIndex++;
      if (this._lastCaseCheckIndex === this._caseCount) {
        this._updateDefaultCases(!this._lastCasesMatched);
        this._lastCaseCheckIndex = 0;
        this._lastCasesMatched = false;
      }
      return matched;
    };
    NgSwitch.prototype._updateDefaultCases = function(useDefault) {
      if (this._defaultViews && useDefault !== this._defaultUsed) {
        this._defaultUsed = useDefault;
        for (var i = 0; i < this._defaultViews.length; i++) {
          var defaultView = this._defaultViews[i];
          defaultView.enforceState(useDefault);
        }
      }
    };
    return NgSwitch;
  }());
  NgSwitch.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngSwitch]'}]
  }];
  NgSwitch.ctorParameters = function() {
    return [];
  };
  NgSwitch.propDecorators = {'ngSwitch': [{type: _angular_core.Input}]};
  var NgSwitchCase = (function() {
    function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
      this.ngSwitch = ngSwitch;
      ngSwitch._addCase();
      this._view = new SwitchView(viewContainer, templateRef);
    }
    NgSwitchCase.prototype.ngDoCheck = function() {
      this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
    };
    return NgSwitchCase;
  }());
  NgSwitchCase.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngSwitchCase]'}]
  }];
  NgSwitchCase.ctorParameters = function() {
    return [{type: _angular_core.ViewContainerRef}, {type: _angular_core.TemplateRef}, {
      type: NgSwitch,
      decorators: [{type: _angular_core.Host}]
    }];
  };
  NgSwitchCase.propDecorators = {'ngSwitchCase': [{type: _angular_core.Input}]};
  var NgSwitchDefault = (function() {
    function NgSwitchDefault(viewContainer, templateRef, ngSwitch) {
      ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
    }
    return NgSwitchDefault;
  }());
  NgSwitchDefault.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngSwitchDefault]'}]
  }];
  NgSwitchDefault.ctorParameters = function() {
    return [{type: _angular_core.ViewContainerRef}, {type: _angular_core.TemplateRef}, {
      type: NgSwitch,
      decorators: [{type: _angular_core.Host}]
    }];
  };
  var NgPlural = (function() {
    function NgPlural(_localization) {
      this._localization = _localization;
      this._caseViews = {};
    }
    Object.defineProperty(NgPlural.prototype, "ngPlural", {
      set: function(value) {
        this._switchValue = value;
        this._updateView();
      },
      enumerable: true,
      configurable: true
    });
    NgPlural.prototype.addCase = function(value, switchView) {
      this._caseViews[value] = switchView;
    };
    NgPlural.prototype._updateView = function() {
      this._clearViews();
      var cases = Object.keys(this._caseViews);
      var key = getPluralCategory(this._switchValue, cases, this._localization);
      this._activateView(this._caseViews[key]);
    };
    NgPlural.prototype._clearViews = function() {
      if (this._activeView)
        this._activeView.destroy();
    };
    NgPlural.prototype._activateView = function(view) {
      if (view) {
        this._activeView = view;
        this._activeView.create();
      }
    };
    return NgPlural;
  }());
  NgPlural.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngPlural]'}]
  }];
  NgPlural.ctorParameters = function() {
    return [{type: NgLocalization}];
  };
  NgPlural.propDecorators = {'ngPlural': [{type: _angular_core.Input}]};
  var NgPluralCase = (function() {
    function NgPluralCase(value, template, viewContainer, ngPlural) {
      this.value = value;
      var isANumber = !isNaN(Number(value));
      ngPlural.addCase(isANumber ? "=" + value : value, new SwitchView(viewContainer, template));
    }
    return NgPluralCase;
  }());
  NgPluralCase.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngPluralCase]'}]
  }];
  NgPluralCase.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Attribute,
        args: ['ngPluralCase']
      }]
    }, {type: _angular_core.TemplateRef}, {type: _angular_core.ViewContainerRef}, {
      type: NgPlural,
      decorators: [{type: _angular_core.Host}]
    }];
  };
  var NgStyle = (function() {
    function NgStyle(_differs, _ngEl, _renderer) {
      this._differs = _differs;
      this._ngEl = _ngEl;
      this._renderer = _renderer;
    }
    Object.defineProperty(NgStyle.prototype, "ngStyle", {
      set: function(v) {
        this._ngStyle = v;
        if (!this._differ && v) {
          this._differ = this._differs.find(v).create();
        }
      },
      enumerable: true,
      configurable: true
    });
    NgStyle.prototype.ngDoCheck = function() {
      if (this._differ) {
        var changes = this._differ.diff(this._ngStyle);
        if (changes) {
          this._applyChanges(changes);
        }
      }
    };
    NgStyle.prototype._applyChanges = function(changes) {
      var _this = this;
      changes.forEachRemovedItem(function(record) {
        return _this._setStyle(record.key, null);
      });
      changes.forEachAddedItem(function(record) {
        return _this._setStyle(record.key, record.currentValue);
      });
      changes.forEachChangedItem(function(record) {
        return _this._setStyle(record.key, record.currentValue);
      });
    };
    NgStyle.prototype._setStyle = function(nameAndUnit, value) {
      var _a = nameAndUnit.split('.'),
          name = _a[0],
          unit = _a[1];
      value = value != null && unit ? "" + value + unit : value;
      this._renderer.setElementStyle(this._ngEl.nativeElement, name, (value));
    };
    return NgStyle;
  }());
  NgStyle.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngStyle]'}]
  }];
  NgStyle.ctorParameters = function() {
    return [{type: _angular_core.KeyValueDiffers}, {type: _angular_core.ElementRef}, {type: _angular_core.Renderer}];
  };
  NgStyle.propDecorators = {'ngStyle': [{type: _angular_core.Input}]};
  var NgTemplateOutlet = (function() {
    function NgTemplateOutlet(_viewContainerRef) {
      this._viewContainerRef = _viewContainerRef;
    }
    Object.defineProperty(NgTemplateOutlet.prototype, "ngOutletContext", {
      set: function(context) {
        this.ngTemplateOutletContext = context;
      },
      enumerable: true,
      configurable: true
    });
    NgTemplateOutlet.prototype.ngOnChanges = function(changes) {
      if (this._viewRef) {
        this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
      }
      if (this.ngTemplateOutlet) {
        this._viewRef = this._viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext);
      }
    };
    return NgTemplateOutlet;
  }());
  NgTemplateOutlet.decorators = [{
    type: _angular_core.Directive,
    args: [{selector: '[ngTemplateOutlet]'}]
  }];
  NgTemplateOutlet.ctorParameters = function() {
    return [{type: _angular_core.ViewContainerRef}];
  };
  NgTemplateOutlet.propDecorators = {
    'ngTemplateOutletContext': [{type: _angular_core.Input}],
    'ngTemplateOutlet': [{type: _angular_core.Input}],
    'ngOutletContext': [{type: _angular_core.Input}]
  };
  var COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];
  function invalidPipeArgumentError(type, value) {
    return Error("InvalidPipeArgument: '" + value + "' for pipe '" + _angular_core.ɵstringify(type) + "'");
  }
  var ObservableStrategy = (function() {
    function ObservableStrategy() {}
    ObservableStrategy.prototype.createSubscription = function(async, updateLatestValue) {
      return async.subscribe({
        next: updateLatestValue,
        error: function(e) {
          throw e;
        }
      });
    };
    ObservableStrategy.prototype.dispose = function(subscription) {
      subscription.unsubscribe();
    };
    ObservableStrategy.prototype.onDestroy = function(subscription) {
      subscription.unsubscribe();
    };
    return ObservableStrategy;
  }());
  var PromiseStrategy = (function() {
    function PromiseStrategy() {}
    PromiseStrategy.prototype.createSubscription = function(async, updateLatestValue) {
      return async.then(updateLatestValue, function(e) {
        throw e;
      });
    };
    PromiseStrategy.prototype.dispose = function(subscription) {};
    PromiseStrategy.prototype.onDestroy = function(subscription) {};
    return PromiseStrategy;
  }());
  var _promiseStrategy = new PromiseStrategy();
  var _observableStrategy = new ObservableStrategy();
  var AsyncPipe = (function() {
    function AsyncPipe(_ref) {
      this._ref = _ref;
      this._latestValue = null;
      this._latestReturnedValue = null;
      this._subscription = null;
      this._obj = null;
      this._strategy = ((null));
    }
    AsyncPipe.prototype.ngOnDestroy = function() {
      if (this._subscription) {
        this._dispose();
      }
    };
    AsyncPipe.prototype.transform = function(obj) {
      if (!this._obj) {
        if (obj) {
          this._subscribe(obj);
        }
        this._latestReturnedValue = this._latestValue;
        return this._latestValue;
      }
      if (obj !== this._obj) {
        this._dispose();
        return this.transform((obj));
      }
      if (this._latestValue === this._latestReturnedValue) {
        return this._latestReturnedValue;
      }
      this._latestReturnedValue = this._latestValue;
      return _angular_core.WrappedValue.wrap(this._latestValue);
    };
    AsyncPipe.prototype._subscribe = function(obj) {
      var _this = this;
      this._obj = obj;
      this._strategy = this._selectStrategy(obj);
      this._subscription = this._strategy.createSubscription(obj, function(value) {
        return _this._updateLatestValue(obj, value);
      });
    };
    AsyncPipe.prototype._selectStrategy = function(obj) {
      if (_angular_core.ɵisPromise(obj)) {
        return _promiseStrategy;
      }
      if (_angular_core.ɵisObservable(obj)) {
        return _observableStrategy;
      }
      throw invalidPipeArgumentError(AsyncPipe, obj);
    };
    AsyncPipe.prototype._dispose = function() {
      this._strategy.dispose(((this._subscription)));
      this._latestValue = null;
      this._latestReturnedValue = null;
      this._subscription = null;
      this._obj = null;
    };
    AsyncPipe.prototype._updateLatestValue = function(async, value) {
      if (async === this._obj) {
        this._latestValue = value;
        this._ref.markForCheck();
      }
    };
    return AsyncPipe;
  }());
  AsyncPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'async',
      pure: false
    }]
  }];
  AsyncPipe.ctorParameters = function() {
    return [{type: _angular_core.ChangeDetectorRef}];
  };
  var LowerCasePipe = (function() {
    function LowerCasePipe() {}
    LowerCasePipe.prototype.transform = function(value) {
      if (!value)
        return value;
      if (typeof value !== 'string') {
        throw invalidPipeArgumentError(LowerCasePipe, value);
      }
      return value.toLowerCase();
    };
    return LowerCasePipe;
  }());
  LowerCasePipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'lowercase'}]
  }];
  LowerCasePipe.ctorParameters = function() {
    return [];
  };
  function titleCaseWord(word) {
    if (!word)
      return word;
    return word[0].toUpperCase() + word.substr(1).toLowerCase();
  }
  var TitleCasePipe = (function() {
    function TitleCasePipe() {}
    TitleCasePipe.prototype.transform = function(value) {
      if (!value)
        return value;
      if (typeof value !== 'string') {
        throw invalidPipeArgumentError(TitleCasePipe, value);
      }
      return value.split(/\b/g).map(function(word) {
        return titleCaseWord(word);
      }).join('');
    };
    return TitleCasePipe;
  }());
  TitleCasePipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'titlecase'}]
  }];
  TitleCasePipe.ctorParameters = function() {
    return [];
  };
  var UpperCasePipe = (function() {
    function UpperCasePipe() {}
    UpperCasePipe.prototype.transform = function(value) {
      if (!value)
        return value;
      if (typeof value !== 'string') {
        throw invalidPipeArgumentError(UpperCasePipe, value);
      }
      return value.toUpperCase();
    };
    return UpperCasePipe;
  }());
  UpperCasePipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'uppercase'}]
  }];
  UpperCasePipe.ctorParameters = function() {
    return [];
  };
  var NumberFormatStyle = {};
  NumberFormatStyle.Decimal = 0;
  NumberFormatStyle.Percent = 1;
  NumberFormatStyle.Currency = 2;
  NumberFormatStyle[NumberFormatStyle.Decimal] = "Decimal";
  NumberFormatStyle[NumberFormatStyle.Percent] = "Percent";
  NumberFormatStyle[NumberFormatStyle.Currency] = "Currency";
  var NumberFormatter = (function() {
    function NumberFormatter() {}
    NumberFormatter.format = function(num, locale, style, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var minimumIntegerDigits = opts.minimumIntegerDigits,
          minimumFractionDigits = opts.minimumFractionDigits,
          maximumFractionDigits = opts.maximumFractionDigits,
          currency = opts.currency,
          _a = opts.currencyAsSymbol,
          currencyAsSymbol = _a === void 0 ? false : _a;
      var options = {
        minimumIntegerDigits: minimumIntegerDigits,
        minimumFractionDigits: minimumFractionDigits,
        maximumFractionDigits: maximumFractionDigits,
        style: NumberFormatStyle[style].toLowerCase()
      };
      if (style == NumberFormatStyle.Currency) {
        options.currency = typeof currency == 'string' ? currency : undefined;
        options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
      }
      return new Intl.NumberFormat(locale, options).format(num);
    };
    return NumberFormatter;
  }());
  var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;
  var PATTERN_ALIASES = {
    'yMMMdjms': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1), digitCondition('hour', 1), digitCondition('minute', 1), digitCondition('second', 1)])),
    'yMdjm': datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1), digitCondition('hour', 1), digitCondition('minute', 1)])),
    'yMMMMEEEEd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4), digitCondition('day', 1)])),
    'yMMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
    'yMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
    'yMd': datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
    'jms': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
    'jm': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
  };
  var DATE_FORMATS = {
    'yyyy': datePartGetterFactory(digitCondition('year', 4)),
    'yy': datePartGetterFactory(digitCondition('year', 2)),
    'y': datePartGetterFactory(digitCondition('year', 1)),
    'MMMM': datePartGetterFactory(nameCondition('month', 4)),
    'MMM': datePartGetterFactory(nameCondition('month', 3)),
    'MM': datePartGetterFactory(digitCondition('month', 2)),
    'M': datePartGetterFactory(digitCondition('month', 1)),
    'LLLL': datePartGetterFactory(nameCondition('month', 4)),
    'L': datePartGetterFactory(nameCondition('month', 1)),
    'dd': datePartGetterFactory(digitCondition('day', 2)),
    'd': datePartGetterFactory(digitCondition('day', 1)),
    'HH': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),
    'H': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
    'hh': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),
    'h': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
    'jj': datePartGetterFactory(digitCondition('hour', 2)),
    'j': datePartGetterFactory(digitCondition('hour', 1)),
    'mm': digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
    'm': datePartGetterFactory(digitCondition('minute', 1)),
    'ss': digitModifier(datePartGetterFactory(digitCondition('second', 2))),
    's': datePartGetterFactory(digitCondition('second', 1)),
    'sss': datePartGetterFactory(digitCondition('second', 3)),
    'EEEE': datePartGetterFactory(nameCondition('weekday', 4)),
    'EEE': datePartGetterFactory(nameCondition('weekday', 3)),
    'EE': datePartGetterFactory(nameCondition('weekday', 2)),
    'E': datePartGetterFactory(nameCondition('weekday', 1)),
    'a': hourClockExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
    'Z': timeZoneGetter('short'),
    'z': timeZoneGetter('long'),
    'ww': datePartGetterFactory({}),
    'w': datePartGetterFactory({}),
    'G': datePartGetterFactory(nameCondition('era', 1)),
    'GG': datePartGetterFactory(nameCondition('era', 2)),
    'GGG': datePartGetterFactory(nameCondition('era', 3)),
    'GGGG': datePartGetterFactory(nameCondition('era', 4))
  };
  function digitModifier(inner) {
    return function(date, locale) {
      var result = inner(date, locale);
      return result.length == 1 ? '0' + result : result;
    };
  }
  function hourClockExtractor(inner) {
    return function(date, locale) {
      return inner(date, locale).split(' ')[1];
    };
  }
  function hourExtractor(inner) {
    return function(date, locale) {
      return inner(date, locale).split(' ')[0];
    };
  }
  function intlDateFormat(date, locale, options) {
    return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\u200e\u200f]/g, '');
  }
  function timeZoneGetter(timezone) {
    var options = {
      hour: '2-digit',
      hour12: false,
      timeZoneName: timezone
    };
    return function(date, locale) {
      var result = intlDateFormat(date, locale, options);
      return result ? result.substring(3) : '';
    };
  }
  function hour12Modify(options, value) {
    options.hour12 = value;
    return options;
  }
  function digitCondition(prop, len) {
    var result = {};
    result[prop] = len === 2 ? '2-digit' : 'numeric';
    return result;
  }
  function nameCondition(prop, len) {
    var result = {};
    if (len < 4) {
      result[prop] = len > 1 ? 'short' : 'narrow';
    } else {
      result[prop] = 'long';
    }
    return result;
  }
  function combine(options) {
    return options.reduce(function(merged, opt) {
      return (Object.assign({}, merged, opt));
    }, {});
  }
  function datePartGetterFactory(ret) {
    return function(date, locale) {
      return intlDateFormat(date, locale, ret);
    };
  }
  var DATE_FORMATTER_CACHE = new Map();
  function dateFormatter(format, date, locale) {
    var fn = PATTERN_ALIASES[format];
    if (fn)
      return fn(date, locale);
    var cacheKey = format;
    var parts = DATE_FORMATTER_CACHE.get(cacheKey);
    if (!parts) {
      parts = [];
      var match = void 0;
      DATE_FORMATS_SPLIT.exec(format);
      var _format = format;
      while (_format) {
        match = DATE_FORMATS_SPLIT.exec(_format);
        if (match) {
          parts = parts.concat(match.slice(1));
          _format = ((parts.pop()));
        } else {
          parts.push(_format);
          _format = null;
        }
      }
      DATE_FORMATTER_CACHE.set(cacheKey, parts);
    }
    return parts.reduce(function(text, part) {
      var fn = DATE_FORMATS[part];
      return text + (fn ? fn(date, locale) : partToTime(part));
    }, '');
  }
  function partToTime(part) {
    return part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
  }
  var DateFormatter = (function() {
    function DateFormatter() {}
    DateFormatter.format = function(date, locale, pattern) {
      return dateFormatter(pattern, date, locale);
    };
    return DateFormatter;
  }());
  var _NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
  function formatNumber(pipe, locale, value, style, digits, currency, currencyAsSymbol) {
    if (currency === void 0) {
      currency = null;
    }
    if (currencyAsSymbol === void 0) {
      currencyAsSymbol = false;
    }
    if (value == null)
      return null;
    value = typeof value === 'string' && isNumeric(value) ? +value : value;
    if (typeof value !== 'number') {
      throw invalidPipeArgumentError(pipe, value);
    }
    var minInt = undefined;
    var minFraction = undefined;
    var maxFraction = undefined;
    if (style !== NumberFormatStyle.Currency) {
      minInt = 1;
      minFraction = 0;
      maxFraction = 3;
    }
    if (digits) {
      var parts = digits.match(_NUMBER_FORMAT_REGEXP);
      if (parts === null) {
        throw new Error(digits + " is not a valid digit info for number pipes");
      }
      if (parts[1] != null) {
        minInt = parseIntAutoRadix(parts[1]);
      }
      if (parts[3] != null) {
        minFraction = parseIntAutoRadix(parts[3]);
      }
      if (parts[5] != null) {
        maxFraction = parseIntAutoRadix(parts[5]);
      }
    }
    return NumberFormatter.format((value), locale, style, {
      minimumIntegerDigits: minInt,
      minimumFractionDigits: minFraction,
      maximumFractionDigits: maxFraction,
      currency: currency,
      currencyAsSymbol: currencyAsSymbol
    });
  }
  var DecimalPipe = (function() {
    function DecimalPipe(_locale) {
      this._locale = _locale;
    }
    DecimalPipe.prototype.transform = function(value, digits) {
      return formatNumber(DecimalPipe, this._locale, value, NumberFormatStyle.Decimal, digits);
    };
    return DecimalPipe;
  }());
  DecimalPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'number'}]
  }];
  DecimalPipe.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [_angular_core.LOCALE_ID]
      }]
    }];
  };
  var PercentPipe = (function() {
    function PercentPipe(_locale) {
      this._locale = _locale;
    }
    PercentPipe.prototype.transform = function(value, digits) {
      return formatNumber(PercentPipe, this._locale, value, NumberFormatStyle.Percent, digits);
    };
    return PercentPipe;
  }());
  PercentPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'percent'}]
  }];
  PercentPipe.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [_angular_core.LOCALE_ID]
      }]
    }];
  };
  var CurrencyPipe = (function() {
    function CurrencyPipe(_locale) {
      this._locale = _locale;
    }
    CurrencyPipe.prototype.transform = function(value, currencyCode, symbolDisplay, digits) {
      if (currencyCode === void 0) {
        currencyCode = 'USD';
      }
      if (symbolDisplay === void 0) {
        symbolDisplay = false;
      }
      return formatNumber(CurrencyPipe, this._locale, value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
    };
    return CurrencyPipe;
  }());
  CurrencyPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{name: 'currency'}]
  }];
  CurrencyPipe.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [_angular_core.LOCALE_ID]
      }]
    }];
  };
  function parseIntAutoRadix(text) {
    var result = parseInt(text);
    if (isNaN(result)) {
      throw new Error('Invalid integer literal when parsing ' + text);
    }
    return result;
  }
  function isNumeric(value) {
    return !isNaN(value - parseFloat(value));
  }
  var ISO8601_DATE_REGEX = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
  var DatePipe = (function() {
    function DatePipe(_locale) {
      this._locale = _locale;
    }
    DatePipe.prototype.transform = function(value, pattern) {
      if (pattern === void 0) {
        pattern = 'mediumDate';
      }
      var date;
      if (isBlank(value) || value !== value)
        return null;
      if (typeof value === 'string') {
        value = value.trim();
      }
      if (isDate(value)) {
        date = value;
      } else if (isNumeric(value)) {
        date = new Date(parseFloat(value));
      } else if (typeof value === 'string' && /^(\d{4}-\d{1,2}-\d{1,2})$/.test(value)) {
        var _a = value.split('-').map(function(val) {
          return parseInt(val, 10);
        }),
            y = _a[0],
            m = _a[1],
            d = _a[2];
        date = new Date(y, m - 1, d);
      } else {
        date = new Date(value);
      }
      if (!isDate(date)) {
        var match = void 0;
        if ((typeof value === 'string') && (match = value.match(ISO8601_DATE_REGEX))) {
          date = isoStringToDate(match);
        } else {
          throw invalidPipeArgumentError(DatePipe, value);
        }
      }
      return DateFormatter.format(date, this._locale, DatePipe._ALIASES[pattern] || pattern);
    };
    return DatePipe;
  }());
  DatePipe._ALIASES = {
    'medium': 'yMMMdjms',
    'short': 'yMdjm',
    'fullDate': 'yMMMMEEEEd',
    'longDate': 'yMMMMd',
    'mediumDate': 'yMMMd',
    'shortDate': 'yMd',
    'mediumTime': 'jms',
    'shortTime': 'jm'
  };
  DatePipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'date',
      pure: true
    }]
  }];
  DatePipe.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [_angular_core.LOCALE_ID]
      }]
    }];
  };
  function isBlank(obj) {
    return obj == null || obj === '';
  }
  function isDate(obj) {
    return obj instanceof Date && !isNaN(obj.valueOf());
  }
  function isoStringToDate(match) {
    var date = new Date(0);
    var tzHour = 0;
    var tzMin = 0;
    var dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
    var timeSetter = match[8] ? date.setUTCHours : date.setHours;
    if (match[9]) {
      tzHour = toInt(match[9] + match[10]);
      tzMin = toInt(match[9] + match[11]);
    }
    dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
    var h = toInt(match[4] || '0') - tzHour;
    var m = toInt(match[5] || '0') - tzMin;
    var s = toInt(match[6] || '0');
    var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
    timeSetter.call(date, h, m, s, ms);
    return date;
  }
  function toInt(str) {
    return parseInt(str, 10);
  }
  var _INTERPOLATION_REGEXP = /#/g;
  var I18nPluralPipe = (function() {
    function I18nPluralPipe(_localization) {
      this._localization = _localization;
    }
    I18nPluralPipe.prototype.transform = function(value, pluralMap) {
      if (value == null)
        return '';
      if (typeof pluralMap !== 'object' || pluralMap === null) {
        throw invalidPipeArgumentError(I18nPluralPipe, pluralMap);
      }
      var key = getPluralCategory(value, Object.keys(pluralMap), this._localization);
      return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
    };
    return I18nPluralPipe;
  }());
  I18nPluralPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'i18nPlural',
      pure: true
    }]
  }];
  I18nPluralPipe.ctorParameters = function() {
    return [{type: NgLocalization}];
  };
  var I18nSelectPipe = (function() {
    function I18nSelectPipe() {}
    I18nSelectPipe.prototype.transform = function(value, mapping) {
      if (value == null)
        return '';
      if (typeof mapping !== 'object' || typeof value !== 'string') {
        throw invalidPipeArgumentError(I18nSelectPipe, mapping);
      }
      if (mapping.hasOwnProperty(value)) {
        return mapping[value];
      }
      if (mapping.hasOwnProperty('other')) {
        return mapping['other'];
      }
      return '';
    };
    return I18nSelectPipe;
  }());
  I18nSelectPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'i18nSelect',
      pure: true
    }]
  }];
  I18nSelectPipe.ctorParameters = function() {
    return [];
  };
  var JsonPipe = (function() {
    function JsonPipe() {}
    JsonPipe.prototype.transform = function(value) {
      return JSON.stringify(value, null, 2);
    };
    return JsonPipe;
  }());
  JsonPipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'json',
      pure: false
    }]
  }];
  JsonPipe.ctorParameters = function() {
    return [];
  };
  var SlicePipe = (function() {
    function SlicePipe() {}
    SlicePipe.prototype.transform = function(value, start, end) {
      if (value == null)
        return value;
      if (!this.supports(value)) {
        throw invalidPipeArgumentError(SlicePipe, value);
      }
      return value.slice(start, end);
    };
    SlicePipe.prototype.supports = function(obj) {
      return typeof obj === 'string' || Array.isArray(obj);
    };
    return SlicePipe;
  }());
  SlicePipe.decorators = [{
    type: _angular_core.Pipe,
    args: [{
      name: 'slice',
      pure: false
    }]
  }];
  SlicePipe.ctorParameters = function() {
    return [];
  };
  var COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe];
  var CommonModule = (function() {
    function CommonModule() {}
    return CommonModule;
  }());
  CommonModule.decorators = [{
    type: _angular_core.NgModule,
    args: [{
      declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
      exports: [COMMON_DIRECTIVES, COMMON_PIPES],
      providers: [{
        provide: NgLocalization,
        useClass: NgLocaleLocalization
      }]
    }]
  }];
  CommonModule.ctorParameters = function() {
    return [];
  };
  var DOCUMENT = new _angular_core.InjectionToken('DocumentToken');
  var PLATFORM_BROWSER_ID = 'browser';
  var PLATFORM_SERVER_ID = 'server';
  var PLATFORM_WORKER_APP_ID = 'browserWorkerApp';
  var PLATFORM_WORKER_UI_ID = 'browserWorkerUi';
  function isPlatformBrowser(platformId) {
    return platformId === PLATFORM_BROWSER_ID;
  }
  function isPlatformServer(platformId) {
    return platformId === PLATFORM_SERVER_ID;
  }
  function isPlatformWorkerApp(platformId) {
    return platformId === PLATFORM_WORKER_APP_ID;
  }
  function isPlatformWorkerUi(platformId) {
    return platformId === PLATFORM_WORKER_UI_ID;
  }
  var VERSION = new _angular_core.Version('4.3.4');
  exports.NgLocaleLocalization = NgLocaleLocalization;
  exports.NgLocalization = NgLocalization;
  exports.ɵparseCookieValue = parseCookieValue;
  exports.CommonModule = CommonModule;
  exports.NgClass = NgClass;
  exports.NgFor = NgFor;
  exports.NgForOf = NgForOf;
  exports.NgForOfContext = NgForOfContext;
  exports.NgIf = NgIf;
  exports.NgIfContext = NgIfContext;
  exports.NgPlural = NgPlural;
  exports.NgPluralCase = NgPluralCase;
  exports.NgStyle = NgStyle;
  exports.NgSwitch = NgSwitch;
  exports.NgSwitchCase = NgSwitchCase;
  exports.NgSwitchDefault = NgSwitchDefault;
  exports.NgTemplateOutlet = NgTemplateOutlet;
  exports.NgComponentOutlet = NgComponentOutlet;
  exports.DOCUMENT = DOCUMENT;
  exports.AsyncPipe = AsyncPipe;
  exports.DatePipe = DatePipe;
  exports.I18nPluralPipe = I18nPluralPipe;
  exports.I18nSelectPipe = I18nSelectPipe;
  exports.JsonPipe = JsonPipe;
  exports.LowerCasePipe = LowerCasePipe;
  exports.CurrencyPipe = CurrencyPipe;
  exports.DecimalPipe = DecimalPipe;
  exports.PercentPipe = PercentPipe;
  exports.SlicePipe = SlicePipe;
  exports.UpperCasePipe = UpperCasePipe;
  exports.TitleCasePipe = TitleCasePipe;
  exports.ɵPLATFORM_BROWSER_ID = PLATFORM_BROWSER_ID;
  exports.ɵPLATFORM_SERVER_ID = PLATFORM_SERVER_ID;
  exports.ɵPLATFORM_WORKER_APP_ID = PLATFORM_WORKER_APP_ID;
  exports.ɵPLATFORM_WORKER_UI_ID = PLATFORM_WORKER_UI_ID;
  exports.isPlatformBrowser = isPlatformBrowser;
  exports.isPlatformServer = isPlatformServer;
  exports.isPlatformWorkerApp = isPlatformWorkerApp;
  exports.isPlatformWorkerUi = isPlatformWorkerUi;
  exports.VERSION = VERSION;
  exports.PlatformLocation = PlatformLocation;
  exports.LOCATION_INITIALIZED = LOCATION_INITIALIZED;
  exports.LocationStrategy = LocationStrategy;
  exports.APP_BASE_HREF = APP_BASE_HREF;
  exports.HashLocationStrategy = HashLocationStrategy;
  exports.PathLocationStrategy = PathLocationStrategy;
  exports.Location = Location;
  exports.ɵa = COMMON_DIRECTIVES;
  exports.ɵb = COMMON_PIPES;
  Object.defineProperty(exports, '__esModule', {value: true});
})));

})();
System.registerDynamic("node_modules/rxjs/observable/ScalarObservable.js", ["node_modules/rxjs/Observable.js"], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Observable_1 = $__require("node_modules/rxjs/Observable.js");
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var ScalarObservable = function (_super) {
        __extends(ScalarObservable, _super);
        function ScalarObservable(value, scheduler) {
            _super.call(this);
            this.value = value;
            this.scheduler = scheduler;
            this._isScalar = true;
            if (scheduler) {
                this._isScalar = false;
            }
        }
        ScalarObservable.create = function (value, scheduler) {
            return new ScalarObservable(value, scheduler);
        };
        ScalarObservable.dispatch = function (state) {
            var done = state.done,
                value = state.value,
                subscriber = state.subscriber;
            if (done) {
                subscriber.complete();
                return;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                return;
            }
            state.done = true;
            this.schedule(state);
        };
        ScalarObservable.prototype._subscribe = function (subscriber) {
            var value = this.value;
            var scheduler = this.scheduler;
            if (scheduler) {
                return scheduler.schedule(ScalarObservable.dispatch, 0, {
                    done: false, value: value, subscriber: subscriber
                });
            } else {
                subscriber.next(value);
                if (!subscriber.closed) {
                    subscriber.complete();
                }
            }
        };
        return ScalarObservable;
    }(Observable_1.Observable);
    exports.ScalarObservable = ScalarObservable;
    
});
System.registerDynamic("node_modules/rxjs/observable/EmptyObservable.js", ["node_modules/rxjs/Observable.js"], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Observable_1 = $__require("node_modules/rxjs/Observable.js");
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var EmptyObservable = function (_super) {
        __extends(EmptyObservable, _super);
        function EmptyObservable(scheduler) {
            _super.call(this);
            this.scheduler = scheduler;
        }
        /**
         * Creates an Observable that emits no items to the Observer and immediately
         * emits a complete notification.
         *
         * <span class="informal">Just emits 'complete', and nothing else.
         * </span>
         *
         * <img src="./img/empty.png" width="100%">
         *
         * This static operator is useful for creating a simple Observable that only
         * emits the complete notification. It can be used for composing with other
         * Observables, such as in a {@link mergeMap}.
         *
         * @example <caption>Emit the number 7, then complete.</caption>
         * var result = Rx.Observable.empty().startWith(7);
         * result.subscribe(x => console.log(x));
         *
         * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
         * var interval = Rx.Observable.interval(1000);
         * var result = interval.mergeMap(x =>
         *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
         * );
         * result.subscribe(x => console.log(x));
         *
         * // Results in the following to the console:
         * // x is equal to the count on the interval eg(0,1,2,3,...)
         * // x will occur every 1000ms
         * // if x % 2 is equal to 1 print abc
         * // if x % 2 is not equal to 1 nothing will be output
         *
         * @see {@link create}
         * @see {@link never}
         * @see {@link of}
         * @see {@link throw}
         *
         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
         * the emission of the complete notification.
         * @return {Observable} An "empty" Observable: emits only the complete
         * notification.
         * @static true
         * @name empty
         * @owner Observable
         */
        EmptyObservable.create = function (scheduler) {
            return new EmptyObservable(scheduler);
        };
        EmptyObservable.dispatch = function (arg) {
            var subscriber = arg.subscriber;
            subscriber.complete();
        };
        EmptyObservable.prototype._subscribe = function (subscriber) {
            var scheduler = this.scheduler;
            if (scheduler) {
                return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
            } else {
                subscriber.complete();
            }
        };
        return EmptyObservable;
    }(Observable_1.Observable);
    exports.EmptyObservable = EmptyObservable;
    
});
System.registerDynamic('node_modules/rxjs/observable/ArrayObservable.js', ['node_modules/rxjs/Observable.js', 'node_modules/rxjs/observable/ScalarObservable.js', 'node_modules/rxjs/observable/EmptyObservable.js', 'node_modules/rxjs/util/isScheduler.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Observable_1 = $__require('node_modules/rxjs/Observable.js');
    var ScalarObservable_1 = $__require('node_modules/rxjs/observable/ScalarObservable.js');
    var EmptyObservable_1 = $__require('node_modules/rxjs/observable/EmptyObservable.js');
    var isScheduler_1 = $__require('node_modules/rxjs/util/isScheduler.js');
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var ArrayObservable = function (_super) {
        __extends(ArrayObservable, _super);
        function ArrayObservable(array, scheduler) {
            _super.call(this);
            this.array = array;
            this.scheduler = scheduler;
            if (!scheduler && array.length === 1) {
                this._isScalar = true;
                this.value = array[0];
            }
        }
        ArrayObservable.create = function (array, scheduler) {
            return new ArrayObservable(array, scheduler);
        };
        /**
         * Creates an Observable that emits some values you specify as arguments,
         * immediately one after the other, and then emits a complete notification.
         *
         * <span class="informal">Emits the arguments you provide, then completes.
         * </span>
         *
         * <img src="./img/of.png" width="100%">
         *
         * This static operator is useful for creating a simple Observable that only
         * emits the arguments given, and the complete notification thereafter. It can
         * be used for composing with other Observables, such as with {@link concat}.
         * By default, it uses a `null` IScheduler, which means the `next`
         * notifications are sent synchronously, although with a different IScheduler
         * it is possible to determine when those notifications will be delivered.
         *
         * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
         * var numbers = Rx.Observable.of(10, 20, 30);
         * var letters = Rx.Observable.of('a', 'b', 'c');
         * var interval = Rx.Observable.interval(1000);
         * var result = numbers.concat(letters).concat(interval);
         * result.subscribe(x => console.log(x));
         *
         * @see {@link create}
         * @see {@link empty}
         * @see {@link never}
         * @see {@link throw}
         *
         * @param {...T} values Arguments that represent `next` values to be emitted.
         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
         * the emissions of the `next` notifications.
         * @return {Observable<T>} An Observable that emits each given input value.
         * @static true
         * @name of
         * @owner Observable
         */
        ArrayObservable.of = function () {
            var array = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                array[_i - 0] = arguments[_i];
            }
            var scheduler = array[array.length - 1];
            if (isScheduler_1.isScheduler(scheduler)) {
                array.pop();
            } else {
                scheduler = null;
            }
            var len = array.length;
            if (len > 1) {
                return new ArrayObservable(array, scheduler);
            } else if (len === 1) {
                return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
            } else {
                return new EmptyObservable_1.EmptyObservable(scheduler);
            }
        };
        ArrayObservable.dispatch = function (state) {
            var array = state.array,
                index = state.index,
                count = state.count,
                subscriber = state.subscriber;
            if (index >= count) {
                subscriber.complete();
                return;
            }
            subscriber.next(array[index]);
            if (subscriber.closed) {
                return;
            }
            state.index = index + 1;
            this.schedule(state);
        };
        ArrayObservable.prototype._subscribe = function (subscriber) {
            var index = 0;
            var array = this.array;
            var count = array.length;
            var scheduler = this.scheduler;
            if (scheduler) {
                return scheduler.schedule(ArrayObservable.dispatch, 0, {
                    array: array, index: index, count: count, subscriber: subscriber
                });
            } else {
                for (var i = 0; i < count && !subscriber.closed; i++) {
                    subscriber.next(array[i]);
                }
                subscriber.complete();
            }
        };
        return ArrayObservable;
    }(Observable_1.Observable);
    exports.ArrayObservable = ArrayObservable;
    
});
System.registerDynamic("node_modules/rxjs/OuterSubscriber.js", ["node_modules/rxjs/Subscriber.js"], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscriber_1 = $__require("node_modules/rxjs/Subscriber.js");
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var OuterSubscriber = function (_super) {
        __extends(OuterSubscriber, _super);
        function OuterSubscriber() {
            _super.apply(this, arguments);
        }
        OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.destination.next(innerValue);
        };
        OuterSubscriber.prototype.notifyError = function (error, innerSub) {
            this.destination.error(error);
        };
        OuterSubscriber.prototype.notifyComplete = function (innerSub) {
            this.destination.complete();
        };
        return OuterSubscriber;
    }(Subscriber_1.Subscriber);
    exports.OuterSubscriber = OuterSubscriber;
    
});
System.registerDynamic("node_modules/rxjs/util/isArrayLike.js", [], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  exports.isArrayLike = function (x) {
    return x && typeof x.length === 'number';
  };
  
});
System.registerDynamic('node_modules/rxjs/util/isPromise.js', [], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    function isPromise(value) {
        return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
    }
    exports.isPromise = isPromise;
    
});
System.registerDynamic('node_modules/rxjs/symbol/iterator.js', ['node_modules/rxjs/util/root.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var root_1 = $__require('node_modules/rxjs/util/root.js');
    function symbolIteratorPonyfill(root) {
        var Symbol = root.Symbol;
        if (typeof Symbol === 'function') {
            if (!Symbol.iterator) {
                Symbol.iterator = Symbol('iterator polyfill');
            }
            return Symbol.iterator;
        } else {
            // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
            var Set_1 = root.Set;
            if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
                return '@@iterator';
            }
            var Map_1 = root.Map;
            // required for compatability with es6-shim
            if (Map_1) {
                var keys = Object.getOwnPropertyNames(Map_1.prototype);
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                    if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                        return key;
                    }
                }
            }
            return '@@iterator';
        }
    }
    exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
    exports.iterator = symbolIteratorPonyfill(root_1.root);
    /**
     * @deprecated use iterator instead
     */
    exports.$$iterator = exports.iterator;
    
});
System.registerDynamic("node_modules/rxjs/InnerSubscriber.js", ["node_modules/rxjs/Subscriber.js"], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscriber_1 = $__require("node_modules/rxjs/Subscriber.js");
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var InnerSubscriber = function (_super) {
        __extends(InnerSubscriber, _super);
        function InnerSubscriber(parent, outerValue, outerIndex) {
            _super.call(this);
            this.parent = parent;
            this.outerValue = outerValue;
            this.outerIndex = outerIndex;
            this.index = 0;
        }
        InnerSubscriber.prototype._next = function (value) {
            this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
        };
        InnerSubscriber.prototype._error = function (error) {
            this.parent.notifyError(error, this);
            this.unsubscribe();
        };
        InnerSubscriber.prototype._complete = function () {
            this.parent.notifyComplete(this);
            this.unsubscribe();
        };
        return InnerSubscriber;
    }(Subscriber_1.Subscriber);
    exports.InnerSubscriber = InnerSubscriber;
    
});
System.registerDynamic('node_modules/rxjs/util/subscribeToResult.js', ['node_modules/rxjs/util/root.js', 'node_modules/rxjs/util/isArrayLike.js', 'node_modules/rxjs/util/isPromise.js', 'node_modules/rxjs/util/isObject.js', 'node_modules/rxjs/Observable.js', 'node_modules/rxjs/symbol/iterator.js', 'node_modules/rxjs/InnerSubscriber.js', 'node_modules/rxjs/symbol/observable.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var root_1 = $__require('node_modules/rxjs/util/root.js');
    var isArrayLike_1 = $__require('node_modules/rxjs/util/isArrayLike.js');
    var isPromise_1 = $__require('node_modules/rxjs/util/isPromise.js');
    var isObject_1 = $__require('node_modules/rxjs/util/isObject.js');
    var Observable_1 = $__require('node_modules/rxjs/Observable.js');
    var iterator_1 = $__require('node_modules/rxjs/symbol/iterator.js');
    var InnerSubscriber_1 = $__require('node_modules/rxjs/InnerSubscriber.js');
    var observable_1 = $__require('node_modules/rxjs/symbol/observable.js');
    function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
        var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
        if (destination.closed) {
            return null;
        }
        if (result instanceof Observable_1.Observable) {
            if (result._isScalar) {
                destination.next(result.value);
                destination.complete();
                return null;
            } else {
                return result.subscribe(destination);
            }
        } else if (isArrayLike_1.isArrayLike(result)) {
            for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
                destination.next(result[i]);
            }
            if (!destination.closed) {
                destination.complete();
            }
        } else if (isPromise_1.isPromise(result)) {
            result.then(function (value) {
                if (!destination.closed) {
                    destination.next(value);
                    destination.complete();
                }
            }, function (err) {
                return destination.error(err);
            }).then(null, function (err) {
                // Escaping the Promise trap: globally throw unhandled errors
                root_1.root.setTimeout(function () {
                    throw err;
                });
            });
            return destination;
        } else if (result && typeof result[iterator_1.iterator] === 'function') {
            var iterator = result[iterator_1.iterator]();
            do {
                var item = iterator.next();
                if (item.done) {
                    destination.complete();
                    break;
                }
                destination.next(item.value);
                if (destination.closed) {
                    break;
                }
            } while (true);
        } else if (result && typeof result[observable_1.observable] === 'function') {
            var obs = result[observable_1.observable]();
            if (typeof obs.subscribe !== 'function') {
                destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
            } else {
                return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
            }
        } else {
            var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
            var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
            destination.error(new TypeError(msg));
        }
        return null;
    }
    exports.subscribeToResult = subscribeToResult;
    
});
System.registerDynamic('node_modules/rxjs/operator/mergeAll.js', ['node_modules/rxjs/OuterSubscriber.js', 'node_modules/rxjs/util/subscribeToResult.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var OuterSubscriber_1 = $__require('node_modules/rxjs/OuterSubscriber.js');
    var subscribeToResult_1 = $__require('node_modules/rxjs/util/subscribeToResult.js');
    /**
     * Converts a higher-order Observable into a first-order Observable which
     * concurrently delivers all values that are emitted on the inner Observables.
     *
     * <span class="informal">Flattens an Observable-of-Observables.</span>
     *
     * <img src="./img/mergeAll.png" width="100%">
     *
     * `mergeAll` subscribes to an Observable that emits Observables, also known as
     * a higher-order Observable. Each time it observes one of these emitted inner
     * Observables, it subscribes to that and delivers all the values from the
     * inner Observable on the output Observable. The output Observable only
     * completes once all inner Observables have completed. Any error delivered by
     * a inner Observable will be immediately emitted on the output Observable.
     *
     * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
     * var firstOrder = higherOrder.mergeAll();
     * firstOrder.subscribe(x => console.log(x));
     *
     * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
     * var firstOrder = higherOrder.mergeAll(2);
     * firstOrder.subscribe(x => console.log(x));
     *
     * @see {@link combineAll}
     * @see {@link concatAll}
     * @see {@link exhaust}
     * @see {@link merge}
     * @see {@link mergeMap}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     * @see {@link switch}
     * @see {@link zipAll}
     *
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
     * Observables being subscribed to concurrently.
     * @return {Observable} An Observable that emits values coming from all the
     * inner Observables emitted by the source Observable.
     * @method mergeAll
     * @owner Observable
     */
    function mergeAll(concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        return this.lift(new MergeAllOperator(concurrent));
    }
    exports.mergeAll = mergeAll;
    var MergeAllOperator = function () {
        function MergeAllOperator(concurrent) {
            this.concurrent = concurrent;
        }
        MergeAllOperator.prototype.call = function (observer, source) {
            return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
        };
        return MergeAllOperator;
    }();
    exports.MergeAllOperator = MergeAllOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var MergeAllSubscriber = function (_super) {
        __extends(MergeAllSubscriber, _super);
        function MergeAllSubscriber(destination, concurrent) {
            _super.call(this, destination);
            this.concurrent = concurrent;
            this.hasCompleted = false;
            this.buffer = [];
            this.active = 0;
        }
        MergeAllSubscriber.prototype._next = function (observable) {
            if (this.active < this.concurrent) {
                this.active++;
                this.add(subscribeToResult_1.subscribeToResult(this, observable));
            } else {
                this.buffer.push(observable);
            }
        };
        MergeAllSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.active === 0 && this.buffer.length === 0) {
                this.destination.complete();
            }
        };
        MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
            var buffer = this.buffer;
            this.remove(innerSub);
            this.active--;
            if (buffer.length > 0) {
                this._next(buffer.shift());
            } else if (this.active === 0 && this.hasCompleted) {
                this.destination.complete();
            }
        };
        return MergeAllSubscriber;
    }(OuterSubscriber_1.OuterSubscriber);
    exports.MergeAllSubscriber = MergeAllSubscriber;
    
});
System.registerDynamic("node_modules/rxjs/util/isScheduler.js", [], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    function isScheduler(value) {
        return value && typeof value.schedule === 'function';
    }
    exports.isScheduler = isScheduler;
    
});
System.registerDynamic('node_modules/rxjs/operator/merge.js', ['node_modules/rxjs/Observable.js', 'node_modules/rxjs/observable/ArrayObservable.js', 'node_modules/rxjs/operator/mergeAll.js', 'node_modules/rxjs/util/isScheduler.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var Observable_1 = $__require('node_modules/rxjs/Observable.js');
    var ArrayObservable_1 = $__require('node_modules/rxjs/observable/ArrayObservable.js');
    var mergeAll_1 = $__require('node_modules/rxjs/operator/mergeAll.js');
    var isScheduler_1 = $__require('node_modules/rxjs/util/isScheduler.js');
    /* tslint:enable:max-line-length */
    /**
     * Creates an output Observable which concurrently emits all values from every
     * given input Observable.
     *
     * <span class="informal">Flattens multiple Observables together by blending
     * their values into one Observable.</span>
     *
     * <img src="./img/merge.png" width="100%">
     *
     * `merge` subscribes to each given input Observable (either the source or an
     * Observable given as argument), and simply forwards (without doing any
     * transformation) all the values from all the input Observables to the output
     * Observable. The output Observable only completes once all input Observables
     * have completed. Any error delivered by an input Observable will be immediately
     * emitted on the output Observable.
     *
     * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var timer = Rx.Observable.interval(1000);
     * var clicksOrTimer = clicks.merge(timer);
     * clicksOrTimer.subscribe(x => console.log(x));
     *
     * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
     * var timer1 = Rx.Observable.interval(1000).take(10);
     * var timer2 = Rx.Observable.interval(2000).take(6);
     * var timer3 = Rx.Observable.interval(500).take(10);
     * var concurrent = 2; // the argument
     * var merged = timer1.merge(timer2, timer3, concurrent);
     * merged.subscribe(x => console.log(x));
     *
     * @see {@link mergeAll}
     * @see {@link mergeMap}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     *
     * @param {ObservableInput} other An input Observable to merge with the source
     * Observable. More than one input Observables may be given as argument.
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
     * concurrency of input Observables.
     * @return {Observable} An Observable that emits items that are the result of
     * every input Observable.
     * @method merge
     * @owner Observable
     */
    function merge() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
    }
    exports.merge = merge;
    /* tslint:enable:max-line-length */
    /**
     * Creates an output Observable which concurrently emits all values from every
     * given input Observable.
     *
     * <span class="informal">Flattens multiple Observables together by blending
     * their values into one Observable.</span>
     *
     * <img src="./img/merge.png" width="100%">
     *
     * `merge` subscribes to each given input Observable (as arguments), and simply
     * forwards (without doing any transformation) all the values from all the input
     * Observables to the output Observable. The output Observable only completes
     * once all input Observables have completed. Any error delivered by an input
     * Observable will be immediately emitted on the output Observable.
     *
     * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var timer = Rx.Observable.interval(1000);
     * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
     * clicksOrTimer.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // timer will emit ascending values, one every second(1000ms) to console
     * // clicks logs MouseEvents to console everytime the "document" is clicked
     * // Since the two streams are merged you see these happening
     * // as they occur.
     *
     * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
     * var timer1 = Rx.Observable.interval(1000).take(10);
     * var timer2 = Rx.Observable.interval(2000).take(6);
     * var timer3 = Rx.Observable.interval(500).take(10);
     * var concurrent = 2; // the argument
     * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
     * merged.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // - First timer1 and timer2 will run concurrently
     * // - timer1 will emit a value every 1000ms for 10 iterations
     * // - timer2 will emit a value every 2000ms for 6 iterations
     * // - after timer1 hits it's max iteration, timer2 will
     * //   continue, and timer3 will start to run concurrently with timer2
     * // - when timer2 hits it's max iteration it terminates, and
     * //   timer3 will continue to emit a value every 500ms until it is complete
     *
     * @see {@link mergeAll}
     * @see {@link mergeMap}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     *
     * @param {...ObservableInput} observables Input Observables to merge together.
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
     * concurrency of input Observables.
     * @return {Observable} an Observable that emits items that are the result of
     * every input Observable.
     * @static true
     * @name merge
     * @owner Observable
     */
    function mergeStatic() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        var concurrent = Number.POSITIVE_INFINITY;
        var scheduler = null;
        var last = observables[observables.length - 1];
        if (isScheduler_1.isScheduler(last)) {
            scheduler = observables.pop();
            if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
                concurrent = observables.pop();
            }
        } else if (typeof last === 'number') {
            concurrent = observables.pop();
        }
        if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
            return observables[0];
        }
        return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
    }
    exports.mergeStatic = mergeStatic;
    
});
System.registerDynamic("node_modules/rxjs/observable/merge.js", ["node_modules/rxjs/operator/merge.js"], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var merge_1 = $__require("node_modules/rxjs/operator/merge.js");
  exports.merge = merge_1.mergeStatic;
  
});
System.registerDynamic('node_modules/rxjs/observable/ConnectableObservable.js', ['node_modules/rxjs/Subject.js', 'node_modules/rxjs/Observable.js', 'node_modules/rxjs/Subscriber.js', 'node_modules/rxjs/Subscription.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subject_1 = $__require('node_modules/rxjs/Subject.js');
    var Observable_1 = $__require('node_modules/rxjs/Observable.js');
    var Subscriber_1 = $__require('node_modules/rxjs/Subscriber.js');
    var Subscription_1 = $__require('node_modules/rxjs/Subscription.js');
    /**
     * @class ConnectableObservable<T>
     */
    var ConnectableObservable = function (_super) {
        __extends(ConnectableObservable, _super);
        function ConnectableObservable(source, subjectFactory) {
            _super.call(this);
            this.source = source;
            this.subjectFactory = subjectFactory;
            this._refCount = 0;
            this._isComplete = false;
        }
        ConnectableObservable.prototype._subscribe = function (subscriber) {
            return this.getSubject().subscribe(subscriber);
        };
        ConnectableObservable.prototype.getSubject = function () {
            var subject = this._subject;
            if (!subject || subject.isStopped) {
                this._subject = this.subjectFactory();
            }
            return this._subject;
        };
        ConnectableObservable.prototype.connect = function () {
            var connection = this._connection;
            if (!connection) {
                this._isComplete = false;
                connection = this._connection = new Subscription_1.Subscription();
                connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
                if (connection.closed) {
                    this._connection = null;
                    connection = Subscription_1.Subscription.EMPTY;
                } else {
                    this._connection = connection;
                }
            }
            return connection;
        };
        ConnectableObservable.prototype.refCount = function () {
            return this.lift(new RefCountOperator(this));
        };
        return ConnectableObservable;
    }(Observable_1.Observable);
    exports.ConnectableObservable = ConnectableObservable;
    var connectableProto = ConnectableObservable.prototype;
    exports.connectableObservableDescriptor = {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
    var ConnectableSubscriber = function (_super) {
        __extends(ConnectableSubscriber, _super);
        function ConnectableSubscriber(destination, connectable) {
            _super.call(this, destination);
            this.connectable = connectable;
        }
        ConnectableSubscriber.prototype._error = function (err) {
            this._unsubscribe();
            _super.prototype._error.call(this, err);
        };
        ConnectableSubscriber.prototype._complete = function () {
            this.connectable._isComplete = true;
            this._unsubscribe();
            _super.prototype._complete.call(this);
        };
        ConnectableSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (connectable) {
                this.connectable = null;
                var connection = connectable._connection;
                connectable._refCount = 0;
                connectable._subject = null;
                connectable._connection = null;
                if (connection) {
                    connection.unsubscribe();
                }
            }
        };
        return ConnectableSubscriber;
    }(Subject_1.SubjectSubscriber);
    var RefCountOperator = function () {
        function RefCountOperator(connectable) {
            this.connectable = connectable;
        }
        RefCountOperator.prototype.call = function (subscriber, source) {
            var connectable = this.connectable;
            connectable._refCount++;
            var refCounter = new RefCountSubscriber(subscriber, connectable);
            var subscription = source.subscribe(refCounter);
            if (!refCounter.closed) {
                refCounter.connection = connectable.connect();
            }
            return subscription;
        };
        return RefCountOperator;
    }();
    var RefCountSubscriber = function (_super) {
        __extends(RefCountSubscriber, _super);
        function RefCountSubscriber(destination, connectable) {
            _super.call(this, destination);
            this.connectable = connectable;
        }
        RefCountSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (!connectable) {
                this.connection = null;
                return;
            }
            this.connectable = null;
            var refCount = connectable._refCount;
            if (refCount <= 0) {
                this.connection = null;
                return;
            }
            connectable._refCount = refCount - 1;
            if (refCount > 1) {
                this.connection = null;
                return;
            }
            ///
            // Compare the local RefCountSubscriber's connection Subscription to the
            // connection Subscription on the shared ConnectableObservable. In cases
            // where the ConnectableObservable source synchronously emits values, and
            // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
            // execution continues to here before the RefCountOperator has a chance to
            // supply the RefCountSubscriber with the shared connection Subscription.
            // For example:
            // ```
            // Observable.range(0, 10)
            //   .publish()
            //   .refCount()
            //   .take(5)
            //   .subscribe();
            // ```
            // In order to account for this case, RefCountSubscriber should only dispose
            // the ConnectableObservable's shared connection Subscription if the
            // connection Subscription exists, *and* either:
            //   a. RefCountSubscriber doesn't have a reference to the shared connection
            //      Subscription yet, or,
            //   b. RefCountSubscriber's connection Subscription reference is identical
            //      to the shared connection Subscription
            ///
            var connection = this.connection;
            var sharedConnection = connectable._connection;
            this.connection = null;
            if (sharedConnection && (!connection || sharedConnection === connection)) {
                sharedConnection.unsubscribe();
            }
        };
        return RefCountSubscriber;
    }(Subscriber_1.Subscriber);
    
});
System.registerDynamic('node_modules/rxjs/operator/multicast.js', ['node_modules/rxjs/observable/ConnectableObservable.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var ConnectableObservable_1 = $__require('node_modules/rxjs/observable/ConnectableObservable.js');
    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that emits the results of invoking a specified selector on items
     * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
     *
     * <img src="./img/multicast.png" width="100%">
     *
     * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
     * which the source sequence's elements will be multicast to the selector function
     * or Subject to push source elements into.
     * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
     * as many times as needed, without causing multiple subscriptions to the source stream.
     * Subscribers to the given source will receive all notifications of the source from the
     * time of the subscription forward.
     * @return {Observable} An Observable that emits the results of invoking the selector
     * on the items emitted by a `ConnectableObservable` that shares a single subscription to
     * the underlying stream.
     * @method multicast
     * @owner Observable
     */
    function multicast(subjectOrSubjectFactory, selector) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        } else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return this.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
        connectable.source = this;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    }
    exports.multicast = multicast;
    var MulticastOperator = function () {
        function MulticastOperator(subjectFactory, selector) {
            this.subjectFactory = subjectFactory;
            this.selector = selector;
        }
        MulticastOperator.prototype.call = function (subscriber, source) {
            var selector = this.selector;
            var subject = this.subjectFactory();
            var subscription = selector(subject).subscribe(subscriber);
            subscription.add(source.subscribe(subject));
            return subscription;
        };
        return MulticastOperator;
    }();
    exports.MulticastOperator = MulticastOperator;
    
});
System.registerDynamic('node_modules/rxjs/operator/share.js', ['node_modules/rxjs/operator/multicast.js', 'node_modules/rxjs/Subject.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var multicast_1 = $__require('node_modules/rxjs/operator/multicast.js');
    var Subject_1 = $__require('node_modules/rxjs/Subject.js');
    function shareSubjectFactory() {
        return new Subject_1.Subject();
    }
    /**
     * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
     * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
     * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
     * This is an alias for .publish().refCount().
     *
     * <img src="./img/share.png" width="100%">
     *
     * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
     * @method share
     * @owner Observable
     */
    function share() {
        return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
    }
    exports.share = share;
    ;
    
});
System.registerDynamic('node_modules/rxjs/util/toSubscriber.js', ['node_modules/rxjs/Subscriber.js', 'node_modules/rxjs/symbol/rxSubscriber.js', 'node_modules/rxjs/Observer.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var Subscriber_1 = $__require('node_modules/rxjs/Subscriber.js');
    var rxSubscriber_1 = $__require('node_modules/rxjs/symbol/rxSubscriber.js');
    var Observer_1 = $__require('node_modules/rxjs/Observer.js');
    function toSubscriber(nextOrObserver, error, complete) {
        if (nextOrObserver) {
            if (nextOrObserver instanceof Subscriber_1.Subscriber) {
                return nextOrObserver;
            }
            if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
                return nextOrObserver[rxSubscriber_1.rxSubscriber]();
            }
        }
        if (!nextOrObserver && !error && !complete) {
            return new Subscriber_1.Subscriber(Observer_1.empty);
        }
        return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
    }
    exports.toSubscriber = toSubscriber;
    
});
System.registerDynamic('node_modules/rxjs/symbol/observable.js', ['node_modules/rxjs/util/root.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var root_1 = $__require('node_modules/rxjs/util/root.js');
    function getSymbolObservable(context) {
        var $$observable;
        var Symbol = context.Symbol;
        if (typeof Symbol === 'function') {
            if (Symbol.observable) {
                $$observable = Symbol.observable;
            } else {
                $$observable = Symbol('observable');
                Symbol.observable = $$observable;
            }
        } else {
            $$observable = '@@observable';
        }
        return $$observable;
    }
    exports.getSymbolObservable = getSymbolObservable;
    exports.observable = getSymbolObservable(root_1.root);
    /**
     * @deprecated use observable instead
     */
    exports.$$observable = exports.observable;
    
});
System.registerDynamic('node_modules/rxjs/Observable.js', ['node_modules/rxjs/util/root.js', 'node_modules/rxjs/util/toSubscriber.js', 'node_modules/rxjs/symbol/observable.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var root_1 = $__require('node_modules/rxjs/util/root.js');
    var toSubscriber_1 = $__require('node_modules/rxjs/util/toSubscriber.js');
    var observable_1 = $__require('node_modules/rxjs/symbol/observable.js');
    /**
     * A representation of any set of values over any amount of time. This is the most basic building block
     * of RxJS.
     *
     * @class Observable<T>
     */
    var Observable = function () {
        /**
         * @constructor
         * @param {Function} subscribe the function that is called when the Observable is
         * initially subscribed to. This function is given a Subscriber, to which new values
         * can be `next`ed, or an `error` method can be called to raise an error, or
         * `complete` can be called to notify of a successful completion.
         */
        function Observable(subscribe) {
            this._isScalar = false;
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        /**
         * Creates a new Observable, with this Observable as the source, and the passed
         * operator defined as the new observable's operator.
         * @method lift
         * @param {Operator} operator the operator defining the operation to take on the observable
         * @return {Observable} a new observable with the Operator applied
         */
        Observable.prototype.lift = function (operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
        };
        /**
         * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
         *
         * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
         *
         * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
         * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
         * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
         * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
         * thought.
         *
         * Apart from starting the execution of an Observable, this method allows you to listen for values
         * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
         * following ways.
         *
         * The first way is creating an object that implements {@link Observer} interface. It should have methods
         * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
         * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
         * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
         * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
         * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
         * be left uncaught.
         *
         * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
         * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
         * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
         * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
         * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
         * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
         *
         * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
         * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
         * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
         * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
         *
         * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
         * It is an Observable itself that decides when these functions will be called. For example {@link of}
         * by default emits all its values synchronously. Always check documentation for how given Observable
         * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
         *
         * @example <caption>Subscribe with an Observer</caption>
         * const sumObserver = {
         *   sum: 0,
         *   next(value) {
         *     console.log('Adding: ' + value);
         *     this.sum = this.sum + value;
         *   },
         *   error() { // We actually could just remove this method,
         *   },        // since we do not really care about errors right now.
         *   complete() {
         *     console.log('Sum equals: ' + this.sum);
         *   }
         * };
         *
         * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
         * .subscribe(sumObserver);
         *
         * // Logs:
         * // "Adding: 1"
         * // "Adding: 2"
         * // "Adding: 3"
         * // "Sum equals: 6"
         *
         *
         * @example <caption>Subscribe with functions</caption>
         * let sum = 0;
         *
         * Rx.Observable.of(1, 2, 3)
         * .subscribe(
         *   function(value) {
         *     console.log('Adding: ' + value);
         *     sum = sum + value;
         *   },
         *   undefined,
         *   function() {
         *     console.log('Sum equals: ' + sum);
         *   }
         * );
         *
         * // Logs:
         * // "Adding: 1"
         * // "Adding: 2"
         * // "Adding: 3"
         * // "Sum equals: 6"
         *
         *
         * @example <caption>Cancel a subscription</caption>
         * const subscription = Rx.Observable.interval(1000).subscribe(
         *   num => console.log(num),
         *   undefined,
         *   () => console.log('completed!') // Will not be called, even
         * );                                // when cancelling subscription
         *
         *
         * setTimeout(() => {
         *   subscription.unsubscribe();
         *   console.log('unsubscribed!');
         * }, 2500);
         *
         * // Logs:
         * // 0 after 1s
         * // 1 after 2s
         * // "unsubscribed!" after 2.5s
         *
         *
         * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
         *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
         *  Observable.
         * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
         *  the error will be thrown as unhandled.
         * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
         * @return {ISubscription} a subscription reference to the registered handlers
         * @method subscribe
         */
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var operator = this.operator;
            var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
            if (operator) {
                operator.call(sink, this.source);
            } else {
                sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
            }
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
            return sink;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            } catch (err) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
                sink.error(err);
            }
        };
        /**
         * @method forEach
         * @param {Function} next a handler for each value emitted by the observable
         * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
         * @return {Promise} a promise that either resolves on observable completion or
         *  rejects with the handled error
         */
        Observable.prototype.forEach = function (next, PromiseCtor) {
            var _this = this;
            if (!PromiseCtor) {
                if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                    PromiseCtor = root_1.root.Rx.config.Promise;
                } else if (root_1.root.Promise) {
                    PromiseCtor = root_1.root.Promise;
                }
            }
            if (!PromiseCtor) {
                throw new Error('no Promise impl found');
            }
            return new PromiseCtor(function (resolve, reject) {
                // Must be declared in a separate statement to avoid a RefernceError when
                // accessing subscription below in the closure due to Temporal Dead Zone.
                var subscription;
                subscription = _this.subscribe(function (value) {
                    if (subscription) {
                        // if there is a subscription, then we can surmise
                        // the next handling is asynchronous. Any errors thrown
                        // need to be rejected explicitly and unsubscribe must be
                        // called manually
                        try {
                            next(value);
                        } catch (err) {
                            reject(err);
                            subscription.unsubscribe();
                        }
                    } else {
                        // if there is NO subscription, then we're getting a nexted
                        // value synchronously during subscription. We can just call it.
                        // If it errors, Observable's `subscribe` will ensure the
                        // unsubscription logic is called, then synchronously rethrow the error.
                        // After that, Promise will trap the error and send it
                        // down the rejection path.
                        next(value);
                    }
                }, reject, resolve);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            return this.source.subscribe(subscriber);
        };
        /**
         * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
         * @method Symbol.observable
         * @return {Observable} this instance of the observable
         */
        Observable.prototype[observable_1.observable] = function () {
            return this;
        };
        // HACK: Since TypeScript inherits static properties too, we have to
        // fight against TypeScript here so Subject can have a different static create signature
        /**
         * Creates a new cold Observable by calling the Observable constructor
         * @static true
         * @owner Observable
         * @method create
         * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
         * @return {Observable} a new cold observable
         */
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }();
    exports.Observable = Observable;
    
});
System.registerDynamic("node_modules/rxjs/Observer.js", [], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    exports.empty = {
        closed: true,
        next: function (value) {},
        error: function (err) {
            throw err;
        },
        complete: function () {}
    };
    
});
System.registerDynamic('node_modules/rxjs/Subscriber.js', ['node_modules/rxjs/util/isFunction.js', 'node_modules/rxjs/Subscription.js', 'node_modules/rxjs/Observer.js', 'node_modules/rxjs/symbol/rxSubscriber.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var isFunction_1 = $__require('node_modules/rxjs/util/isFunction.js');
    var Subscription_1 = $__require('node_modules/rxjs/Subscription.js');
    var Observer_1 = $__require('node_modules/rxjs/Observer.js');
    var rxSubscriber_1 = $__require('node_modules/rxjs/symbol/rxSubscriber.js');
    /**
     * Implements the {@link Observer} interface and extends the
     * {@link Subscription} class. While the {@link Observer} is the public API for
     * consuming the values of an {@link Observable}, all Observers get converted to
     * a Subscriber, in order to provide Subscription-like capabilities such as
     * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
     * implementing operators, but it is rarely used as a public API.
     *
     * @class Subscriber<T>
     */
    var Subscriber = function (_super) {
        __extends(Subscriber, _super);
        /**
         * @param {Observer|function(value: T): void} [destinationOrNext] A partially
         * defined Observer or a `next` callback function.
         * @param {function(e: ?any): void} [error] The `error` callback of an
         * Observer.
         * @param {function(): void} [complete] The `complete` callback of an
         * Observer.
         */
        function Subscriber(destinationOrNext, error, complete) {
            _super.call(this);
            this.syncErrorValue = null;
            this.syncErrorThrown = false;
            this.syncErrorThrowable = false;
            this.isStopped = false;
            switch (arguments.length) {
                case 0:
                    this.destination = Observer_1.empty;
                    break;
                case 1:
                    if (!destinationOrNext) {
                        this.destination = Observer_1.empty;
                        break;
                    }
                    if (typeof destinationOrNext === 'object') {
                        if (destinationOrNext instanceof Subscriber) {
                            this.destination = destinationOrNext;
                            this.destination.add(this);
                        } else {
                            this.syncErrorThrowable = true;
                            this.destination = new SafeSubscriber(this, destinationOrNext);
                        }
                        break;
                    }
                default:
                    this.syncErrorThrowable = true;
                    this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                    break;
            }
        }
        Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {
            return this;
        };
        /**
         * A static factory for a Subscriber, given a (potentially partial) definition
         * of an Observer.
         * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
         * @param {function(e: ?any): void} [error] The `error` callback of an
         * Observer.
         * @param {function(): void} [complete] The `complete` callback of an
         * Observer.
         * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
         * Observer represented by the given arguments.
         */
        Subscriber.create = function (next, error, complete) {
            var subscriber = new Subscriber(next, error, complete);
            subscriber.syncErrorThrowable = false;
            return subscriber;
        };
        /**
         * The {@link Observer} callback to receive notifications of type `next` from
         * the Observable, with a value. The Observable may call this method 0 or more
         * times.
         * @param {T} [value] The `next` value.
         * @return {void}
         */
        Subscriber.prototype.next = function (value) {
            if (!this.isStopped) {
                this._next(value);
            }
        };
        /**
         * The {@link Observer} callback to receive notifications of type `error` from
         * the Observable, with an attached {@link Error}. Notifies the Observer that
         * the Observable has experienced an error condition.
         * @param {any} [err] The `error` exception.
         * @return {void}
         */
        Subscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this._error(err);
            }
        };
        /**
         * The {@link Observer} callback to receive a valueless notification of type
         * `complete` from the Observable. Notifies the Observer that the Observable
         * has finished sending push-based notifications.
         * @return {void}
         */
        Subscriber.prototype.complete = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            this.destination.error(err);
            this.unsubscribe();
        };
        Subscriber.prototype._complete = function () {
            this.destination.complete();
            this.unsubscribe();
        };
        Subscriber.prototype._unsubscribeAndRecycle = function () {
            var _a = this,
                _parent = _a._parent,
                _parents = _a._parents;
            this._parent = null;
            this._parents = null;
            this.unsubscribe();
            this.closed = false;
            this.isStopped = false;
            this._parent = _parent;
            this._parents = _parents;
            return this;
        };
        return Subscriber;
    }(Subscription_1.Subscription);
    exports.Subscriber = Subscriber;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SafeSubscriber = function (_super) {
        __extends(SafeSubscriber, _super);
        function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
            _super.call(this);
            this._parentSubscriber = _parentSubscriber;
            var next;
            var context = this;
            if (isFunction_1.isFunction(observerOrNext)) {
                next = observerOrNext;
            } else if (observerOrNext) {
                next = observerOrNext.next;
                error = observerOrNext.error;
                complete = observerOrNext.complete;
                if (observerOrNext !== Observer_1.empty) {
                    context = Object.create(observerOrNext);
                    if (isFunction_1.isFunction(context.unsubscribe)) {
                        this.add(context.unsubscribe.bind(context));
                    }
                    context.unsubscribe = this.unsubscribe.bind(this);
                }
            }
            this._context = context;
            this._next = next;
            this._error = error;
            this._complete = complete;
        }
        SafeSubscriber.prototype.next = function (value) {
            if (!this.isStopped && this._next) {
                var _parentSubscriber = this._parentSubscriber;
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._next, value);
                } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                if (this._error) {
                    if (!_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(this._error, err);
                        this.unsubscribe();
                    } else {
                        this.__tryOrSetError(_parentSubscriber, this._error, err);
                        this.unsubscribe();
                    }
                } else if (!_parentSubscriber.syncErrorThrowable) {
                    this.unsubscribe();
                    throw err;
                } else {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.complete = function () {
            var _this = this;
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                if (this._complete) {
                    var wrappedComplete = function () {
                        return _this._complete.call(_this._context);
                    };
                    if (!_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(wrappedComplete);
                        this.unsubscribe();
                    } else {
                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                        this.unsubscribe();
                    }
                } else {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
            try {
                fn.call(this._context, value);
            } catch (err) {
                this.unsubscribe();
                throw err;
            }
        };
        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
            try {
                fn.call(this._context, value);
            } catch (err) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            return false;
        };
        SafeSubscriber.prototype._unsubscribe = function () {
            var _parentSubscriber = this._parentSubscriber;
            this._context = null;
            this._parentSubscriber = null;
            _parentSubscriber.unsubscribe();
        };
        return SafeSubscriber;
    }(Subscriber);
    
});
System.registerDynamic('node_modules/rxjs/util/ObjectUnsubscribedError.js', [], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An error thrown when an action is invalid because the object has been
     * unsubscribed.
     *
     * @see {@link Subject}
     * @see {@link BehaviorSubject}
     *
     * @class ObjectUnsubscribedError
     */
    var ObjectUnsubscribedError = function (_super) {
        __extends(ObjectUnsubscribedError, _super);
        function ObjectUnsubscribedError() {
            var err = _super.call(this, 'object unsubscribed');
            this.name = err.name = 'ObjectUnsubscribedError';
            this.stack = err.stack;
            this.message = err.message;
        }
        return ObjectUnsubscribedError;
    }(Error);
    exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
    
});
System.registerDynamic("node_modules/rxjs/util/isArray.js", [], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  exports.isArray = Array.isArray || function (x) {
    return x && typeof x.length === 'number';
  };
  
});
System.registerDynamic("node_modules/rxjs/util/isObject.js", [], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    function isObject(x) {
        return x != null && typeof x === 'object';
    }
    exports.isObject = isObject;
    
});
System.registerDynamic("node_modules/rxjs/util/isFunction.js", [], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    function isFunction(x) {
        return typeof x === 'function';
    }
    exports.isFunction = isFunction;
    
});
System.registerDynamic("node_modules/rxjs/util/tryCatch.js", ["node_modules/rxjs/util/errorObject.js"], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var errorObject_1 = $__require("node_modules/rxjs/util/errorObject.js");
    var tryCatchTarget;
    function tryCatcher() {
        try {
            return tryCatchTarget.apply(this, arguments);
        } catch (e) {
            errorObject_1.errorObject.e = e;
            return errorObject_1.errorObject;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }
    exports.tryCatch = tryCatch;
    ;
    
});
System.registerDynamic("node_modules/rxjs/util/errorObject.js", [], true, function ($__require, exports, module) {
  "use strict";
  // typeof any so that it we don't have to cast when comparing a result to the error object

  var global = this || self,
      GLOBAL = global;
  exports.errorObject = { e: {} };
  
});
System.registerDynamic("node_modules/rxjs/util/UnsubscriptionError.js", [], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An error thrown when one or more errors have occurred during the
     * `unsubscribe` of a {@link Subscription}.
     */
    var UnsubscriptionError = function (_super) {
        __extends(UnsubscriptionError, _super);
        function UnsubscriptionError(errors) {
            _super.call(this);
            this.errors = errors;
            var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
                return i + 1 + ") " + err.toString();
            }).join('\n  ') : '');
            this.name = err.name = 'UnsubscriptionError';
            this.stack = err.stack;
            this.message = err.message;
        }
        return UnsubscriptionError;
    }(Error);
    exports.UnsubscriptionError = UnsubscriptionError;
    
});
System.registerDynamic('node_modules/rxjs/Subscription.js', ['node_modules/rxjs/util/isArray.js', 'node_modules/rxjs/util/isObject.js', 'node_modules/rxjs/util/isFunction.js', 'node_modules/rxjs/util/tryCatch.js', 'node_modules/rxjs/util/errorObject.js', 'node_modules/rxjs/util/UnsubscriptionError.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var isArray_1 = $__require('node_modules/rxjs/util/isArray.js');
    var isObject_1 = $__require('node_modules/rxjs/util/isObject.js');
    var isFunction_1 = $__require('node_modules/rxjs/util/isFunction.js');
    var tryCatch_1 = $__require('node_modules/rxjs/util/tryCatch.js');
    var errorObject_1 = $__require('node_modules/rxjs/util/errorObject.js');
    var UnsubscriptionError_1 = $__require('node_modules/rxjs/util/UnsubscriptionError.js');
    /**
     * Represents a disposable resource, such as the execution of an Observable. A
     * Subscription has one important method, `unsubscribe`, that takes no argument
     * and just disposes the resource held by the subscription.
     *
     * Additionally, subscriptions may be grouped together through the `add()`
     * method, which will attach a child Subscription to the current Subscription.
     * When a Subscription is unsubscribed, all its children (and its grandchildren)
     * will be unsubscribed as well.
     *
     * @class Subscription
     */
    var Subscription = function () {
        /**
         * @param {function(): void} [unsubscribe] A function describing how to
         * perform the disposal of resources when the `unsubscribe` method is called.
         */
        function Subscription(unsubscribe) {
            /**
             * A flag to indicate whether this Subscription has already been unsubscribed.
             * @type {boolean}
             */
            this.closed = false;
            this._parent = null;
            this._parents = null;
            this._subscriptions = null;
            if (unsubscribe) {
                this._unsubscribe = unsubscribe;
            }
        }
        /**
         * Disposes the resources held by the subscription. May, for instance, cancel
         * an ongoing Observable execution or cancel any other type of work that
         * started when the Subscription was created.
         * @return {void}
         */
        Subscription.prototype.unsubscribe = function () {
            var hasErrors = false;
            var errors;
            if (this.closed) {
                return;
            }
            var _a = this,
                _parent = _a._parent,
                _parents = _a._parents,
                _unsubscribe = _a._unsubscribe,
                _subscriptions = _a._subscriptions;
            this.closed = true;
            this._parent = null;
            this._parents = null;
            // null out _subscriptions first so any child subscriptions that attempt
            // to remove themselves from this subscription will noop
            this._subscriptions = null;
            var index = -1;
            var len = _parents ? _parents.length : 0;
            // if this._parent is null, then so is this._parents, and we
            // don't have to remove ourselves from any parent subscriptions.
            while (_parent) {
                _parent.remove(this);
                // if this._parents is null or index >= len,
                // then _parent is set to null, and the loop exits
                _parent = ++index < len && _parents[index] || null;
            }
            if (isFunction_1.isFunction(_unsubscribe)) {
                var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
                if (trial === errorObject_1.errorObject) {
                    hasErrors = true;
                    errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
                }
            }
            if (isArray_1.isArray(_subscriptions)) {
                index = -1;
                len = _subscriptions.length;
                while (++index < len) {
                    var sub = _subscriptions[index];
                    if (isObject_1.isObject(sub)) {
                        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                        if (trial === errorObject_1.errorObject) {
                            hasErrors = true;
                            errors = errors || [];
                            var err = errorObject_1.errorObject.e;
                            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                                errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                            } else {
                                errors.push(err);
                            }
                        }
                    }
                }
            }
            if (hasErrors) {
                throw new UnsubscriptionError_1.UnsubscriptionError(errors);
            }
        };
        /**
         * Adds a tear down to be called during the unsubscribe() of this
         * Subscription.
         *
         * If the tear down being added is a subscription that is already
         * unsubscribed, is the same reference `add` is being called on, or is
         * `Subscription.EMPTY`, it will not be added.
         *
         * If this subscription is already in an `closed` state, the passed
         * tear down logic will be executed immediately.
         *
         * @param {TeardownLogic} teardown The additional logic to execute on
         * teardown.
         * @return {Subscription} Returns the Subscription used or created to be
         * added to the inner subscriptions list. This Subscription can be used with
         * `remove()` to remove the passed teardown logic from the inner subscriptions
         * list.
         */
        Subscription.prototype.add = function (teardown) {
            if (!teardown || teardown === Subscription.EMPTY) {
                return Subscription.EMPTY;
            }
            if (teardown === this) {
                return this;
            }
            var subscription = teardown;
            switch (typeof teardown) {
                case 'function':
                    subscription = new Subscription(teardown);
                case 'object':
                    if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                        return subscription;
                    } else if (this.closed) {
                        subscription.unsubscribe();
                        return subscription;
                    } else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                            var tmp = subscription;
                            subscription = new Subscription();
                            subscription._subscriptions = [tmp];
                        }
                    break;
                default:
                    throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
            var subscriptions = this._subscriptions || (this._subscriptions = []);
            subscriptions.push(subscription);
            subscription._addParent(this);
            return subscription;
        };
        /**
         * Removes a Subscription from the internal list of subscriptions that will
         * unsubscribe during the unsubscribe process of this Subscription.
         * @param {Subscription} subscription The subscription to remove.
         * @return {void}
         */
        Subscription.prototype.remove = function (subscription) {
            var subscriptions = this._subscriptions;
            if (subscriptions) {
                var subscriptionIndex = subscriptions.indexOf(subscription);
                if (subscriptionIndex !== -1) {
                    subscriptions.splice(subscriptionIndex, 1);
                }
            }
        };
        Subscription.prototype._addParent = function (parent) {
            var _a = this,
                _parent = _a._parent,
                _parents = _a._parents;
            if (!_parent || _parent === parent) {
                // If we don't have a parent, or the new parent is the same as the
                // current parent, then set this._parent to the new parent.
                this._parent = parent;
            } else if (!_parents) {
                // If there's already one parent, but not multiple, allocate an Array to
                // store the rest of the parent Subscriptions.
                this._parents = [parent];
            } else if (_parents.indexOf(parent) === -1) {
                // Only add the new parent to the _parents list if it's not already there.
                _parents.push(parent);
            }
        };
        Subscription.EMPTY = function (empty) {
            empty.closed = true;
            return empty;
        }(new Subscription());
        return Subscription;
    }();
    exports.Subscription = Subscription;
    function flattenUnsubscriptionErrors(errors) {
        return errors.reduce(function (errs, err) {
            return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
        }, []);
    }
    
});
System.registerDynamic("node_modules/rxjs/SubjectSubscription.js", ["node_modules/rxjs/Subscription.js"], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscription_1 = $__require("node_modules/rxjs/Subscription.js");
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SubjectSubscription = function (_super) {
        __extends(SubjectSubscription, _super);
        function SubjectSubscription(subject, subscriber) {
            _super.call(this);
            this.subject = subject;
            this.subscriber = subscriber;
            this.closed = false;
        }
        SubjectSubscription.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.closed = true;
            var subject = this.subject;
            var observers = subject.observers;
            this.subject = null;
            if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
                return;
            }
            var subscriberIndex = observers.indexOf(this.subscriber);
            if (subscriberIndex !== -1) {
                observers.splice(subscriberIndex, 1);
            }
        };
        return SubjectSubscription;
    }(Subscription_1.Subscription);
    exports.SubjectSubscription = SubjectSubscription;
    
});
System.registerDynamic('node_modules/rxjs/util/root.js', [], true, function ($__require, exports, module) {
    "use strict";
    // CommonJS / Node have global context exposed as "global" variable.
    // We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
    // the global "global" var for now.

    var global = this || self,
        GLOBAL = global;
    var __window = typeof window !== 'undefined' && window;
    var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;
    var __global = typeof global !== 'undefined' && global;
    var _root = __window || __global || __self;
    exports.root = _root;
    // Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
    // This is needed when used with angular/tsickle which inserts a goog.module statement.
    // Wrap in IIFE
    (function () {
        if (!_root) {
            throw new Error('RxJS could not find any global context (window, self, global)');
        }
    })();
    
});
System.registerDynamic('node_modules/rxjs/symbol/rxSubscriber.js', ['node_modules/rxjs/util/root.js'], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var root_1 = $__require('node_modules/rxjs/util/root.js');
  var Symbol = root_1.root.Symbol;
  exports.rxSubscriber = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('rxSubscriber') : '@@rxSubscriber';
  /**
   * @deprecated use rxSubscriber instead
   */
  exports.$$rxSubscriber = exports.rxSubscriber;
  
});
System.registerDynamic('node_modules/rxjs/Subject.js', ['node_modules/rxjs/Observable.js', 'node_modules/rxjs/Subscriber.js', 'node_modules/rxjs/Subscription.js', 'node_modules/rxjs/util/ObjectUnsubscribedError.js', 'node_modules/rxjs/SubjectSubscription.js', 'node_modules/rxjs/symbol/rxSubscriber.js'], true, function ($__require, exports, module) {
    "use strict";

    var global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Observable_1 = $__require('node_modules/rxjs/Observable.js');
    var Subscriber_1 = $__require('node_modules/rxjs/Subscriber.js');
    var Subscription_1 = $__require('node_modules/rxjs/Subscription.js');
    var ObjectUnsubscribedError_1 = $__require('node_modules/rxjs/util/ObjectUnsubscribedError.js');
    var SubjectSubscription_1 = $__require('node_modules/rxjs/SubjectSubscription.js');
    var rxSubscriber_1 = $__require('node_modules/rxjs/symbol/rxSubscriber.js');
    /**
     * @class SubjectSubscriber<T>
     */
    var SubjectSubscriber = function (_super) {
        __extends(SubjectSubscriber, _super);
        function SubjectSubscriber(destination) {
            _super.call(this, destination);
            this.destination = destination;
        }
        return SubjectSubscriber;
    }(Subscriber_1.Subscriber);
    exports.SubjectSubscriber = SubjectSubscriber;
    /**
     * @class Subject<T>
     */
    var Subject = function (_super) {
        __extends(Subject, _super);
        function Subject() {
            _super.call(this);
            this.observers = [];
            this.closed = false;
            this.isStopped = false;
            this.hasError = false;
            this.thrownError = null;
        }
        Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
            return new SubjectSubscriber(this);
        };
        Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype.next = function (value) {
            if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            if (!this.isStopped) {
                var observers = this.observers;
                var len = observers.length;
                var copy = observers.slice();
                for (var i = 0; i < len; i++) {
                    copy[i].next(value);
                }
            }
        };
        Subject.prototype.error = function (err) {
            if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            this.hasError = true;
            this.thrownError = err;
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].error(err);
            }
            this.observers.length = 0;
        };
        Subject.prototype.complete = function () {
            if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].complete();
            }
            this.observers.length = 0;
        };
        Subject.prototype.unsubscribe = function () {
            this.isStopped = true;
            this.closed = true;
            this.observers = null;
        };
        Subject.prototype._trySubscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            } else {
                return _super.prototype._trySubscribe.call(this, subscriber);
            }
        };
        Subject.prototype._subscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            } else if (this.hasError) {
                subscriber.error(this.thrownError);
                return Subscription_1.Subscription.EMPTY;
            } else if (this.isStopped) {
                subscriber.complete();
                return Subscription_1.Subscription.EMPTY;
            } else {
                this.observers.push(subscriber);
                return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
            }
        };
        Subject.prototype.asObservable = function () {
            var observable = new Observable_1.Observable();
            observable.source = this;
            return observable;
        };
        Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable_1.Observable);
    exports.Subject = Subject;
    /**
     * @class AnonymousSubject<T>
     */
    var AnonymousSubject = function (_super) {
        __extends(AnonymousSubject, _super);
        function AnonymousSubject(destination, source) {
            _super.call(this);
            this.destination = destination;
            this.source = source;
        }
        AnonymousSubject.prototype.next = function (value) {
            var destination = this.destination;
            if (destination && destination.next) {
                destination.next(value);
            }
        };
        AnonymousSubject.prototype.error = function (err) {
            var destination = this.destination;
            if (destination && destination.error) {
                this.destination.error(err);
            }
        };
        AnonymousSubject.prototype.complete = function () {
            var destination = this.destination;
            if (destination && destination.complete) {
                this.destination.complete();
            }
        };
        AnonymousSubject.prototype._subscribe = function (subscriber) {
            var source = this.source;
            if (source) {
                return this.source.subscribe(subscriber);
            } else {
                return Subscription_1.Subscription.EMPTY;
            }
        };
        return AnonymousSubject;
    }(Subject);
    exports.AnonymousSubject = AnonymousSubject;
    
});
(function() {
var define = System.amdDefine;
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs/Observable'), require('rxjs/observable/merge'), require('rxjs/operator/share'), require('rxjs/Subject')) : typeof define === 'function' && define.amd ? define("node_modules/@angular/core/bundles/core.umd.js", ["exports", "node_modules/rxjs/Observable.js", "node_modules/rxjs/observable/merge.js", "node_modules/rxjs/operator/share.js", "node_modules/rxjs/Subject.js"], factory) : (factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}), global.Rx, global.Rx.Observable, global.Rx.Observable.prototype, global.Rx));
}(this, (function(exports, rxjs_Observable, rxjs_observable_merge, rxjs_operator_share, rxjs_Subject) {
  'use strict';
  var extendStatics = Object.setPrototypeOf || ({__proto__: []} instanceof Array && function(d, b) {
    d.__proto__ = b;
  }) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
  };
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var OpaqueToken = (function() {
    function OpaqueToken(_desc) {
      this._desc = _desc;
    }
    OpaqueToken.prototype.toString = function() {
      return "Token " + this._desc;
    };
    return OpaqueToken;
  }());
  var InjectionToken = (function(_super) {
    __extends(InjectionToken, _super);
    function InjectionToken(desc) {
      return _super.call(this, desc) || this;
    }
    InjectionToken.prototype.toString = function() {
      return "InjectionToken " + this._desc;
    };
    return InjectionToken;
  }(OpaqueToken));
  var __window = typeof window !== 'undefined' && window;
  var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;
  var __global = typeof global !== 'undefined' && global;
  var _global = __window || __global || __self;
  var _symbolIterator = null;
  function getSymbolIterator() {
    if (!_symbolIterator) {
      var Symbol = _global['Symbol'];
      if (Symbol && Symbol.iterator) {
        _symbolIterator = Symbol.iterator;
      } else {
        var keys = Object.getOwnPropertyNames(Map.prototype);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (key !== 'entries' && key !== 'size' && ((Map)).prototype[key] === Map.prototype['entries']) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
  }
  function looseIdentical(a, b) {
    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
  }
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token == null) {
      return '' + token;
    }
    if (token.overriddenName) {
      return "" + token.overriddenName;
    }
    if (token.name) {
      return "" + token.name;
    }
    var res = token.toString();
    if (res == null) {
      return '' + res;
    }
    var newLineIndex = res.indexOf('\n');
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
  }
  var _nextClassId = 0;
  var Reflect$1 = _global['Reflect'];
  function extractAnnotation(annotation) {
    if (typeof annotation === 'function' && annotation.hasOwnProperty('annotation')) {
      annotation = annotation.annotation;
    }
    return annotation;
  }
  function applyParams(fnOrArray, key) {
    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function || fnOrArray === Number || fnOrArray === Array) {
      throw new Error("Can not use native " + stringify(fnOrArray) + " as constructor");
    }
    if (typeof fnOrArray === 'function') {
      return fnOrArray;
    }
    if (Array.isArray(fnOrArray)) {
      var annotations = (fnOrArray);
      var annoLength = annotations.length - 1;
      var fn = fnOrArray[annoLength];
      if (typeof fn !== 'function') {
        throw new Error("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'");
      }
      if (annoLength != fn.length) {
        throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn));
      }
      var paramsAnnotations = [];
      for (var i = 0,
          ii = annotations.length - 1; i < ii; i++) {
        var paramAnnotations = [];
        paramsAnnotations.push(paramAnnotations);
        var annotation = annotations[i];
        if (Array.isArray(annotation)) {
          for (var j = 0; j < annotation.length; j++) {
            paramAnnotations.push(extractAnnotation(annotation[j]));
          }
        } else if (typeof annotation === 'function') {
          paramAnnotations.push(extractAnnotation(annotation));
        } else {
          paramAnnotations.push(annotation);
        }
      }
      Reflect$1.defineMetadata('parameters', paramsAnnotations, fn);
      return fn;
    }
    throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'");
  }
  function Class(clsDef) {
    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
    var proto = constructor.prototype;
    if (clsDef.hasOwnProperty('extends')) {
      if (typeof clsDef.extends === 'function') {
        ((constructor)).prototype = proto = Object.create(((clsDef.extends)).prototype);
      } else {
        throw new Error("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends));
      }
    }
    for (var key in clsDef) {
      if (key !== 'extends' && key !== 'prototype' && clsDef.hasOwnProperty(key)) {
        proto[key] = applyParams(clsDef[key], key);
      }
    }
    if (this && this.annotations instanceof Array) {
      Reflect$1.defineMetadata('annotations', this.annotations, constructor);
    }
    var constructorName = constructor['name'];
    if (!constructorName || constructorName === 'constructor') {
      ((constructor))['overriddenName'] = "class" + _nextClassId++;
    }
    return (constructor);
  }
  function makeDecorator(name, props, parentClass, chainFn) {
    var metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(objOrType) {
      if (!(Reflect$1 && Reflect$1.getOwnMetadata)) {
        throw 'reflect-metadata shim is required when using class decorators';
      }
      if (this instanceof DecoratorFactory) {
        metaCtor.call(this, objOrType);
        return this;
      }
      var annotationInstance = new ((DecoratorFactory))(objOrType);
      var chainAnnotation = typeof this === 'function' && Array.isArray(this.annotations) ? this.annotations : [];
      chainAnnotation.push(annotationInstance);
      var TypeDecorator = (function TypeDecorator(cls) {
        var annotations = Reflect$1.getOwnMetadata('annotations', cls) || [];
        annotations.push(annotationInstance);
        Reflect$1.defineMetadata('annotations', annotations, cls);
        return cls;
      });
      TypeDecorator.annotations = chainAnnotation;
      TypeDecorator.Class = Class;
      if (chainFn)
        chainFn(TypeDecorator);
      return TypeDecorator;
    }
    if (parentClass) {
      DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.toString = function() {
      return "@" + name;
    };
    ((DecoratorFactory)).annotationCls = DecoratorFactory;
    return DecoratorFactory;
  }
  function makeMetadataCtor(props) {
    return function ctor() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (props) {
        var values = props.apply(void 0, args);
        for (var propName in values) {
          this[propName] = values[propName];
        }
      }
    };
  }
  function makeParamDecorator(name, props, parentClass) {
    var metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this instanceof ParamDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      var annotationInstance = new (((ParamDecoratorFactory)).bind.apply(((ParamDecoratorFactory)), [void 0].concat(args)))();
      ((ParamDecorator)).annotation = annotationInstance;
      return ParamDecorator;
      function ParamDecorator(cls, unusedKey, index) {
        var parameters = Reflect$1.getOwnMetadata('parameters', cls) || [];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        parameters[index] = parameters[index] || [];
        ((parameters[index])).push(annotationInstance);
        Reflect$1.defineMetadata('parameters', parameters, cls);
        return cls;
      }
    }
    if (parentClass) {
      ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    ParamDecoratorFactory.prototype.toString = function() {
      return "@" + name;
    };
    ((ParamDecoratorFactory)).annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
  }
  function makePropDecorator(name, props, parentClass) {
    var metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this instanceof PropDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      var decoratorInstance = new (((PropDecoratorFactory)).bind.apply(((PropDecoratorFactory)), [void 0].concat(args)))();
      return function PropDecorator(target, name) {
        var meta = Reflect$1.getOwnMetadata('propMetadata', target.constructor) || {};
        meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
        meta[name].unshift(decoratorInstance);
        Reflect$1.defineMetadata('propMetadata', meta, target.constructor);
      };
    }
    if (parentClass) {
      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.toString = function() {
      return "@" + name;
    };
    ((PropDecoratorFactory)).annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
  }
  var ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken('AnalyzeForEntryComponents');
  var Attribute = makeParamDecorator('Attribute', function(attributeName) {
    return ({attributeName: attributeName});
  });
  var Query = (function() {
    function Query() {}
    return Query;
  }());
  var ContentChildren = makePropDecorator('ContentChildren', function(selector, data) {
    if (data === void 0) {
      data = {};
    }
    return (Object.assign({
      selector: selector,
      first: false,
      isViewQuery: false,
      descendants: false
    }, data));
  }, Query);
  var ContentChild = makePropDecorator('ContentChild', function(selector, data) {
    if (data === void 0) {
      data = {};
    }
    return (Object.assign({
      selector: selector,
      first: true,
      isViewQuery: false,
      descendants: true
    }, data));
  }, Query);
  var ViewChildren = makePropDecorator('ViewChildren', function(selector, data) {
    if (data === void 0) {
      data = {};
    }
    return (Object.assign({
      selector: selector,
      first: false,
      isViewQuery: true,
      descendants: true
    }, data));
  }, Query);
  var ViewChild = makePropDecorator('ViewChild', function(selector, data) {
    return (Object.assign({
      selector: selector,
      first: true,
      isViewQuery: true,
      descendants: true
    }, data));
  }, Query);
  var ChangeDetectionStrategy = {};
  ChangeDetectionStrategy.OnPush = 0;
  ChangeDetectionStrategy.Default = 1;
  ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush] = "OnPush";
  ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = "Default";
  var ChangeDetectorStatus = {};
  ChangeDetectorStatus.CheckOnce = 0;
  ChangeDetectorStatus.Checked = 1;
  ChangeDetectorStatus.CheckAlways = 2;
  ChangeDetectorStatus.Detached = 3;
  ChangeDetectorStatus.Errored = 4;
  ChangeDetectorStatus.Destroyed = 5;
  ChangeDetectorStatus[ChangeDetectorStatus.CheckOnce] = "CheckOnce";
  ChangeDetectorStatus[ChangeDetectorStatus.Checked] = "Checked";
  ChangeDetectorStatus[ChangeDetectorStatus.CheckAlways] = "CheckAlways";
  ChangeDetectorStatus[ChangeDetectorStatus.Detached] = "Detached";
  ChangeDetectorStatus[ChangeDetectorStatus.Errored] = "Errored";
  ChangeDetectorStatus[ChangeDetectorStatus.Destroyed] = "Destroyed";
  function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
    return changeDetectionStrategy == null || changeDetectionStrategy === ChangeDetectionStrategy.Default;
  }
  var Directive = makeDecorator('Directive', function(dir) {
    if (dir === void 0) {
      dir = {};
    }
    return dir;
  });
  var Component = makeDecorator('Component', function(c) {
    if (c === void 0) {
      c = {};
    }
    return (Object.assign({changeDetection: ChangeDetectionStrategy.Default}, c));
  }, Directive);
  var Pipe = makeDecorator('Pipe', function(p) {
    return (Object.assign({pure: true}, p));
  });
  var Input = makePropDecorator('Input', function(bindingPropertyName) {
    return ({bindingPropertyName: bindingPropertyName});
  });
  var Output = makePropDecorator('Output', function(bindingPropertyName) {
    return ({bindingPropertyName: bindingPropertyName});
  });
  var HostBinding = makePropDecorator('HostBinding', function(hostPropertyName) {
    return ({hostPropertyName: hostPropertyName});
  });
  var HostListener = makePropDecorator('HostListener', function(eventName, args) {
    return ({
      eventName: eventName,
      args: args
    });
  });
  var CUSTOM_ELEMENTS_SCHEMA = {name: 'custom-elements'};
  var NO_ERRORS_SCHEMA = {name: 'no-errors-schema'};
  var NgModule = makeDecorator('NgModule', function(ngModule) {
    return ngModule;
  });
  var ViewEncapsulation = {};
  ViewEncapsulation.Emulated = 0;
  ViewEncapsulation.Native = 1;
  ViewEncapsulation.None = 2;
  ViewEncapsulation[ViewEncapsulation.Emulated] = "Emulated";
  ViewEncapsulation[ViewEncapsulation.Native] = "Native";
  ViewEncapsulation[ViewEncapsulation.None] = "None";
  var ViewMetadata = (function() {
    function ViewMetadata(opts) {
      if (opts === void 0) {
        opts = {};
      }
      this.templateUrl = opts.templateUrl;
      this.template = opts.template;
      this.styleUrls = opts.styleUrls;
      this.styles = opts.styles;
      this.encapsulation = opts.encapsulation;
      this.animations = opts.animations;
      this.interpolation = opts.interpolation;
    }
    return ViewMetadata;
  }());
  var Version = (function() {
    function Version(full) {
      this.full = full;
    }
    Object.defineProperty(Version.prototype, "major", {
      get: function() {
        return this.full.split('.')[0];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Version.prototype, "minor", {
      get: function() {
        return this.full.split('.')[1];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Version.prototype, "patch", {
      get: function() {
        return this.full.split('.').slice(2).join('.');
      },
      enumerable: true,
      configurable: true
    });
    return Version;
  }());
  var VERSION = new Version('4.3.4');
  var Inject = makeParamDecorator('Inject', function(token) {
    return ({token: token});
  });
  var Optional = makeParamDecorator('Optional');
  var Injectable = makeDecorator('Injectable');
  var Self = makeParamDecorator('Self');
  var SkipSelf = makeParamDecorator('SkipSelf');
  var Host = makeParamDecorator('Host');
  function forwardRef(forwardRefFn) {
    ((forwardRefFn)).__forward_ref__ = forwardRef;
    ((forwardRefFn)).toString = function() {
      return stringify(this());
    };
    return (((forwardRefFn)));
  }
  function resolveForwardRef(type) {
    if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') && type.__forward_ref__ === forwardRef) {
      return ((type))();
    } else {
      return type;
    }
  }
  var _THROW_IF_NOT_FOUND = new Object();
  var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
  var _NullInjector = (function() {
    function _NullInjector() {}
    _NullInjector.prototype.get = function(token, notFoundValue) {
      if (notFoundValue === void 0) {
        notFoundValue = _THROW_IF_NOT_FOUND;
      }
      if (notFoundValue === _THROW_IF_NOT_FOUND) {
        throw new Error("No provider for " + stringify(token) + "!");
      }
      return notFoundValue;
    };
    return _NullInjector;
  }());
  var Injector = (function() {
    function Injector() {}
    Injector.prototype.get = function(token, notFoundValue) {};
    Injector.prototype.get = function(token, notFoundValue) {};
    return Injector;
  }());
  Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
  Injector.NULL = new _NullInjector();
  var ERROR_COMPONENT_TYPE = 'ngComponentType';
  var ERROR_DEBUG_CONTEXT = 'ngDebugContext';
  var ERROR_ORIGINAL_ERROR = 'ngOriginalError';
  var ERROR_LOGGER = 'ngErrorLogger';
  function getDebugContext(error) {
    return ((error))[ERROR_DEBUG_CONTEXT];
  }
  function getOriginalError(error) {
    return ((error))[ERROR_ORIGINAL_ERROR];
  }
  function getErrorLogger(error) {
    return ((error))[ERROR_LOGGER] || defaultErrorLogger;
  }
  function defaultErrorLogger(console) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      values[_i - 1] = arguments[_i];
    }
    console.error.apply(console, values);
  }
  var ErrorHandler = (function() {
    function ErrorHandler(deprecatedParameter) {
      this._console = console;
    }
    ErrorHandler.prototype.handleError = function(error) {
      var originalError = this._findOriginalError(error);
      var context = this._findContext(error);
      var errorLogger = getErrorLogger(error);
      errorLogger(this._console, "ERROR", error);
      if (originalError) {
        errorLogger(this._console, "ORIGINAL ERROR", originalError);
      }
      if (context) {
        errorLogger(this._console, 'ERROR CONTEXT', context);
      }
    };
    ErrorHandler.prototype._findContext = function(error) {
      if (error) {
        return getDebugContext(error) ? getDebugContext(error) : this._findContext(getOriginalError(error));
      }
      return null;
    };
    ErrorHandler.prototype._findOriginalError = function(error) {
      var e = getOriginalError(error);
      while (e && getOriginalError(e)) {
        e = getOriginalError(e);
      }
      return e;
    };
    return ErrorHandler;
  }());
  function wrappedError(message, originalError) {
    var msg = message + " caused by: " + (originalError instanceof Error ? originalError.message : originalError);
    var error = Error(msg);
    ((error))[ERROR_ORIGINAL_ERROR] = originalError;
    return error;
  }
  function findFirstClosedCycle(keys) {
    var res = [];
    for (var i = 0; i < keys.length; ++i) {
      if (res.indexOf(keys[i]) > -1) {
        res.push(keys[i]);
        return res;
      }
      res.push(keys[i]);
    }
    return res;
  }
  function constructResolvingPath(keys) {
    if (keys.length > 1) {
      var reversed = findFirstClosedCycle(keys.slice().reverse());
      var tokenStrs = reversed.map(function(k) {
        return stringify(k.token);
      });
      return ' (' + tokenStrs.join(' -> ') + ')';
    }
    return '';
  }
  function injectionError(injector, key, constructResolvingMessage, originalError) {
    var keys = [key];
    var errMsg = constructResolvingMessage(keys);
    var error = ((originalError ? wrappedError(errMsg, originalError) : Error(errMsg)));
    error.addKey = addKey;
    error.keys = keys;
    error.injectors = [injector];
    error.constructResolvingMessage = constructResolvingMessage;
    ((error))[ERROR_ORIGINAL_ERROR] = originalError;
    return error;
  }
  function addKey(injector, key) {
    this.injectors.push(injector);
    this.keys.push(key);
    this.message = this.constructResolvingMessage(this.keys);
  }
  function noProviderError(injector, key) {
    return injectionError(injector, key, function(keys) {
      var first = stringify(keys[0].token);
      return "No provider for " + first + "!" + constructResolvingPath(keys);
    });
  }
  function cyclicDependencyError(injector, key) {
    return injectionError(injector, key, function(keys) {
      return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
    });
  }
  function instantiationError(injector, originalException, originalStack, key) {
    return injectionError(injector, key, function(keys) {
      var first = stringify(keys[0].token);
      return originalException.message + ": Error during instantiation of " + first + "!" + constructResolvingPath(keys) + ".";
    }, originalException);
  }
  function invalidProviderError(provider) {
    return Error("Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
  }
  function noAnnotationError(typeOrFunc, params) {
    var signature = [];
    for (var i = 0,
        ii = params.length; i < ii; i++) {
      var parameter = params[i];
      if (!parameter || parameter.length == 0) {
        signature.push('?');
      } else {
        signature.push(parameter.map(stringify).join(' '));
      }
    }
    return Error('Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' + signature.join(', ') + '). ' + 'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' + stringify(typeOrFunc) + '\' is decorated with Injectable.');
  }
  function outOfBoundsError(index) {
    return Error("Index " + index + " is out-of-bounds.");
  }
  function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
    return Error("Cannot mix multi providers and regular providers, got: " + provider1 + " " + provider2);
  }
  var ReflectiveKey = (function() {
    function ReflectiveKey(token, id) {
      this.token = token;
      this.id = id;
      if (!token) {
        throw new Error('Token must be defined!');
      }
    }
    Object.defineProperty(ReflectiveKey.prototype, "displayName", {
      get: function() {
        return stringify(this.token);
      },
      enumerable: true,
      configurable: true
    });
    ReflectiveKey.get = function(token) {
      return _globalKeyRegistry.get(resolveForwardRef(token));
    };
    Object.defineProperty(ReflectiveKey, "numberOfKeys", {
      get: function() {
        return _globalKeyRegistry.numberOfKeys;
      },
      enumerable: true,
      configurable: true
    });
    return ReflectiveKey;
  }());
  var KeyRegistry = (function() {
    function KeyRegistry() {
      this._allKeys = new Map();
    }
    KeyRegistry.prototype.get = function(token) {
      if (token instanceof ReflectiveKey)
        return token;
      if (this._allKeys.has(token)) {
        return ((this._allKeys.get(token)));
      }
      var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
      this._allKeys.set(token, newKey);
      return newKey;
    };
    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
      get: function() {
        return this._allKeys.size;
      },
      enumerable: true,
      configurable: true
    });
    return KeyRegistry;
  }());
  var _globalKeyRegistry = new KeyRegistry();
  var Type = Function;
  function isType(v) {
    return typeof v === 'function';
  }
  var DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*arguments\)/;
  var ReflectionCapabilities = (function() {
    function ReflectionCapabilities(reflect) {
      this._reflect = reflect || _global['Reflect'];
    }
    ReflectionCapabilities.prototype.isReflectionEnabled = function() {
      return true;
    };
    ReflectionCapabilities.prototype.factory = function(t) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return new (t.bind.apply(t, [void 0].concat(args)))();
      };
    };
    ReflectionCapabilities.prototype._zipTypesAndAnnotations = function(paramTypes, paramAnnotations) {
      var result;
      if (typeof paramTypes === 'undefined') {
        result = new Array(paramAnnotations.length);
      } else {
        result = new Array(paramTypes.length);
      }
      for (var i = 0; i < result.length; i++) {
        if (typeof paramTypes === 'undefined') {
          result[i] = [];
        } else if (paramTypes[i] != Object) {
          result[i] = [paramTypes[i]];
        } else {
          result[i] = [];
        }
        if (paramAnnotations && paramAnnotations[i] != null) {
          result[i] = result[i].concat(paramAnnotations[i]);
        }
      }
      return result;
    };
    ReflectionCapabilities.prototype._ownParameters = function(type, parentCtor) {
      if (DELEGATE_CTOR.exec(type.toString())) {
        return null;
      }
      if (((type)).parameters && ((type)).parameters !== parentCtor.parameters) {
        return ((type)).parameters;
      }
      var tsickleCtorParams = ((type)).ctorParameters;
      if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
        var ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
        var paramTypes = ctorParameters.map(function(ctorParam) {
          return ctorParam && ctorParam.type;
        });
        var paramAnnotations = ctorParameters.map(function(ctorParam) {
          return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
        });
        return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
      }
      if (this._reflect != null && this._reflect.getOwnMetadata != null) {
        var paramAnnotations = this._reflect.getOwnMetadata('parameters', type);
        var paramTypes = this._reflect.getOwnMetadata('design:paramtypes', type);
        if (paramTypes || paramAnnotations) {
          return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
        }
      }
      return new Array(((type.length))).fill(undefined);
    };
    ReflectionCapabilities.prototype.parameters = function(type) {
      if (!isType(type)) {
        return [];
      }
      var parentCtor = getParentCtor(type);
      var parameters = this._ownParameters(type, parentCtor);
      if (!parameters && parentCtor !== Object) {
        parameters = this.parameters(parentCtor);
      }
      return parameters || [];
    };
    ReflectionCapabilities.prototype._ownAnnotations = function(typeOrFunc, parentCtor) {
      if (((typeOrFunc)).annotations && ((typeOrFunc)).annotations !== parentCtor.annotations) {
        var annotations = ((typeOrFunc)).annotations;
        if (typeof annotations === 'function' && annotations.annotations) {
          annotations = annotations.annotations;
        }
        return annotations;
      }
      if (((typeOrFunc)).decorators && ((typeOrFunc)).decorators !== parentCtor.decorators) {
        return convertTsickleDecoratorIntoMetadata(((typeOrFunc)).decorators);
      }
      if (this._reflect && this._reflect.getOwnMetadata) {
        return this._reflect.getOwnMetadata('annotations', typeOrFunc);
      }
      return null;
    };
    ReflectionCapabilities.prototype.annotations = function(typeOrFunc) {
      if (!isType(typeOrFunc)) {
        return [];
      }
      var parentCtor = getParentCtor(typeOrFunc);
      var ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
      var parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
      return parentAnnotations.concat(ownAnnotations);
    };
    ReflectionCapabilities.prototype._ownPropMetadata = function(typeOrFunc, parentCtor) {
      if (((typeOrFunc)).propMetadata && ((typeOrFunc)).propMetadata !== parentCtor.propMetadata) {
        var propMetadata = ((typeOrFunc)).propMetadata;
        if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
          propMetadata = propMetadata.propMetadata;
        }
        return propMetadata;
      }
      if (((typeOrFunc)).propDecorators && ((typeOrFunc)).propDecorators !== parentCtor.propDecorators) {
        var propDecorators_1 = ((typeOrFunc)).propDecorators;
        var propMetadata_1 = ({});
        Object.keys(propDecorators_1).forEach(function(prop) {
          propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
        });
        return propMetadata_1;
      }
      if (this._reflect && this._reflect.getOwnMetadata) {
        return this._reflect.getOwnMetadata('propMetadata', typeOrFunc);
      }
      return null;
    };
    ReflectionCapabilities.prototype.propMetadata = function(typeOrFunc) {
      if (!isType(typeOrFunc)) {
        return {};
      }
      var parentCtor = getParentCtor(typeOrFunc);
      var propMetadata = {};
      if (parentCtor !== Object) {
        var parentPropMetadata_1 = this.propMetadata(parentCtor);
        Object.keys(parentPropMetadata_1).forEach(function(propName) {
          propMetadata[propName] = parentPropMetadata_1[propName];
        });
      }
      var ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
      if (ownPropMetadata) {
        Object.keys(ownPropMetadata).forEach(function(propName) {
          var decorators = [];
          if (propMetadata.hasOwnProperty(propName)) {
            decorators.push.apply(decorators, propMetadata[propName]);
          }
          decorators.push.apply(decorators, ownPropMetadata[propName]);
          propMetadata[propName] = decorators;
        });
      }
      return propMetadata;
    };
    ReflectionCapabilities.prototype.hasLifecycleHook = function(type, lcProperty) {
      return type instanceof Type && lcProperty in type.prototype;
    };
    ReflectionCapabilities.prototype.getter = function(name) {
      return (new Function('o', 'return o.' + name + ';'));
    };
    ReflectionCapabilities.prototype.setter = function(name) {
      return (new Function('o', 'v', 'return o.' + name + ' = v;'));
    };
    ReflectionCapabilities.prototype.method = function(name) {
      var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
      return (new Function('o', 'args', functionBody));
    };
    ReflectionCapabilities.prototype.importUri = function(type) {
      if (typeof type === 'object' && type['filePath']) {
        return type['filePath'];
      }
      return "./" + stringify(type);
    };
    ReflectionCapabilities.prototype.resourceUri = function(type) {
      return "./" + stringify(type);
    };
    ReflectionCapabilities.prototype.resolveIdentifier = function(name, moduleUrl, members, runtime) {
      return runtime;
    };
    ReflectionCapabilities.prototype.resolveEnum = function(enumIdentifier, name) {
      return enumIdentifier[name];
    };
    return ReflectionCapabilities;
  }());
  function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
    if (!decoratorInvocations) {
      return [];
    }
    return decoratorInvocations.map(function(decoratorInvocation) {
      var decoratorType = decoratorInvocation.type;
      var annotationCls = decoratorType.annotationCls;
      var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
      return new (annotationCls.bind.apply(annotationCls, [void 0].concat(annotationArgs)))();
    });
  }
  function getParentCtor(ctor) {
    var parentProto = Object.getPrototypeOf(ctor.prototype);
    var parentCtor = parentProto ? parentProto.constructor : null;
    return parentCtor || Object;
  }
  var Reflector = (function() {
    function Reflector(reflectionCapabilities) {
      this.reflectionCapabilities = reflectionCapabilities;
    }
    Reflector.prototype.updateCapabilities = function(caps) {
      this.reflectionCapabilities = caps;
    };
    Reflector.prototype.factory = function(type) {
      return this.reflectionCapabilities.factory(type);
    };
    Reflector.prototype.parameters = function(typeOrFunc) {
      return this.reflectionCapabilities.parameters(typeOrFunc);
    };
    Reflector.prototype.annotations = function(typeOrFunc) {
      return this.reflectionCapabilities.annotations(typeOrFunc);
    };
    Reflector.prototype.propMetadata = function(typeOrFunc) {
      return this.reflectionCapabilities.propMetadata(typeOrFunc);
    };
    Reflector.prototype.hasLifecycleHook = function(type, lcProperty) {
      return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
    };
    Reflector.prototype.getter = function(name) {
      return this.reflectionCapabilities.getter(name);
    };
    Reflector.prototype.setter = function(name) {
      return this.reflectionCapabilities.setter(name);
    };
    Reflector.prototype.method = function(name) {
      return this.reflectionCapabilities.method(name);
    };
    Reflector.prototype.importUri = function(type) {
      return this.reflectionCapabilities.importUri(type);
    };
    Reflector.prototype.resourceUri = function(type) {
      return this.reflectionCapabilities.resourceUri(type);
    };
    Reflector.prototype.resolveIdentifier = function(name, moduleUrl, members, runtime) {
      return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);
    };
    Reflector.prototype.resolveEnum = function(identifier, name) {
      return this.reflectionCapabilities.resolveEnum(identifier, name);
    };
    return Reflector;
  }());
  var reflector = new Reflector(new ReflectionCapabilities());
  var ReflectiveDependency = (function() {
    function ReflectiveDependency(key, optional, visibility) {
      this.key = key;
      this.optional = optional;
      this.visibility = visibility;
    }
    ReflectiveDependency.fromKey = function(key) {
      return new ReflectiveDependency(key, false, null);
    };
    return ReflectiveDependency;
  }());
  var _EMPTY_LIST = [];
  var ResolvedReflectiveProvider_ = (function() {
    function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
      this.key = key;
      this.resolvedFactories = resolvedFactories;
      this.multiProvider = multiProvider;
    }
    Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
      get: function() {
        return this.resolvedFactories[0];
      },
      enumerable: true,
      configurable: true
    });
    return ResolvedReflectiveProvider_;
  }());
  var ResolvedReflectiveFactory = (function() {
    function ResolvedReflectiveFactory(factory, dependencies) {
      this.factory = factory;
      this.dependencies = dependencies;
    }
    return ResolvedReflectiveFactory;
  }());
  function resolveReflectiveFactory(provider) {
    var factoryFn;
    var resolvedDeps;
    if (provider.useClass) {
      var useClass = resolveForwardRef(provider.useClass);
      factoryFn = reflector.factory(useClass);
      resolvedDeps = _dependenciesFor(useClass);
    } else if (provider.useExisting) {
      factoryFn = function(aliasInstance) {
        return aliasInstance;
      };
      resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
    } else if (provider.useFactory) {
      factoryFn = provider.useFactory;
      resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
    } else {
      factoryFn = function() {
        return provider.useValue;
      };
      resolvedDeps = _EMPTY_LIST;
    }
    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
  }
  function resolveReflectiveProvider(provider) {
    return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);
  }
  function resolveReflectiveProviders(providers) {
    var normalized = _normalizeProviders(providers, []);
    var resolved = normalized.map(resolveReflectiveProvider);
    var resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());
    return Array.from(resolvedProviderMap.values());
  }
  function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
    for (var i = 0; i < providers.length; i++) {
      var provider = providers[i];
      var existing = normalizedProvidersMap.get(provider.key.id);
      if (existing) {
        if (provider.multiProvider !== existing.multiProvider) {
          throw mixingMultiProvidersWithRegularProvidersError(existing, provider);
        }
        if (provider.multiProvider) {
          for (var j = 0; j < provider.resolvedFactories.length; j++) {
            existing.resolvedFactories.push(provider.resolvedFactories[j]);
          }
        } else {
          normalizedProvidersMap.set(provider.key.id, provider);
        }
      } else {
        var resolvedProvider = void 0;
        if (provider.multiProvider) {
          resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
        } else {
          resolvedProvider = provider;
        }
        normalizedProvidersMap.set(provider.key.id, resolvedProvider);
      }
    }
    return normalizedProvidersMap;
  }
  function _normalizeProviders(providers, res) {
    providers.forEach(function(b) {
      if (b instanceof Type) {
        res.push({
          provide: b,
          useClass: b
        });
      } else if (b && typeof b == 'object' && ((b)).provide !== undefined) {
        res.push((b));
      } else if (b instanceof Array) {
        _normalizeProviders(b, res);
      } else {
        throw invalidProviderError(b);
      }
    });
    return res;
  }
  function constructDependencies(typeOrFunc, dependencies) {
    if (!dependencies) {
      return _dependenciesFor(typeOrFunc);
    } else {
      var params_1 = dependencies.map(function(t) {
        return [t];
      });
      return dependencies.map(function(t) {
        return _extractToken(typeOrFunc, t, params_1);
      });
    }
  }
  function _dependenciesFor(typeOrFunc) {
    var params = reflector.parameters(typeOrFunc);
    if (!params)
      return [];
    if (params.some(function(p) {
      return p == null;
    })) {
      throw noAnnotationError(typeOrFunc, params);
    }
    return params.map(function(p) {
      return _extractToken(typeOrFunc, p, params);
    });
  }
  function _extractToken(typeOrFunc, metadata, params) {
    var token = null;
    var optional = false;
    if (!Array.isArray(metadata)) {
      if (metadata instanceof Inject) {
        return _createDependency(metadata.token, optional, null);
      } else {
        return _createDependency(metadata, optional, null);
      }
    }
    var visibility = null;
    for (var i = 0; i < metadata.length; ++i) {
      var paramMetadata = metadata[i];
      if (paramMetadata instanceof Type) {
        token = paramMetadata;
      } else if (paramMetadata instanceof Inject) {
        token = paramMetadata.token;
      } else if (paramMetadata instanceof Optional) {
        optional = true;
      } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {
        visibility = paramMetadata;
      } else if (paramMetadata instanceof InjectionToken) {
        token = paramMetadata;
      }
    }
    token = resolveForwardRef(token);
    if (token != null) {
      return _createDependency(token, optional, visibility);
    } else {
      throw noAnnotationError(typeOrFunc, params);
    }
  }
  function _createDependency(token, optional, visibility) {
    return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);
  }
  var UNDEFINED = new Object();
  var ReflectiveInjector = (function() {
    function ReflectiveInjector() {}
    ReflectiveInjector.resolve = function(providers) {
      return resolveReflectiveProviders(providers);
    };
    ReflectiveInjector.resolveAndCreate = function(providers, parent) {
      var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
    };
    ReflectiveInjector.fromResolvedProviders = function(providers, parent) {
      return new ReflectiveInjector_(providers, parent);
    };
    ReflectiveInjector.prototype.parent = function() {};
    ReflectiveInjector.prototype.resolveAndCreateChild = function(providers) {};
    ReflectiveInjector.prototype.createChildFromResolved = function(providers) {};
    ReflectiveInjector.prototype.resolveAndInstantiate = function(provider) {};
    ReflectiveInjector.prototype.instantiateResolved = function(provider) {};
    ReflectiveInjector.prototype.get = function(token, notFoundValue) {};
    return ReflectiveInjector;
  }());
  var ReflectiveInjector_ = (function() {
    function ReflectiveInjector_(_providers, _parent) {
      this._constructionCounter = 0;
      this._providers = _providers;
      this._parent = _parent || null;
      var len = _providers.length;
      this.keyIds = new Array(len);
      this.objs = new Array(len);
      for (var i = 0; i < len; i++) {
        this.keyIds[i] = _providers[i].key.id;
        this.objs[i] = UNDEFINED;
      }
    }
    ReflectiveInjector_.prototype.get = function(token, notFoundValue) {
      if (notFoundValue === void 0) {
        notFoundValue = THROW_IF_NOT_FOUND;
      }
      return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);
    };
    Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
      get: function() {
        return this._parent;
      },
      enumerable: true,
      configurable: true
    });
    ReflectiveInjector_.prototype.resolveAndCreateChild = function(providers) {
      var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return this.createChildFromResolved(ResolvedReflectiveProviders);
    };
    ReflectiveInjector_.prototype.createChildFromResolved = function(providers) {
      var inj = new ReflectiveInjector_(providers);
      inj._parent = this;
      return inj;
    };
    ReflectiveInjector_.prototype.resolveAndInstantiate = function(provider) {
      return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
    };
    ReflectiveInjector_.prototype.instantiateResolved = function(provider) {
      return this._instantiateProvider(provider);
    };
    ReflectiveInjector_.prototype.getProviderAtIndex = function(index) {
      if (index < 0 || index >= this._providers.length) {
        throw outOfBoundsError(index);
      }
      return this._providers[index];
    };
    ReflectiveInjector_.prototype._new = function(provider) {
      if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {
        throw cyclicDependencyError(this, provider.key);
      }
      return this._instantiateProvider(provider);
    };
    ReflectiveInjector_.prototype._getMaxNumberOfObjects = function() {
      return this.objs.length;
    };
    ReflectiveInjector_.prototype._instantiateProvider = function(provider) {
      if (provider.multiProvider) {
        var res = new Array(provider.resolvedFactories.length);
        for (var i = 0; i < provider.resolvedFactories.length; ++i) {
          res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
        }
        return res;
      } else {
        return this._instantiate(provider, provider.resolvedFactories[0]);
      }
    };
    ReflectiveInjector_.prototype._instantiate = function(provider, ResolvedReflectiveFactory$$1) {
      var _this = this;
      var factory = ResolvedReflectiveFactory$$1.factory;
      var deps;
      try {
        deps = ResolvedReflectiveFactory$$1.dependencies.map(function(dep) {
          return _this._getByReflectiveDependency(dep);
        });
      } catch (e) {
        if (e.addKey) {
          e.addKey(this, provider.key);
        }
        throw e;
      }
      var obj;
      try {
        obj = factory.apply(void 0, deps);
      } catch (e) {
        throw instantiationError(this, e, e.stack, provider.key);
      }
      return obj;
    };
    ReflectiveInjector_.prototype._getByReflectiveDependency = function(dep) {
      return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);
    };
    ReflectiveInjector_.prototype._getByKey = function(key, visibility, notFoundValue) {
      if (key === INJECTOR_KEY) {
        return this;
      }
      if (visibility instanceof Self) {
        return this._getByKeySelf(key, notFoundValue);
      } else {
        return this._getByKeyDefault(key, notFoundValue, visibility);
      }
    };
    ReflectiveInjector_.prototype._getObjByKeyId = function(keyId) {
      for (var i = 0; i < this.keyIds.length; i++) {
        if (this.keyIds[i] === keyId) {
          if (this.objs[i] === UNDEFINED) {
            this.objs[i] = this._new(this._providers[i]);
          }
          return this.objs[i];
        }
      }
      return UNDEFINED;
    };
    ReflectiveInjector_.prototype._throwOrNull = function(key, notFoundValue) {
      if (notFoundValue !== THROW_IF_NOT_FOUND) {
        return notFoundValue;
      } else {
        throw noProviderError(this, key);
      }
    };
    ReflectiveInjector_.prototype._getByKeySelf = function(key, notFoundValue) {
      var obj = this._getObjByKeyId(key.id);
      return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
    };
    ReflectiveInjector_.prototype._getByKeyDefault = function(key, notFoundValue, visibility) {
      var inj;
      if (visibility instanceof SkipSelf) {
        inj = this._parent;
      } else {
        inj = this;
      }
      while (inj instanceof ReflectiveInjector_) {
        var inj_ = (inj);
        var obj = inj_._getObjByKeyId(key.id);
        if (obj !== UNDEFINED)
          return obj;
        inj = inj_._parent;
      }
      if (inj !== null) {
        return inj.get(key.token, notFoundValue);
      } else {
        return this._throwOrNull(key, notFoundValue);
      }
    };
    Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
      get: function() {
        var providers = _mapProviders(this, function(b) {
          return ' "' + b.key.displayName + '" ';
        }).join(', ');
        return "ReflectiveInjector(providers: [" + providers + "])";
      },
      enumerable: true,
      configurable: true
    });
    ReflectiveInjector_.prototype.toString = function() {
      return this.displayName;
    };
    return ReflectiveInjector_;
  }());
  var INJECTOR_KEY = ReflectiveKey.get(Injector);
  function _mapProviders(injector, fn) {
    var res = new Array(injector._providers.length);
    for (var i = 0; i < injector._providers.length; ++i) {
      res[i] = fn(injector.getProviderAtIndex(i));
    }
    return res;
  }
  function isPromise(obj) {
    return !!obj && typeof obj.then === 'function';
  }
  function isObservable(obj) {
    return !!obj && typeof obj.subscribe === 'function';
  }
  var APP_INITIALIZER = new InjectionToken('Application Initializer');
  var ApplicationInitStatus = (function() {
    function ApplicationInitStatus(appInits) {
      var _this = this;
      this.appInits = appInits;
      this.initialized = false;
      this._done = false;
      this._donePromise = new Promise(function(res, rej) {
        _this.resolve = res;
        _this.reject = rej;
      });
    }
    ApplicationInitStatus.prototype.runInitializers = function() {
      var _this = this;
      if (this.initialized) {
        return;
      }
      var asyncInitPromises = [];
      var complete = function() {
        _this._done = true;
        _this.resolve();
      };
      if (this.appInits) {
        for (var i = 0; i < this.appInits.length; i++) {
          var initResult = this.appInits[i]();
          if (isPromise(initResult)) {
            asyncInitPromises.push(initResult);
          }
        }
      }
      Promise.all(asyncInitPromises).then(function() {
        complete();
      }).catch(function(e) {
        _this.reject(e);
      });
      if (asyncInitPromises.length === 0) {
        complete();
      }
      this.initialized = true;
    };
    Object.defineProperty(ApplicationInitStatus.prototype, "done", {
      get: function() {
        return this._done;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ApplicationInitStatus.prototype, "donePromise", {
      get: function() {
        return this._donePromise;
      },
      enumerable: true,
      configurable: true
    });
    return ApplicationInitStatus;
  }());
  ApplicationInitStatus.decorators = [{type: Injectable}];
  ApplicationInitStatus.ctorParameters = function() {
    return [{
      type: Array,
      decorators: [{
        type: Inject,
        args: [APP_INITIALIZER]
      }, {type: Optional}]
    }];
  };
  var APP_ID = new InjectionToken('AppId');
  function _appIdRandomProviderFactory() {
    return "" + _randomChar() + _randomChar() + _randomChar();
  }
  var APP_ID_RANDOM_PROVIDER = {
    provide: APP_ID,
    useFactory: _appIdRandomProviderFactory,
    deps: []
  };
  function _randomChar() {
    return String.fromCharCode(97 + Math.floor(Math.random() * 25));
  }
  var PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');
  var PLATFORM_ID = new InjectionToken('Platform ID');
  var APP_BOOTSTRAP_LISTENER = new InjectionToken('appBootstrapListener');
  var PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');
  var Console = (function() {
    function Console() {}
    Console.prototype.log = function(message) {
      console.log(message);
    };
    Console.prototype.warn = function(message) {
      console.warn(message);
    };
    return Console;
  }());
  Console.decorators = [{type: Injectable}];
  Console.ctorParameters = function() {
    return [];
  };
  var ModuleWithComponentFactories = (function() {
    function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {
      this.ngModuleFactory = ngModuleFactory;
      this.componentFactories = componentFactories;
    }
    return ModuleWithComponentFactories;
  }());
  function _throwError() {
    throw new Error("Runtime compiler is not loaded");
  }
  var Compiler = (function() {
    function Compiler() {}
    Compiler.prototype.compileModuleSync = function(moduleType) {
      throw _throwError();
    };
    Compiler.prototype.compileModuleAsync = function(moduleType) {
      throw _throwError();
    };
    Compiler.prototype.compileModuleAndAllComponentsSync = function(moduleType) {
      throw _throwError();
    };
    Compiler.prototype.compileModuleAndAllComponentsAsync = function(moduleType) {
      throw _throwError();
    };
    Compiler.prototype.getNgContentSelectors = function(component) {
      throw _throwError();
    };
    Compiler.prototype.clearCache = function() {};
    Compiler.prototype.clearCacheFor = function(type) {};
    return Compiler;
  }());
  Compiler.decorators = [{type: Injectable}];
  Compiler.ctorParameters = function() {
    return [];
  };
  var COMPILER_OPTIONS = new InjectionToken('compilerOptions');
  var CompilerFactory = (function() {
    function CompilerFactory() {}
    CompilerFactory.prototype.createCompiler = function(options) {};
    return CompilerFactory;
  }());
  var ComponentRef = (function() {
    function ComponentRef() {}
    ComponentRef.prototype.location = function() {};
    ComponentRef.prototype.injector = function() {};
    ComponentRef.prototype.instance = function() {};
    ComponentRef.prototype.hostView = function() {};
    ComponentRef.prototype.changeDetectorRef = function() {};
    ComponentRef.prototype.componentType = function() {};
    ComponentRef.prototype.destroy = function() {};
    ComponentRef.prototype.onDestroy = function(callback) {};
    return ComponentRef;
  }());
  var ComponentFactory = (function() {
    function ComponentFactory() {}
    ComponentFactory.prototype.selector = function() {};
    ComponentFactory.prototype.componentType = function() {};
    ComponentFactory.prototype.ngContentSelectors = function() {};
    ComponentFactory.prototype.inputs = function() {};
    ComponentFactory.prototype.outputs = function() {};
    ComponentFactory.prototype.create = function(injector, projectableNodes, rootSelectorOrNode, ngModule) {};
    return ComponentFactory;
  }());
  function noComponentFactoryError(component) {
    var error = Error("No component factory found for " + stringify(component) + ". Did you add it to @NgModule.entryComponents?");
    ((error))[ERROR_COMPONENT] = component;
    return error;
  }
  var ERROR_COMPONENT = 'ngComponent';
  var _NullComponentFactoryResolver = (function() {
    function _NullComponentFactoryResolver() {}
    _NullComponentFactoryResolver.prototype.resolveComponentFactory = function(component) {
      throw noComponentFactoryError(component);
    };
    return _NullComponentFactoryResolver;
  }());
  var ComponentFactoryResolver = (function() {
    function ComponentFactoryResolver() {}
    ComponentFactoryResolver.prototype.resolveComponentFactory = function(component) {};
    return ComponentFactoryResolver;
  }());
  ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
  var CodegenComponentFactoryResolver = (function() {
    function CodegenComponentFactoryResolver(factories, _parent, _ngModule) {
      this._parent = _parent;
      this._ngModule = _ngModule;
      this._factories = new Map();
      for (var i = 0; i < factories.length; i++) {
        var factory = factories[i];
        this._factories.set(factory.componentType, factory);
      }
    }
    CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function(component) {
      var factory = this._factories.get(component);
      if (!factory && this._parent) {
        factory = this._parent.resolveComponentFactory(component);
      }
      if (!factory) {
        throw noComponentFactoryError(component);
      }
      return new ComponentFactoryBoundToModule(factory, this._ngModule);
    };
    return CodegenComponentFactoryResolver;
  }());
  var ComponentFactoryBoundToModule = (function(_super) {
    __extends(ComponentFactoryBoundToModule, _super);
    function ComponentFactoryBoundToModule(factory, ngModule) {
      var _this = _super.call(this) || this;
      _this.factory = factory;
      _this.ngModule = ngModule;
      return _this;
    }
    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "selector", {
      get: function() {
        return this.factory.selector;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "componentType", {
      get: function() {
        return this.factory.componentType;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "ngContentSelectors", {
      get: function() {
        return this.factory.ngContentSelectors;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "inputs", {
      get: function() {
        return this.factory.inputs;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "outputs", {
      get: function() {
        return this.factory.outputs;
      },
      enumerable: true,
      configurable: true
    });
    ComponentFactoryBoundToModule.prototype.create = function(injector, projectableNodes, rootSelectorOrNode, ngModule) {
      return this.factory.create(injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);
    };
    return ComponentFactoryBoundToModule;
  }(ComponentFactory));
  var NgModuleRef = (function() {
    function NgModuleRef() {}
    NgModuleRef.prototype.injector = function() {};
    NgModuleRef.prototype.componentFactoryResolver = function() {};
    NgModuleRef.prototype.instance = function() {};
    NgModuleRef.prototype.destroy = function() {};
    NgModuleRef.prototype.onDestroy = function(callback) {};
    return NgModuleRef;
  }());
  var NgModuleFactory = (function() {
    function NgModuleFactory() {}
    NgModuleFactory.prototype.moduleType = function() {};
    NgModuleFactory.prototype.create = function(parentInjector) {};
    return NgModuleFactory;
  }());
  var trace;
  var events;
  function detectWTF() {
    var wtf = ((_global))['wtf'];
    if (wtf) {
      trace = wtf['trace'];
      if (trace) {
        events = trace['events'];
        return true;
      }
    }
    return false;
  }
  function createScope$1(signature, flags) {
    if (flags === void 0) {
      flags = null;
    }
    return events.createScope(signature, flags);
  }
  function leave(scope, returnValue) {
    trace.leaveScope(scope, returnValue);
    return returnValue;
  }
  function startTimeRange(rangeType, action) {
    return trace.beginTimeRange(rangeType, action);
  }
  function endTimeRange(range) {
    trace.endTimeRange(range);
  }
  var wtfEnabled = detectWTF();
  function noopScope(arg0, arg1) {
    return null;
  }
  var wtfCreateScope = wtfEnabled ? createScope$1 : function(signature, flags) {
    return noopScope;
  };
  var wtfLeave = wtfEnabled ? leave : function(s, r) {
    return r;
  };
  var wtfStartTimeRange = wtfEnabled ? startTimeRange : function(rangeType, action) {
    return null;
  };
  var wtfEndTimeRange = wtfEnabled ? endTimeRange : function(r) {
    return null;
  };
  var EventEmitter = (function(_super) {
    __extends(EventEmitter, _super);
    function EventEmitter(isAsync) {
      if (isAsync === void 0) {
        isAsync = false;
      }
      var _this = _super.call(this) || this;
      _this.__isAsync = isAsync;
      return _this;
    }
    EventEmitter.prototype.emit = function(value) {
      _super.prototype.next.call(this, value);
    };
    EventEmitter.prototype.subscribe = function(generatorOrNext, error, complete) {
      var schedulerFn;
      var errorFn = function(err) {
        return null;
      };
      var completeFn = function() {
        return null;
      };
      if (generatorOrNext && typeof generatorOrNext === 'object') {
        schedulerFn = this.__isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext.next(value);
          });
        } : function(value) {
          generatorOrNext.next(value);
        };
        if (generatorOrNext.error) {
          errorFn = this.__isAsync ? function(err) {
            setTimeout(function() {
              return generatorOrNext.error(err);
            });
          } : function(err) {
            generatorOrNext.error(err);
          };
        }
        if (generatorOrNext.complete) {
          completeFn = this.__isAsync ? function() {
            setTimeout(function() {
              return generatorOrNext.complete();
            });
          } : function() {
            generatorOrNext.complete();
          };
        }
      } else {
        schedulerFn = this.__isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext(value);
          });
        } : function(value) {
          generatorOrNext(value);
        };
        if (error) {
          errorFn = this.__isAsync ? function(err) {
            setTimeout(function() {
              return error(err);
            });
          } : function(err) {
            error(err);
          };
        }
        if (complete) {
          completeFn = this.__isAsync ? function() {
            setTimeout(function() {
              return complete();
            });
          } : function() {
            complete();
          };
        }
      }
      return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
    };
    return EventEmitter;
  }(rxjs_Subject.Subject));
  var NgZone = (function() {
    function NgZone(_a) {
      var _b = _a.enableLongStackTrace,
          enableLongStackTrace = _b === void 0 ? false : _b;
      this.hasPendingMicrotasks = false;
      this.hasPendingMacrotasks = false;
      this.isStable = true;
      this.onUnstable = new EventEmitter(false);
      this.onMicrotaskEmpty = new EventEmitter(false);
      this.onStable = new EventEmitter(false);
      this.onError = new EventEmitter(false);
      if (typeof Zone == 'undefined') {
        throw new Error('Angular requires Zone.js prolyfill.');
      }
      Zone.assertZonePatched();
      var self = this;
      self._nesting = 0;
      self._outer = self._inner = Zone.current;
      if (Zone['wtfZoneSpec']) {
        self._inner = self._inner.fork(Zone['wtfZoneSpec']);
      }
      if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
        self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);
      }
      forkInnerZoneWithAngularBehavior(self);
    }
    NgZone.isInAngularZone = function() {
      return Zone.current.get('isAngularZone') === true;
    };
    NgZone.assertInAngularZone = function() {
      if (!NgZone.isInAngularZone()) {
        throw new Error('Expected to be in Angular Zone, but it is not!');
      }
    };
    NgZone.assertNotInAngularZone = function() {
      if (NgZone.isInAngularZone()) {
        throw new Error('Expected to not be in Angular Zone, but it is!');
      }
    };
    NgZone.prototype.run = function(fn) {
      return (((this)))._inner.run(fn);
    };
    NgZone.prototype.runGuarded = function(fn) {
      return (((this)))._inner.runGuarded(fn);
    };
    NgZone.prototype.runOutsideAngular = function(fn) {
      return (((this)))._outer.run(fn);
    };
    return NgZone;
  }());
  function checkStable(zone) {
    if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
      try {
        zone._nesting++;
        zone.onMicrotaskEmpty.emit(null);
      } finally {
        zone._nesting--;
        if (!zone.hasPendingMicrotasks) {
          try {
            zone.runOutsideAngular(function() {
              return zone.onStable.emit(null);
            });
          } finally {
            zone.isStable = true;
          }
        }
      }
    }
  }
  function forkInnerZoneWithAngularBehavior(zone) {
    zone._inner = zone._inner.fork({
      name: 'angular',
      properties: ({'isAngularZone': true}),
      onInvokeTask: function(delegate, current, target, task, applyThis, applyArgs) {
        try {
          onEnter(zone);
          return delegate.invokeTask(target, task, applyThis, applyArgs);
        } finally {
          onLeave(zone);
        }
      },
      onInvoke: function(delegate, current, target, callback, applyThis, applyArgs, source) {
        try {
          onEnter(zone);
          return delegate.invoke(target, callback, applyThis, applyArgs, source);
        } finally {
          onLeave(zone);
        }
      },
      onHasTask: function(delegate, current, target, hasTaskState) {
        delegate.hasTask(target, hasTaskState);
        if (current === target) {
          if (hasTaskState.change == 'microTask') {
            zone.hasPendingMicrotasks = hasTaskState.microTask;
            checkStable(zone);
          } else if (hasTaskState.change == 'macroTask') {
            zone.hasPendingMacrotasks = hasTaskState.macroTask;
          }
        }
      },
      onHandleError: function(delegate, current, target, error) {
        delegate.handleError(target, error);
        zone.runOutsideAngular(function() {
          return zone.onError.emit(error);
        });
        return false;
      }
    });
  }
  function onEnter(zone) {
    zone._nesting++;
    if (zone.isStable) {
      zone.isStable = false;
      zone.onUnstable.emit(null);
    }
  }
  function onLeave(zone) {
    zone._nesting--;
    checkStable(zone);
  }
  var Testability = (function() {
    function Testability(_ngZone) {
      this._ngZone = _ngZone;
      this._pendingCount = 0;
      this._isZoneStable = true;
      this._didWork = false;
      this._callbacks = [];
      this._watchAngularEvents();
    }
    Testability.prototype._watchAngularEvents = function() {
      var _this = this;
      this._ngZone.onUnstable.subscribe({next: function() {
          _this._didWork = true;
          _this._isZoneStable = false;
        }});
      this._ngZone.runOutsideAngular(function() {
        _this._ngZone.onStable.subscribe({next: function() {
            NgZone.assertNotInAngularZone();
            scheduleMicroTask(function() {
              _this._isZoneStable = true;
              _this._runCallbacksIfReady();
            });
          }});
      });
    };
    Testability.prototype.increasePendingRequestCount = function() {
      this._pendingCount += 1;
      this._didWork = true;
      return this._pendingCount;
    };
    Testability.prototype.decreasePendingRequestCount = function() {
      this._pendingCount -= 1;
      if (this._pendingCount < 0) {
        throw new Error('pending async requests below zero');
      }
      this._runCallbacksIfReady();
      return this._pendingCount;
    };
    Testability.prototype.isStable = function() {
      return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
    };
    Testability.prototype._runCallbacksIfReady = function() {
      var _this = this;
      if (this.isStable()) {
        scheduleMicroTask(function() {
          while (_this._callbacks.length !== 0) {
            (((_this._callbacks.pop())))(_this._didWork);
          }
          _this._didWork = false;
        });
      } else {
        this._didWork = true;
      }
    };
    Testability.prototype.whenStable = function(callback) {
      this._callbacks.push(callback);
      this._runCallbacksIfReady();
    };
    Testability.prototype.getPendingRequestCount = function() {
      return this._pendingCount;
    };
    Testability.prototype.findBindings = function(using, provider, exactMatch) {
      return [];
    };
    Testability.prototype.findProviders = function(using, provider, exactMatch) {
      return [];
    };
    return Testability;
  }());
  Testability.decorators = [{type: Injectable}];
  Testability.ctorParameters = function() {
    return [{type: NgZone}];
  };
  var TestabilityRegistry = (function() {
    function TestabilityRegistry() {
      this._applications = new Map();
      _testabilityGetter.addToWindow(this);
    }
    TestabilityRegistry.prototype.registerApplication = function(token, testability) {
      this._applications.set(token, testability);
    };
    TestabilityRegistry.prototype.getTestability = function(elem) {
      return this._applications.get(elem) || null;
    };
    TestabilityRegistry.prototype.getAllTestabilities = function() {
      return Array.from(this._applications.values());
    };
    TestabilityRegistry.prototype.getAllRootElements = function() {
      return Array.from(this._applications.keys());
    };
    TestabilityRegistry.prototype.findTestabilityInTree = function(elem, findInAncestors) {
      if (findInAncestors === void 0) {
        findInAncestors = true;
      }
      return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
    };
    return TestabilityRegistry;
  }());
  TestabilityRegistry.decorators = [{type: Injectable}];
  TestabilityRegistry.ctorParameters = function() {
    return [];
  };
  var _NoopGetTestability = (function() {
    function _NoopGetTestability() {}
    _NoopGetTestability.prototype.addToWindow = function(registry) {};
    _NoopGetTestability.prototype.findTestabilityInTree = function(registry, elem, findInAncestors) {
      return null;
    };
    return _NoopGetTestability;
  }());
  function setTestabilityGetter(getter) {
    _testabilityGetter = getter;
  }
  var _testabilityGetter = new _NoopGetTestability();
  var _devMode = true;
  var _runModeLocked = false;
  var _platform;
  var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken('AllowMultipleToken');
  function enableProdMode() {
    if (_runModeLocked) {
      throw new Error('Cannot enable prod mode after platform setup.');
    }
    _devMode = false;
  }
  function isDevMode() {
    _runModeLocked = true;
    return _devMode;
  }
  var NgProbeToken = (function() {
    function NgProbeToken(name, token) {
      this.name = name;
      this.token = token;
    }
    return NgProbeToken;
  }());
  function createPlatform(injector) {
    if (_platform && !_platform.destroyed && !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
      throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
    }
    _platform = injector.get(PlatformRef);
    var inits = injector.get(PLATFORM_INITIALIZER, null);
    if (inits)
      inits.forEach(function(init) {
        return init();
      });
    return _platform;
  }
  function createPlatformFactory(parentPlatformFactory, name, providers) {
    if (providers === void 0) {
      providers = [];
    }
    var marker = new InjectionToken("Platform: " + name);
    return function(extraProviders) {
      if (extraProviders === void 0) {
        extraProviders = [];
      }
      var platform = getPlatform();
      if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
        if (parentPlatformFactory) {
          parentPlatformFactory(providers.concat(extraProviders).concat({
            provide: marker,
            useValue: true
          }));
        } else {
          createPlatform(ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({
            provide: marker,
            useValue: true
          })));
        }
      }
      return assertPlatform(marker);
    };
  }
  function assertPlatform(requiredToken) {
    var platform = getPlatform();
    if (!platform) {
      throw new Error('No platform exists!');
    }
    if (!platform.injector.get(requiredToken, null)) {
      throw new Error('A platform with a different configuration has been created. Please destroy it first.');
    }
    return platform;
  }
  function destroyPlatform() {
    if (_platform && !_platform.destroyed) {
      _platform.destroy();
    }
  }
  function getPlatform() {
    return _platform && !_platform.destroyed ? _platform : null;
  }
  var PlatformRef = (function() {
    function PlatformRef() {}
    PlatformRef.prototype.bootstrapModuleFactory = function(moduleFactory) {};
    PlatformRef.prototype.bootstrapModule = function(moduleType, compilerOptions) {};
    PlatformRef.prototype.onDestroy = function(callback) {};
    PlatformRef.prototype.injector = function() {};
    PlatformRef.prototype.destroy = function() {};
    PlatformRef.prototype.destroyed = function() {};
    return PlatformRef;
  }());
  function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {
    try {
      var result = callback();
      if (isPromise(result)) {
        return result.catch(function(e) {
          ngZone.runOutsideAngular(function() {
            return errorHandler.handleError(e);
          });
          throw e;
        });
      }
      return result;
    } catch (e) {
      ngZone.runOutsideAngular(function() {
        return errorHandler.handleError(e);
      });
      throw e;
    }
  }
  var PlatformRef_ = (function(_super) {
    __extends(PlatformRef_, _super);
    function PlatformRef_(_injector) {
      var _this = _super.call(this) || this;
      _this._injector = _injector;
      _this._modules = [];
      _this._destroyListeners = [];
      _this._destroyed = false;
      return _this;
    }
    PlatformRef_.prototype.onDestroy = function(callback) {
      this._destroyListeners.push(callback);
    };
    Object.defineProperty(PlatformRef_.prototype, "injector", {
      get: function() {
        return this._injector;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PlatformRef_.prototype, "destroyed", {
      get: function() {
        return this._destroyed;
      },
      enumerable: true,
      configurable: true
    });
    PlatformRef_.prototype.destroy = function() {
      if (this._destroyed) {
        throw new Error('The platform has already been destroyed!');
      }
      this._modules.slice().forEach(function(module) {
        return module.destroy();
      });
      this._destroyListeners.forEach(function(listener) {
        return listener();
      });
      this._destroyed = true;
    };
    PlatformRef_.prototype.bootstrapModuleFactory = function(moduleFactory) {
      return this._bootstrapModuleFactoryWithZone(moduleFactory);
    };
    PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function(moduleFactory, ngZone) {
      var _this = this;
      if (!ngZone)
        ngZone = new NgZone({enableLongStackTrace: isDevMode()});
      return ngZone.run(function() {
        var ngZoneInjector = ReflectiveInjector.resolveAndCreate([{
          provide: NgZone,
          useValue: ngZone
        }], _this.injector);
        var moduleRef = (moduleFactory.create(ngZoneInjector));
        var exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
        if (!exceptionHandler) {
          throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
        }
        moduleRef.onDestroy(function() {
          return remove(_this._modules, moduleRef);
        });
        ((ngZone)).runOutsideAngular(function() {
          return ((ngZone)).onError.subscribe({next: function(error) {
              exceptionHandler.handleError(error);
            }});
        });
        return _callAndReportToErrorHandler(exceptionHandler, ((ngZone)), function() {
          var initStatus = moduleRef.injector.get(ApplicationInitStatus);
          initStatus.runInitializers();
          return initStatus.donePromise.then(function() {
            _this._moduleDoBootstrap(moduleRef);
            return moduleRef;
          });
        });
      });
    };
    PlatformRef_.prototype.bootstrapModule = function(moduleType, compilerOptions) {
      if (compilerOptions === void 0) {
        compilerOptions = [];
      }
      return this._bootstrapModuleWithZone(moduleType, compilerOptions);
    };
    PlatformRef_.prototype._bootstrapModuleWithZone = function(moduleType, compilerOptions, ngZone) {
      var _this = this;
      if (compilerOptions === void 0) {
        compilerOptions = [];
      }
      var compilerFactory = this.injector.get(CompilerFactory);
      var compiler = compilerFactory.createCompiler(Array.isArray(compilerOptions) ? compilerOptions : [compilerOptions]);
      return compiler.compileModuleAsync(moduleType).then(function(moduleFactory) {
        return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone);
      });
    };
    PlatformRef_.prototype._moduleDoBootstrap = function(moduleRef) {
      var appRef = (moduleRef.injector.get(ApplicationRef));
      if (moduleRef._bootstrapComponents.length > 0) {
        moduleRef._bootstrapComponents.forEach(function(f) {
          return appRef.bootstrap(f);
        });
      } else if (moduleRef.instance.ngDoBootstrap) {
        moduleRef.instance.ngDoBootstrap(appRef);
      } else {
        throw new Error("The module " + stringify(moduleRef.instance.constructor) + " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. " + "Please define one of these.");
      }
      this._modules.push(moduleRef);
    };
    return PlatformRef_;
  }(PlatformRef));
  PlatformRef_.decorators = [{type: Injectable}];
  PlatformRef_.ctorParameters = function() {
    return [{type: Injector}];
  };
  var ApplicationRef = (function() {
    function ApplicationRef() {}
    ApplicationRef.prototype.bootstrap = function(componentFactory, rootSelectorOrNode) {};
    ApplicationRef.prototype.tick = function() {};
    ApplicationRef.prototype.componentTypes = function() {};
    ApplicationRef.prototype.components = function() {};
    ApplicationRef.prototype.attachView = function(view) {};
    ApplicationRef.prototype.detachView = function(view) {};
    ApplicationRef.prototype.viewCount = function() {};
    ApplicationRef.prototype.isStable = function() {};
    return ApplicationRef;
  }());
  var ApplicationRef_ = (function(_super) {
    __extends(ApplicationRef_, _super);
    function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
      var _this = _super.call(this) || this;
      _this._zone = _zone;
      _this._console = _console;
      _this._injector = _injector;
      _this._exceptionHandler = _exceptionHandler;
      _this._componentFactoryResolver = _componentFactoryResolver;
      _this._initStatus = _initStatus;
      _this._bootstrapListeners = [];
      _this._rootComponents = [];
      _this._rootComponentTypes = [];
      _this._views = [];
      _this._runningTick = false;
      _this._enforceNoNewChanges = false;
      _this._stable = true;
      _this._enforceNoNewChanges = isDevMode();
      _this._zone.onMicrotaskEmpty.subscribe({next: function() {
          _this._zone.run(function() {
            _this.tick();
          });
        }});
      var isCurrentlyStable = new rxjs_Observable.Observable(function(observer) {
        _this._stable = _this._zone.isStable && !_this._zone.hasPendingMacrotasks && !_this._zone.hasPendingMicrotasks;
        _this._zone.runOutsideAngular(function() {
          observer.next(_this._stable);
          observer.complete();
        });
      });
      var isStable = new rxjs_Observable.Observable(function(observer) {
        var stableSub = _this._zone.onStable.subscribe(function() {
          NgZone.assertNotInAngularZone();
          scheduleMicroTask(function() {
            if (!_this._stable && !_this._zone.hasPendingMacrotasks && !_this._zone.hasPendingMicrotasks) {
              _this._stable = true;
              observer.next(true);
            }
          });
        });
        var unstableSub = _this._zone.onUnstable.subscribe(function() {
          NgZone.assertInAngularZone();
          if (_this._stable) {
            _this._stable = false;
            _this._zone.runOutsideAngular(function() {
              observer.next(false);
            });
          }
        });
        return function() {
          stableSub.unsubscribe();
          unstableSub.unsubscribe();
        };
      });
      _this._isStable = rxjs_observable_merge.merge(isCurrentlyStable, rxjs_operator_share.share.call(isStable));
      return _this;
    }
    ApplicationRef_.prototype.attachView = function(viewRef) {
      var view = ((viewRef));
      this._views.push(view);
      view.attachToAppRef(this);
    };
    ApplicationRef_.prototype.detachView = function(viewRef) {
      var view = ((viewRef));
      remove(this._views, view);
      view.detachFromAppRef();
    };
    ApplicationRef_.prototype.bootstrap = function(componentOrFactory, rootSelectorOrNode) {
      var _this = this;
      if (!this._initStatus.done) {
        throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
      }
      var componentFactory;
      if (componentOrFactory instanceof ComponentFactory) {
        componentFactory = componentOrFactory;
      } else {
        componentFactory = ((this._componentFactoryResolver.resolveComponentFactory(componentOrFactory)));
      }
      this._rootComponentTypes.push(componentFactory.componentType);
      var ngModule = componentFactory instanceof ComponentFactoryBoundToModule ? null : this._injector.get(NgModuleRef);
      var selectorOrNode = rootSelectorOrNode || componentFactory.selector;
      var compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
      compRef.onDestroy(function() {
        _this._unloadComponent(compRef);
      });
      var testability = compRef.injector.get(Testability, null);
      if (testability) {
        compRef.injector.get(TestabilityRegistry).registerApplication(compRef.location.nativeElement, testability);
      }
      this._loadComponent(compRef);
      if (isDevMode()) {
        this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode.");
      }
      return compRef;
    };
    ApplicationRef_.prototype._loadComponent = function(componentRef) {
      this.attachView(componentRef.hostView);
      this.tick();
      this._rootComponents.push(componentRef);
      var listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);
      listeners.forEach(function(listener) {
        return listener(componentRef);
      });
    };
    ApplicationRef_.prototype._unloadComponent = function(componentRef) {
      this.detachView(componentRef.hostView);
      remove(this._rootComponents, componentRef);
    };
    ApplicationRef_.prototype.tick = function() {
      var _this = this;
      if (this._runningTick) {
        throw new Error('ApplicationRef.tick is called recursively');
      }
      var scope = ApplicationRef_._tickScope();
      try {
        this._runningTick = true;
        this._views.forEach(function(view) {
          return view.detectChanges();
        });
        if (this._enforceNoNewChanges) {
          this._views.forEach(function(view) {
            return view.checkNoChanges();
          });
        }
      } catch (e) {
        this._zone.runOutsideAngular(function() {
          return _this._exceptionHandler.handleError(e);
        });
      } finally {
        this._runningTick = false;
        wtfLeave(scope);
      }
    };
    ApplicationRef_.prototype.ngOnDestroy = function() {
      this._views.slice().forEach(function(view) {
        return view.destroy();
      });
    };
    Object.defineProperty(ApplicationRef_.prototype, "viewCount", {
      get: function() {
        return this._views.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
      get: function() {
        return this._rootComponentTypes;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ApplicationRef_.prototype, "components", {
      get: function() {
        return this._rootComponents;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ApplicationRef_.prototype, "isStable", {
      get: function() {
        return this._isStable;
      },
      enumerable: true,
      configurable: true
    });
    return ApplicationRef_;
  }(ApplicationRef));
  ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');
  ApplicationRef_.decorators = [{type: Injectable}];
  ApplicationRef_.ctorParameters = function() {
    return [{type: NgZone}, {type: Console}, {type: Injector}, {type: ErrorHandler}, {type: ComponentFactoryResolver}, {type: ApplicationInitStatus}];
  };
  function remove(list, el) {
    var index = list.indexOf(el);
    if (index > -1) {
      list.splice(index, 1);
    }
  }
  var RenderComponentType = (function() {
    function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
      this.id = id;
      this.templateUrl = templateUrl;
      this.slotCount = slotCount;
      this.encapsulation = encapsulation;
      this.styles = styles;
      this.animations = animations;
    }
    return RenderComponentType;
  }());
  var RenderDebugInfo = (function() {
    function RenderDebugInfo() {}
    RenderDebugInfo.prototype.injector = function() {};
    RenderDebugInfo.prototype.component = function() {};
    RenderDebugInfo.prototype.providerTokens = function() {};
    RenderDebugInfo.prototype.references = function() {};
    RenderDebugInfo.prototype.context = function() {};
    RenderDebugInfo.prototype.source = function() {};
    return RenderDebugInfo;
  }());
  var Renderer = (function() {
    function Renderer() {}
    Renderer.prototype.selectRootElement = function(selectorOrNode, debugInfo) {};
    Renderer.prototype.createElement = function(parentElement, name, debugInfo) {};
    Renderer.prototype.createViewRoot = function(hostElement) {};
    Renderer.prototype.createTemplateAnchor = function(parentElement, debugInfo) {};
    Renderer.prototype.createText = function(parentElement, value, debugInfo) {};
    Renderer.prototype.projectNodes = function(parentElement, nodes) {};
    Renderer.prototype.attachViewAfter = function(node, viewRootNodes) {};
    Renderer.prototype.detachView = function(viewRootNodes) {};
    Renderer.prototype.destroyView = function(hostElement, viewAllNodes) {};
    Renderer.prototype.listen = function(renderElement, name, callback) {};
    Renderer.prototype.listenGlobal = function(target, name, callback) {};
    Renderer.prototype.setElementProperty = function(renderElement, propertyName, propertyValue) {};
    Renderer.prototype.setElementAttribute = function(renderElement, attributeName, attributeValue) {};
    Renderer.prototype.setBindingDebugInfo = function(renderElement, propertyName, propertyValue) {};
    Renderer.prototype.setElementClass = function(renderElement, className, isAdd) {};
    Renderer.prototype.setElementStyle = function(renderElement, styleName, styleValue) {};
    Renderer.prototype.invokeElementMethod = function(renderElement, methodName, args) {};
    Renderer.prototype.setText = function(renderNode, text) {};
    Renderer.prototype.animate = function(element, startingStyles, keyframes, duration, delay, easing, previousPlayers) {};
    return Renderer;
  }());
  var Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');
  var RootRenderer = (function() {
    function RootRenderer() {}
    RootRenderer.prototype.renderComponent = function(componentType) {};
    return RootRenderer;
  }());
  var RendererFactory2 = (function() {
    function RendererFactory2() {}
    RendererFactory2.prototype.createRenderer = function(hostElement, type) {};
    RendererFactory2.prototype.begin = function() {};
    RendererFactory2.prototype.end = function() {};
    RendererFactory2.prototype.whenRenderingDone = function() {};
    return RendererFactory2;
  }());
  var RendererStyleFlags2 = {};
  RendererStyleFlags2.Important = 1;
  RendererStyleFlags2.DashCase = 2;
  RendererStyleFlags2[RendererStyleFlags2.Important] = "Important";
  RendererStyleFlags2[RendererStyleFlags2.DashCase] = "DashCase";
  var Renderer2 = (function() {
    function Renderer2() {}
    Renderer2.prototype.data = function() {};
    Renderer2.prototype.destroy = function() {};
    Renderer2.prototype.createElement = function(name, namespace) {};
    Renderer2.prototype.createComment = function(value) {};
    Renderer2.prototype.createText = function(value) {};
    Renderer2.prototype.appendChild = function(parent, newChild) {};
    Renderer2.prototype.insertBefore = function(parent, newChild, refChild) {};
    Renderer2.prototype.removeChild = function(parent, oldChild) {};
    Renderer2.prototype.selectRootElement = function(selectorOrNode) {};
    Renderer2.prototype.parentNode = function(node) {};
    Renderer2.prototype.nextSibling = function(node) {};
    Renderer2.prototype.setAttribute = function(el, name, value, namespace) {};
    Renderer2.prototype.removeAttribute = function(el, name, namespace) {};
    Renderer2.prototype.addClass = function(el, name) {};
    Renderer2.prototype.removeClass = function(el, name) {};
    Renderer2.prototype.setStyle = function(el, style, value, flags) {};
    Renderer2.prototype.removeStyle = function(el, style, flags) {};
    Renderer2.prototype.setProperty = function(el, name, value) {};
    Renderer2.prototype.setValue = function(node, value) {};
    Renderer2.prototype.listen = function(target, eventName, callback) {};
    return Renderer2;
  }());
  var ElementRef = (function() {
    function ElementRef(nativeElement) {
      this.nativeElement = nativeElement;
    }
    return ElementRef;
  }());
  var NgModuleFactoryLoader = (function() {
    function NgModuleFactoryLoader() {}
    NgModuleFactoryLoader.prototype.load = function(path) {};
    return NgModuleFactoryLoader;
  }());
  var moduleFactories = new Map();
  function registerModuleFactory(id, factory) {
    var existing = moduleFactories.get(id);
    if (existing) {
      throw new Error("Duplicate module registered for " + id + " - " + existing.moduleType.name + " vs " + factory.moduleType.name);
    }
    moduleFactories.set(id, factory);
  }
  function getModuleFactory(id) {
    var factory = moduleFactories.get(id);
    if (!factory)
      throw new Error("No module with ID " + id + " loaded");
    return factory;
  }
  var QueryList = (function() {
    function QueryList() {
      this._dirty = true;
      this._results = [];
      this._emitter = new EventEmitter();
    }
    Object.defineProperty(QueryList.prototype, "changes", {
      get: function() {
        return this._emitter;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryList.prototype, "length", {
      get: function() {
        return this._results.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryList.prototype, "first", {
      get: function() {
        return this._results[0];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryList.prototype, "last", {
      get: function() {
        return this._results[this.length - 1];
      },
      enumerable: true,
      configurable: true
    });
    QueryList.prototype.map = function(fn) {
      return this._results.map(fn);
    };
    QueryList.prototype.filter = function(fn) {
      return this._results.filter(fn);
    };
    QueryList.prototype.find = function(fn) {
      return this._results.find(fn);
    };
    QueryList.prototype.reduce = function(fn, init) {
      return this._results.reduce(fn, init);
    };
    QueryList.prototype.forEach = function(fn) {
      this._results.forEach(fn);
    };
    QueryList.prototype.some = function(fn) {
      return this._results.some(fn);
    };
    QueryList.prototype.toArray = function() {
      return this._results.slice();
    };
    QueryList.prototype[getSymbolIterator()] = function() {
      return ((this._results))[getSymbolIterator()]();
    };
    QueryList.prototype.toString = function() {
      return this._results.toString();
    };
    QueryList.prototype.reset = function(res) {
      this._results = flatten(res);
      this._dirty = false;
    };
    QueryList.prototype.notifyOnChanges = function() {
      this._emitter.emit(this);
    };
    QueryList.prototype.setDirty = function() {
      this._dirty = true;
    };
    Object.defineProperty(QueryList.prototype, "dirty", {
      get: function() {
        return this._dirty;
      },
      enumerable: true,
      configurable: true
    });
    return QueryList;
  }());
  function flatten(list) {
    return list.reduce(function(flat, item) {
      var flatItem = Array.isArray(item) ? flatten(item) : item;
      return ((flat)).concat(flatItem);
    }, []);
  }
  var _SEPARATOR = '#';
  var FACTORY_CLASS_SUFFIX = 'NgFactory';
  var SystemJsNgModuleLoaderConfig = (function() {
    function SystemJsNgModuleLoaderConfig() {}
    return SystemJsNgModuleLoaderConfig;
  }());
  var DEFAULT_CONFIG = {
    factoryPathPrefix: '',
    factoryPathSuffix: '.ngfactory'
  };
  var SystemJsNgModuleLoader = (function() {
    function SystemJsNgModuleLoader(_compiler, config) {
      this._compiler = _compiler;
      this._config = config || DEFAULT_CONFIG;
    }
    SystemJsNgModuleLoader.prototype.load = function(path) {
      var offlineMode = this._compiler instanceof Compiler;
      return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
    };
    SystemJsNgModuleLoader.prototype.loadAndCompile = function(path) {
      var _this = this;
      var _a = path.split(_SEPARATOR),
          module = _a[0],
          exportName = _a[1];
      if (exportName === undefined) {
        exportName = 'default';
      }
      return System.import(module).then(function(module) {
        return module[exportName];
      }).then(function(type) {
        return checkNotEmpty(type, module, exportName);
      }).then(function(type) {
        return _this._compiler.compileModuleAsync(type);
      });
    };
    SystemJsNgModuleLoader.prototype.loadFactory = function(path) {
      var _a = path.split(_SEPARATOR),
          module = _a[0],
          exportName = _a[1];
      var factoryClassSuffix = FACTORY_CLASS_SUFFIX;
      if (exportName === undefined) {
        exportName = 'default';
        factoryClassSuffix = '';
      }
      return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix).then(function(module) {
        return module[exportName + factoryClassSuffix];
      }).then(function(factory) {
        return checkNotEmpty(factory, module, exportName);
      });
    };
    return SystemJsNgModuleLoader;
  }());
  SystemJsNgModuleLoader.decorators = [{type: Injectable}];
  SystemJsNgModuleLoader.ctorParameters = function() {
    return [{type: Compiler}, {
      type: SystemJsNgModuleLoaderConfig,
      decorators: [{type: Optional}]
    }];
  };
  function checkNotEmpty(value, modulePath, exportName) {
    if (!value) {
      throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
    }
    return value;
  }
  var TemplateRef = (function() {
    function TemplateRef() {}
    TemplateRef.prototype.elementRef = function() {};
    TemplateRef.prototype.createEmbeddedView = function(context) {};
    return TemplateRef;
  }());
  var ViewContainerRef = (function() {
    function ViewContainerRef() {}
    ViewContainerRef.prototype.element = function() {};
    ViewContainerRef.prototype.injector = function() {};
    ViewContainerRef.prototype.parentInjector = function() {};
    ViewContainerRef.prototype.clear = function() {};
    ViewContainerRef.prototype.get = function(index) {};
    ViewContainerRef.prototype.length = function() {};
    ViewContainerRef.prototype.createEmbeddedView = function(templateRef, context, index) {};
    ViewContainerRef.prototype.createComponent = function(componentFactory, index, injector, projectableNodes, ngModule) {};
    ViewContainerRef.prototype.insert = function(viewRef, index) {};
    ViewContainerRef.prototype.move = function(viewRef, currentIndex) {};
    ViewContainerRef.prototype.indexOf = function(viewRef) {};
    ViewContainerRef.prototype.remove = function(index) {};
    ViewContainerRef.prototype.detach = function(index) {};
    return ViewContainerRef;
  }());
  var ChangeDetectorRef = (function() {
    function ChangeDetectorRef() {}
    ChangeDetectorRef.prototype.markForCheck = function() {};
    ChangeDetectorRef.prototype.detach = function() {};
    ChangeDetectorRef.prototype.detectChanges = function() {};
    ChangeDetectorRef.prototype.checkNoChanges = function() {};
    ChangeDetectorRef.prototype.reattach = function() {};
    return ChangeDetectorRef;
  }());
  var ViewRef = (function(_super) {
    __extends(ViewRef, _super);
    function ViewRef() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ViewRef.prototype.destroy = function() {};
    ViewRef.prototype.destroyed = function() {};
    ViewRef.prototype.onDestroy = function(callback) {};
    return ViewRef;
  }(ChangeDetectorRef));
  var EmbeddedViewRef = (function(_super) {
    __extends(EmbeddedViewRef, _super);
    function EmbeddedViewRef() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    EmbeddedViewRef.prototype.context = function() {};
    EmbeddedViewRef.prototype.rootNodes = function() {};
    return EmbeddedViewRef;
  }(ViewRef));
  var EventListener = (function() {
    function EventListener(name, callback) {
      this.name = name;
      this.callback = callback;
    }
    return EventListener;
  }());
  var DebugNode = (function() {
    function DebugNode(nativeNode, parent, _debugContext) {
      this._debugContext = _debugContext;
      this.nativeNode = nativeNode;
      if (parent && parent instanceof DebugElement) {
        parent.addChild(this);
      } else {
        this.parent = null;
      }
      this.listeners = [];
    }
    Object.defineProperty(DebugNode.prototype, "injector", {
      get: function() {
        return this._debugContext.injector;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "componentInstance", {
      get: function() {
        return this._debugContext.component;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "context", {
      get: function() {
        return this._debugContext.context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "references", {
      get: function() {
        return this._debugContext.references;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "providerTokens", {
      get: function() {
        return this._debugContext.providerTokens;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "source", {
      get: function() {
        return 'Deprecated since v4';
      },
      enumerable: true,
      configurable: true
    });
    return DebugNode;
  }());
  var DebugElement = (function(_super) {
    __extends(DebugElement, _super);
    function DebugElement(nativeNode, parent, _debugContext) {
      var _this = _super.call(this, nativeNode, parent, _debugContext) || this;
      _this.properties = {};
      _this.attributes = {};
      _this.classes = {};
      _this.styles = {};
      _this.childNodes = [];
      _this.nativeElement = nativeNode;
      return _this;
    }
    DebugElement.prototype.addChild = function(child) {
      if (child) {
        this.childNodes.push(child);
        child.parent = this;
      }
    };
    DebugElement.prototype.removeChild = function(child) {
      var childIndex = this.childNodes.indexOf(child);
      if (childIndex !== -1) {
        child.parent = null;
        this.childNodes.splice(childIndex, 1);
      }
    };
    DebugElement.prototype.insertChildrenAfter = function(child, newChildren) {
      var _this = this;
      var siblingIndex = this.childNodes.indexOf(child);
      if (siblingIndex !== -1) {
        (_a = this.childNodes).splice.apply(_a, [siblingIndex + 1, 0].concat(newChildren));
        newChildren.forEach(function(c) {
          if (c.parent) {
            c.parent.removeChild(c);
          }
          c.parent = _this;
        });
      }
      var _a;
    };
    DebugElement.prototype.insertBefore = function(refChild, newChild) {
      var refIndex = this.childNodes.indexOf(refChild);
      if (refIndex === -1) {
        this.addChild(newChild);
      } else {
        if (newChild.parent) {
          newChild.parent.removeChild(newChild);
        }
        newChild.parent = this;
        this.childNodes.splice(refIndex, 0, newChild);
      }
    };
    DebugElement.prototype.query = function(predicate) {
      var results = this.queryAll(predicate);
      return results[0] || null;
    };
    DebugElement.prototype.queryAll = function(predicate) {
      var matches = [];
      _queryElementChildren(this, predicate, matches);
      return matches;
    };
    DebugElement.prototype.queryAllNodes = function(predicate) {
      var matches = [];
      _queryNodeChildren(this, predicate, matches);
      return matches;
    };
    Object.defineProperty(DebugElement.prototype, "children", {
      get: function() {
        return (this.childNodes.filter(function(node) {
          return node instanceof DebugElement;
        }));
      },
      enumerable: true,
      configurable: true
    });
    DebugElement.prototype.triggerEventHandler = function(eventName, eventObj) {
      this.listeners.forEach(function(listener) {
        if (listener.name == eventName) {
          listener.callback(eventObj);
        }
      });
    };
    return DebugElement;
  }(DebugNode));
  function asNativeElements(debugEls) {
    return debugEls.map(function(el) {
      return el.nativeElement;
    });
  }
  function _queryElementChildren(element, predicate, matches) {
    element.childNodes.forEach(function(node) {
      if (node instanceof DebugElement) {
        if (predicate(node)) {
          matches.push(node);
        }
        _queryElementChildren(node, predicate, matches);
      }
    });
  }
  function _queryNodeChildren(parentNode, predicate, matches) {
    if (parentNode instanceof DebugElement) {
      parentNode.childNodes.forEach(function(node) {
        if (predicate(node)) {
          matches.push(node);
        }
        if (node instanceof DebugElement) {
          _queryNodeChildren(node, predicate, matches);
        }
      });
    }
  }
  var _nativeNodeToDebugNode = new Map();
  function getDebugNode(nativeNode) {
    return _nativeNodeToDebugNode.get(nativeNode) || null;
  }
  function indexDebugNode(node) {
    _nativeNodeToDebugNode.set(node.nativeNode, node);
  }
  function removeDebugNodeFromIndex(node) {
    _nativeNodeToDebugNode.delete(node.nativeNode);
  }
  function devModeEqual(a, b) {
    var isListLikeIterableA = isListLikeIterable(a);
    var isListLikeIterableB = isListLikeIterable(b);
    if (isListLikeIterableA && isListLikeIterableB) {
      return areIterablesEqual(a, b, devModeEqual);
    } else {
      var isAObject = a && (typeof a === 'object' || typeof a === 'function');
      var isBObject = b && (typeof b === 'object' || typeof b === 'function');
      if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
        return true;
      } else {
        return looseIdentical(a, b);
      }
    }
  }
  var WrappedValue = (function() {
    function WrappedValue(wrapped) {
      this.wrapped = wrapped;
    }
    WrappedValue.wrap = function(value) {
      return new WrappedValue(value);
    };
    return WrappedValue;
  }());
  var ValueUnwrapper = (function() {
    function ValueUnwrapper() {
      this.hasWrappedValue = false;
    }
    ValueUnwrapper.prototype.unwrap = function(value) {
      if (value instanceof WrappedValue) {
        this.hasWrappedValue = true;
        return value.wrapped;
      }
      return value;
    };
    ValueUnwrapper.prototype.reset = function() {
      this.hasWrappedValue = false;
    };
    return ValueUnwrapper;
  }());
  var SimpleChange = (function() {
    function SimpleChange(previousValue, currentValue, firstChange) {
      this.previousValue = previousValue;
      this.currentValue = currentValue;
      this.firstChange = firstChange;
    }
    SimpleChange.prototype.isFirstChange = function() {
      return this.firstChange;
    };
    return SimpleChange;
  }());
  function isListLikeIterable(obj) {
    if (!isJsObject(obj))
      return false;
    return Array.isArray(obj) || (!(obj instanceof Map) && getSymbolIterator() in obj);
  }
  function areIterablesEqual(a, b, comparator) {
    var iterator1 = a[getSymbolIterator()]();
    var iterator2 = b[getSymbolIterator()]();
    while (true) {
      var item1 = iterator1.next();
      var item2 = iterator2.next();
      if (item1.done && item2.done)
        return true;
      if (item1.done || item2.done)
        return false;
      if (!comparator(item1.value, item2.value))
        return false;
    }
  }
  function iterateListLike(obj, fn) {
    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      var iterator = obj[getSymbolIterator()]();
      var item = void 0;
      while (!((item = iterator.next()).done)) {
        fn(item.value);
      }
    }
  }
  function isJsObject(o) {
    return o !== null && (typeof o === 'function' || typeof o === 'object');
  }
  var DefaultIterableDifferFactory = (function() {
    function DefaultIterableDifferFactory() {}
    DefaultIterableDifferFactory.prototype.supports = function(obj) {
      return isListLikeIterable(obj);
    };
    DefaultIterableDifferFactory.prototype.create = function(cdRefOrTrackBy, trackByFn) {
      return new DefaultIterableDiffer(trackByFn || (cdRefOrTrackBy));
    };
    return DefaultIterableDifferFactory;
  }());
  var trackByIdentity = function(index, item) {
    return item;
  };
  var DefaultIterableDiffer = (function() {
    function DefaultIterableDiffer(trackByFn) {
      this._length = 0;
      this._collection = null;
      this._linkedRecords = null;
      this._unlinkedRecords = null;
      this._previousItHead = null;
      this._itHead = null;
      this._itTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._movesHead = null;
      this._movesTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
      this._identityChangesHead = null;
      this._identityChangesTail = null;
      this._trackByFn = trackByFn || trackByIdentity;
    }
    Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
      get: function() {
        return this._collection;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
      get: function() {
        return this._length;
      },
      enumerable: true,
      configurable: true
    });
    DefaultIterableDiffer.prototype.forEachItem = function(fn) {
      var record;
      for (record = this._itHead; record !== null; record = record._next) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachOperation = function(fn) {
      var nextIt = this._itHead;
      var nextRemove = this._removalsHead;
      var addRemoveOffset = 0;
      var moveOffsets = null;
      while (nextIt || nextRemove) {
        var record = !nextRemove || nextIt && ((nextIt.currentIndex)) < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? ((nextIt)) : nextRemove;
        var adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
        var currentIndex = record.currentIndex;
        if (record === nextRemove) {
          addRemoveOffset--;
          nextRemove = nextRemove._nextRemoved;
        } else {
          nextIt = ((nextIt))._next;
          if (record.previousIndex == null) {
            addRemoveOffset++;
          } else {
            if (!moveOffsets)
              moveOffsets = [];
            var localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
            var localCurrentIndex = ((currentIndex)) - addRemoveOffset;
            if (localMovePreviousIndex != localCurrentIndex) {
              for (var i = 0; i < localMovePreviousIndex; i++) {
                var offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
                var index = offset + i;
                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                  moveOffsets[i] = offset + 1;
                }
              }
              var previousIndex = record.previousIndex;
              moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
            }
          }
        }
        if (adjPreviousIndex !== currentIndex) {
          fn(record, adjPreviousIndex, currentIndex);
        }
      }
    };
    DefaultIterableDiffer.prototype.forEachPreviousItem = function(fn) {
      var record;
      for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachAddedItem = function(fn) {
      var record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachMovedItem = function(fn) {
      var record;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachRemovedItem = function(fn) {
      var record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachIdentityChange = function(fn) {
      var record;
      for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.diff = function(collection) {
      if (collection == null)
        collection = [];
      if (!isListLikeIterable(collection)) {
        throw new Error("Error trying to diff '" + stringify(collection) + "'. Only arrays and iterables are allowed");
      }
      if (this.check(collection)) {
        return this;
      } else {
        return null;
      }
    };
    DefaultIterableDiffer.prototype.onDestroy = function() {};
    DefaultIterableDiffer.prototype.check = function(collection) {
      var _this = this;
      this._reset();
      var record = this._itHead;
      var mayBeDirty = false;
      var index;
      var item;
      var itemTrackBy;
      if (Array.isArray(collection)) {
        this._length = collection.length;
        for (var index_1 = 0; index_1 < this._length; index_1++) {
          item = collection[index_1];
          itemTrackBy = this._trackByFn(index_1, item);
          if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
            record = this._mismatch(record, item, itemTrackBy, index_1);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = this._verifyReinsertion(record, item, itemTrackBy, index_1);
            }
            if (!looseIdentical(record.item, item))
              this._addIdentityChange(record, item);
          }
          record = record._next;
        }
      } else {
        index = 0;
        iterateListLike(collection, function(item) {
          itemTrackBy = _this._trackByFn(index, item);
          if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
            record = _this._mismatch(record, item, itemTrackBy, index);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = _this._verifyReinsertion(record, item, itemTrackBy, index);
            }
            if (!looseIdentical(record.item, item))
              _this._addIdentityChange(record, item);
          }
          record = record._next;
          index++;
        });
        this._length = index;
      }
      this._truncate(record);
      this._collection = collection;
      return this.isDirty;
    };
    Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
      get: function() {
        return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
      },
      enumerable: true,
      configurable: true
    });
    DefaultIterableDiffer.prototype._reset = function() {
      if (this.isDirty) {
        var record = void 0;
        var nextRecord = void 0;
        for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          record.previousIndex = record.currentIndex;
        }
        this._additionsHead = this._additionsTail = null;
        for (record = this._movesHead; record !== null; record = nextRecord) {
          record.previousIndex = record.currentIndex;
          nextRecord = record._nextMoved;
        }
        this._movesHead = this._movesTail = null;
        this._removalsHead = this._removalsTail = null;
        this._identityChangesHead = this._identityChangesTail = null;
      }
    };
    DefaultIterableDiffer.prototype._mismatch = function(record, item, itemTrackBy, index) {
      var previousRecord;
      if (record === null) {
        previousRecord = this._itTail;
      } else {
        previousRecord = record._prev;
        this._remove(record);
      }
      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
      if (record !== null) {
        if (!looseIdentical(record.item, item))
          this._addIdentityChange(record, item);
        this._moveAfter(record, previousRecord, index);
      } else {
        record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (record !== null) {
          if (!looseIdentical(record.item, item))
            this._addIdentityChange(record, item);
          this._reinsertAfter(record, previousRecord, index);
        } else {
          record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
        }
      }
      return record;
    };
    DefaultIterableDiffer.prototype._verifyReinsertion = function(record, item, itemTrackBy, index) {
      var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
      if (reinsertRecord !== null) {
        record = this._reinsertAfter(reinsertRecord, ((record._prev)), index);
      } else if (record.currentIndex != index) {
        record.currentIndex = index;
        this._addToMoves(record, index);
      }
      return record;
    };
    DefaultIterableDiffer.prototype._truncate = function(record) {
      while (record !== null) {
        var nextRecord = record._next;
        this._addToRemovals(this._unlink(record));
        record = nextRecord;
      }
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.clear();
      }
      if (this._additionsTail !== null) {
        this._additionsTail._nextAdded = null;
      }
      if (this._movesTail !== null) {
        this._movesTail._nextMoved = null;
      }
      if (this._itTail !== null) {
        this._itTail._next = null;
      }
      if (this._removalsTail !== null) {
        this._removalsTail._nextRemoved = null;
      }
      if (this._identityChangesTail !== null) {
        this._identityChangesTail._nextIdentityChange = null;
      }
    };
    DefaultIterableDiffer.prototype._reinsertAfter = function(record, prevRecord, index) {
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.remove(record);
      }
      var prev = record._prevRemoved;
      var next = record._nextRemoved;
      if (prev === null) {
        this._removalsHead = next;
      } else {
        prev._nextRemoved = next;
      }
      if (next === null) {
        this._removalsTail = prev;
      } else {
        next._prevRemoved = prev;
      }
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    };
    DefaultIterableDiffer.prototype._moveAfter = function(record, prevRecord, index) {
      this._unlink(record);
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    };
    DefaultIterableDiffer.prototype._addAfter = function(record, prevRecord, index) {
      this._insertAfter(record, prevRecord, index);
      if (this._additionsTail === null) {
        this._additionsTail = this._additionsHead = record;
      } else {
        this._additionsTail = this._additionsTail._nextAdded = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._insertAfter = function(record, prevRecord, index) {
      var next = prevRecord === null ? this._itHead : prevRecord._next;
      record._next = next;
      record._prev = prevRecord;
      if (next === null) {
        this._itTail = record;
      } else {
        next._prev = record;
      }
      if (prevRecord === null) {
        this._itHead = record;
      } else {
        prevRecord._next = record;
      }
      if (this._linkedRecords === null) {
        this._linkedRecords = new _DuplicateMap();
      }
      this._linkedRecords.put(record);
      record.currentIndex = index;
      return record;
    };
    DefaultIterableDiffer.prototype._remove = function(record) {
      return this._addToRemovals(this._unlink(record));
    };
    DefaultIterableDiffer.prototype._unlink = function(record) {
      if (this._linkedRecords !== null) {
        this._linkedRecords.remove(record);
      }
      var prev = record._prev;
      var next = record._next;
      if (prev === null) {
        this._itHead = next;
      } else {
        prev._next = next;
      }
      if (next === null) {
        this._itTail = prev;
      } else {
        next._prev = prev;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._addToMoves = function(record, toIndex) {
      if (record.previousIndex === toIndex) {
        return record;
      }
      if (this._movesTail === null) {
        this._movesTail = this._movesHead = record;
      } else {
        this._movesTail = this._movesTail._nextMoved = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._addToRemovals = function(record) {
      if (this._unlinkedRecords === null) {
        this._unlinkedRecords = new _DuplicateMap();
      }
      this._unlinkedRecords.put(record);
      record.currentIndex = null;
      record._nextRemoved = null;
      if (this._removalsTail === null) {
        this._removalsTail = this._removalsHead = record;
        record._prevRemoved = null;
      } else {
        record._prevRemoved = this._removalsTail;
        this._removalsTail = this._removalsTail._nextRemoved = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._addIdentityChange = function(record, item) {
      record.item = item;
      if (this._identityChangesTail === null) {
        this._identityChangesTail = this._identityChangesHead = record;
      } else {
        this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype.toString = function() {
      var list = [];
      this.forEachItem(function(record) {
        return list.push(record);
      });
      var previous = [];
      this.forEachPreviousItem(function(record) {
        return previous.push(record);
      });
      var additions = [];
      this.forEachAddedItem(function(record) {
        return additions.push(record);
      });
      var moves = [];
      this.forEachMovedItem(function(record) {
        return moves.push(record);
      });
      var removals = [];
      this.forEachRemovedItem(function(record) {
        return removals.push(record);
      });
      var identityChanges = [];
      this.forEachIdentityChange(function(record) {
        return identityChanges.push(record);
      });
      return 'collection: ' + list.join(', ') + '\n' + 'previous: ' + previous.join(', ') + '\n' + 'additions: ' + additions.join(', ') + '\n' + 'moves: ' + moves.join(', ') + '\n' + 'removals: ' + removals.join(', ') + '\n' + 'identityChanges: ' + identityChanges.join(', ') + '\n';
    };
    return DefaultIterableDiffer;
  }());
  var IterableChangeRecord_ = (function() {
    function IterableChangeRecord_(item, trackById) {
      this.item = item;
      this.trackById = trackById;
      this.currentIndex = null;
      this.previousIndex = null;
      this._nextPrevious = null;
      this._prev = null;
      this._next = null;
      this._prevDup = null;
      this._nextDup = null;
      this._prevRemoved = null;
      this._nextRemoved = null;
      this._nextAdded = null;
      this._nextMoved = null;
      this._nextIdentityChange = null;
    }
    IterableChangeRecord_.prototype.toString = function() {
      return this.previousIndex === this.currentIndex ? stringify(this.item) : stringify(this.item) + '[' + stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
    };
    return IterableChangeRecord_;
  }());
  var _DuplicateItemRecordList = (function() {
    function _DuplicateItemRecordList() {
      this._head = null;
      this._tail = null;
    }
    _DuplicateItemRecordList.prototype.add = function(record) {
      if (this._head === null) {
        this._head = this._tail = record;
        record._nextDup = null;
        record._prevDup = null;
      } else {
        ((this._tail))._nextDup = record;
        record._prevDup = this._tail;
        record._nextDup = null;
        this._tail = record;
      }
    };
    _DuplicateItemRecordList.prototype.get = function(trackById, atOrAfterIndex) {
      var record;
      for (record = this._head; record !== null; record = record._nextDup) {
        if ((atOrAfterIndex === null || atOrAfterIndex <= ((record.currentIndex))) && looseIdentical(record.trackById, trackById)) {
          return record;
        }
      }
      return null;
    };
    _DuplicateItemRecordList.prototype.remove = function(record) {
      var prev = record._prevDup;
      var next = record._nextDup;
      if (prev === null) {
        this._head = next;
      } else {
        prev._nextDup = next;
      }
      if (next === null) {
        this._tail = prev;
      } else {
        next._prevDup = prev;
      }
      return this._head === null;
    };
    return _DuplicateItemRecordList;
  }());
  var _DuplicateMap = (function() {
    function _DuplicateMap() {
      this.map = new Map();
    }
    _DuplicateMap.prototype.put = function(record) {
      var key = record.trackById;
      var duplicates = this.map.get(key);
      if (!duplicates) {
        duplicates = new _DuplicateItemRecordList();
        this.map.set(key, duplicates);
      }
      duplicates.add(record);
    };
    _DuplicateMap.prototype.get = function(trackById, atOrAfterIndex) {
      var key = trackById;
      var recordList = this.map.get(key);
      return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
    };
    _DuplicateMap.prototype.remove = function(record) {
      var key = record.trackById;
      var recordList = ((this.map.get(key)));
      if (recordList.remove(record)) {
        this.map.delete(key);
      }
      return record;
    };
    Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
      get: function() {
        return this.map.size === 0;
      },
      enumerable: true,
      configurable: true
    });
    _DuplicateMap.prototype.clear = function() {
      this.map.clear();
    };
    _DuplicateMap.prototype.toString = function() {
      return '_DuplicateMap(' + stringify(this.map) + ')';
    };
    return _DuplicateMap;
  }());
  function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
    var previousIndex = item.previousIndex;
    if (previousIndex === null)
      return previousIndex;
    var moveOffset = 0;
    if (moveOffsets && previousIndex < moveOffsets.length) {
      moveOffset = moveOffsets[previousIndex];
    }
    return previousIndex + addRemoveOffset + moveOffset;
  }
  var DefaultKeyValueDifferFactory = (function() {
    function DefaultKeyValueDifferFactory() {}
    DefaultKeyValueDifferFactory.prototype.supports = function(obj) {
      return obj instanceof Map || isJsObject(obj);
    };
    DefaultKeyValueDifferFactory.prototype.create = function(cd) {
      return new DefaultKeyValueDiffer();
    };
    return DefaultKeyValueDifferFactory;
  }());
  var DefaultKeyValueDiffer = (function() {
    function DefaultKeyValueDiffer() {
      this._records = new Map();
      this._mapHead = null;
      this._appendAfter = null;
      this._previousMapHead = null;
      this._changesHead = null;
      this._changesTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
    }
    Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
      get: function() {
        return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
      },
      enumerable: true,
      configurable: true
    });
    DefaultKeyValueDiffer.prototype.forEachItem = function(fn) {
      var record;
      for (record = this._mapHead; record !== null; record = record._next) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function(fn) {
      var record;
      for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachChangedItem = function(fn) {
      var record;
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachAddedItem = function(fn) {
      var record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function(fn) {
      var record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.diff = function(map) {
      if (!map) {
        map = new Map();
      } else if (!(map instanceof Map || isJsObject(map))) {
        throw new Error("Error trying to diff '" + stringify(map) + "'. Only maps and objects are allowed");
      }
      return this.check(map) ? this : null;
    };
    DefaultKeyValueDiffer.prototype.onDestroy = function() {};
    DefaultKeyValueDiffer.prototype.check = function(map) {
      var _this = this;
      this._reset();
      var insertBefore = this._mapHead;
      this._appendAfter = null;
      this._forEach(map, function(value, key) {
        if (insertBefore && insertBefore.key === key) {
          _this._maybeAddToChanges(insertBefore, value);
          _this._appendAfter = insertBefore;
          insertBefore = insertBefore._next;
        } else {
          var record = _this._getOrCreateRecordForKey(key, value);
          insertBefore = _this._insertBeforeOrAppend(insertBefore, record);
        }
      });
      if (insertBefore) {
        if (insertBefore._prev) {
          insertBefore._prev._next = null;
        }
        this._removalsHead = insertBefore;
        for (var record = insertBefore; record !== null; record = record._nextRemoved) {
          if (record === this._mapHead) {
            this._mapHead = null;
          }
          this._records.delete(record.key);
          record._nextRemoved = record._next;
          record.previousValue = record.currentValue;
          record.currentValue = null;
          record._prev = null;
          record._next = null;
        }
      }
      if (this._changesTail)
        this._changesTail._nextChanged = null;
      if (this._additionsTail)
        this._additionsTail._nextAdded = null;
      return this.isDirty;
    };
    DefaultKeyValueDiffer.prototype._insertBeforeOrAppend = function(before, record) {
      if (before) {
        var prev = before._prev;
        record._next = before;
        record._prev = prev;
        before._prev = record;
        if (prev) {
          prev._next = record;
        }
        if (before === this._mapHead) {
          this._mapHead = record;
        }
        this._appendAfter = before;
        return before;
      }
      if (this._appendAfter) {
        this._appendAfter._next = record;
        record._prev = this._appendAfter;
      } else {
        this._mapHead = record;
      }
      this._appendAfter = record;
      return null;
    };
    DefaultKeyValueDiffer.prototype._getOrCreateRecordForKey = function(key, value) {
      if (this._records.has(key)) {
        var record_1 = ((this._records.get(key)));
        this._maybeAddToChanges(record_1, value);
        var prev = record_1._prev;
        var next = record_1._next;
        if (prev) {
          prev._next = next;
        }
        if (next) {
          next._prev = prev;
        }
        record_1._next = null;
        record_1._prev = null;
        return record_1;
      }
      var record = new KeyValueChangeRecord_(key);
      this._records.set(key, record);
      record.currentValue = value;
      this._addToAdditions(record);
      return record;
    };
    DefaultKeyValueDiffer.prototype._reset = function() {
      if (this.isDirty) {
        var record = void 0;
        this._previousMapHead = this._mapHead;
        for (record = this._previousMapHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
          record.previousValue = record.currentValue;
        }
        for (record = this._additionsHead; record != null; record = record._nextAdded) {
          record.previousValue = record.currentValue;
        }
        this._changesHead = this._changesTail = null;
        this._additionsHead = this._additionsTail = null;
        this._removalsHead = null;
      }
    };
    DefaultKeyValueDiffer.prototype._maybeAddToChanges = function(record, newValue) {
      if (!looseIdentical(newValue, record.currentValue)) {
        record.previousValue = record.currentValue;
        record.currentValue = newValue;
        this._addToChanges(record);
      }
    };
    DefaultKeyValueDiffer.prototype._addToAdditions = function(record) {
      if (this._additionsHead === null) {
        this._additionsHead = this._additionsTail = record;
      } else {
        ((this._additionsTail))._nextAdded = record;
        this._additionsTail = record;
      }
    };
    DefaultKeyValueDiffer.prototype._addToChanges = function(record) {
      if (this._changesHead === null) {
        this._changesHead = this._changesTail = record;
      } else {
        ((this._changesTail))._nextChanged = record;
        this._changesTail = record;
      }
    };
    DefaultKeyValueDiffer.prototype._forEach = function(obj, fn) {
      if (obj instanceof Map) {
        obj.forEach(fn);
      } else {
        Object.keys(obj).forEach(function(k) {
          return fn(obj[k], k);
        });
      }
    };
    return DefaultKeyValueDiffer;
  }());
  var KeyValueChangeRecord_ = (function() {
    function KeyValueChangeRecord_(key) {
      this.key = key;
      this.previousValue = null;
      this.currentValue = null;
      this._nextPrevious = null;
      this._next = null;
      this._prev = null;
      this._nextAdded = null;
      this._nextRemoved = null;
      this._nextChanged = null;
    }
    return KeyValueChangeRecord_;
  }());
  var IterableDiffers = (function() {
    function IterableDiffers(factories) {
      this.factories = factories;
    }
    IterableDiffers.create = function(factories, parent) {
      if (parent != null) {
        var copied = parent.factories.slice();
        factories = factories.concat(copied);
        return new IterableDiffers(factories);
      } else {
        return new IterableDiffers(factories);
      }
    };
    IterableDiffers.extend = function(factories) {
      return {
        provide: IterableDiffers,
        useFactory: function(parent) {
          if (!parent) {
            throw new Error('Cannot extend IterableDiffers without a parent injector');
          }
          return IterableDiffers.create(factories, parent);
        },
        deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
      };
    };
    IterableDiffers.prototype.find = function(iterable) {
      var factory = this.factories.find(function(f) {
        return f.supports(iterable);
      });
      if (factory != null) {
        return factory;
      } else {
        throw new Error("Cannot find a differ supporting object '" + iterable + "' of type '" + getTypeNameForDebugging(iterable) + "'");
      }
    };
    return IterableDiffers;
  }());
  function getTypeNameForDebugging(type) {
    return type['name'] || typeof type;
  }
  var KeyValueDiffers = (function() {
    function KeyValueDiffers(factories) {
      this.factories = factories;
    }
    KeyValueDiffers.create = function(factories, parent) {
      if (parent) {
        var copied = parent.factories.slice();
        factories = factories.concat(copied);
      }
      return new KeyValueDiffers(factories);
    };
    KeyValueDiffers.extend = function(factories) {
      return {
        provide: KeyValueDiffers,
        useFactory: function(parent) {
          if (!parent) {
            throw new Error('Cannot extend KeyValueDiffers without a parent injector');
          }
          return KeyValueDiffers.create(factories, parent);
        },
        deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
      };
    };
    KeyValueDiffers.prototype.find = function(kv) {
      var factory = this.factories.find(function(f) {
        return f.supports(kv);
      });
      if (factory) {
        return factory;
      }
      throw new Error("Cannot find a differ supporting object '" + kv + "'");
    };
    return KeyValueDiffers;
  }());
  var keyValDiff = [new DefaultKeyValueDifferFactory()];
  var iterableDiff = [new DefaultIterableDifferFactory()];
  var defaultIterableDiffers = new IterableDiffers(iterableDiff);
  var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
  function _reflector() {
    return reflector;
  }
  var _CORE_PLATFORM_PROVIDERS = [{
    provide: PLATFORM_ID,
    useValue: 'unknown'
  }, PlatformRef_, {
    provide: PlatformRef,
    useExisting: PlatformRef_
  }, {
    provide: Reflector,
    useFactory: _reflector,
    deps: []
  }, TestabilityRegistry, Console];
  var platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);
  var LOCALE_ID = new InjectionToken('LocaleId');
  var TRANSLATIONS = new InjectionToken('Translations');
  var TRANSLATIONS_FORMAT = new InjectionToken('TranslationsFormat');
  var MissingTranslationStrategy = {};
  MissingTranslationStrategy.Error = 0;
  MissingTranslationStrategy.Warning = 1;
  MissingTranslationStrategy.Ignore = 2;
  MissingTranslationStrategy[MissingTranslationStrategy.Error] = "Error";
  MissingTranslationStrategy[MissingTranslationStrategy.Warning] = "Warning";
  MissingTranslationStrategy[MissingTranslationStrategy.Ignore] = "Ignore";
  function _iterableDiffersFactory() {
    return defaultIterableDiffers;
  }
  function _keyValueDiffersFactory() {
    return defaultKeyValueDiffers;
  }
  function _localeFactory(locale) {
    return locale || 'en-US';
  }
  var ApplicationModule = (function() {
    function ApplicationModule(appRef) {}
    return ApplicationModule;
  }());
  ApplicationModule.decorators = [{
    type: NgModule,
    args: [{providers: [ApplicationRef_, {
        provide: ApplicationRef,
        useExisting: ApplicationRef_
      }, ApplicationInitStatus, Compiler, APP_ID_RANDOM_PROVIDER, {
        provide: IterableDiffers,
        useFactory: _iterableDiffersFactory
      }, {
        provide: KeyValueDiffers,
        useFactory: _keyValueDiffersFactory
      }, {
        provide: LOCALE_ID,
        useFactory: _localeFactory,
        deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]
      }]}]
  }];
  ApplicationModule.ctorParameters = function() {
    return [{type: ApplicationRef}];
  };
  var SecurityContext = {};
  SecurityContext.NONE = 0;
  SecurityContext.HTML = 1;
  SecurityContext.STYLE = 2;
  SecurityContext.SCRIPT = 3;
  SecurityContext.URL = 4;
  SecurityContext.RESOURCE_URL = 5;
  SecurityContext[SecurityContext.NONE] = "NONE";
  SecurityContext[SecurityContext.HTML] = "HTML";
  SecurityContext[SecurityContext.STYLE] = "STYLE";
  SecurityContext[SecurityContext.SCRIPT] = "SCRIPT";
  SecurityContext[SecurityContext.URL] = "URL";
  SecurityContext[SecurityContext.RESOURCE_URL] = "RESOURCE_URL";
  var Sanitizer = (function() {
    function Sanitizer() {}
    Sanitizer.prototype.sanitize = function(context, value) {};
    return Sanitizer;
  }());
  function asTextData(view, index) {
    return (view.nodes[index]);
  }
  function asElementData(view, index) {
    return (view.nodes[index]);
  }
  function asProviderData(view, index) {
    return (view.nodes[index]);
  }
  function asPureExpressionData(view, index) {
    return (view.nodes[index]);
  }
  function asQueryList(view, index) {
    return (view.nodes[index]);
  }
  var DebugContext = (function() {
    function DebugContext() {}
    DebugContext.prototype.view = function() {};
    DebugContext.prototype.nodeIndex = function() {};
    DebugContext.prototype.injector = function() {};
    DebugContext.prototype.component = function() {};
    DebugContext.prototype.providerTokens = function() {};
    DebugContext.prototype.references = function() {};
    DebugContext.prototype.context = function() {};
    DebugContext.prototype.componentRenderElement = function() {};
    DebugContext.prototype.renderNode = function() {};
    DebugContext.prototype.logError = function(console) {
      var values = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
      }
    };
    return DebugContext;
  }());
  var Services = {
    setCurrentNode: undefined,
    createRootView: undefined,
    createEmbeddedView: undefined,
    createComponentView: undefined,
    createNgModuleRef: undefined,
    overrideProvider: undefined,
    clearProviderOverrides: undefined,
    checkAndUpdateView: undefined,
    checkNoChangesView: undefined,
    destroyView: undefined,
    resolveDep: undefined,
    createDebugContext: undefined,
    handleEvent: undefined,
    updateDirectives: undefined,
    updateRenderer: undefined,
    dirtyParentQueries: undefined
  };
  function expressionChangedAfterItHasBeenCheckedError(context, oldValue, currValue, isFirstCheck) {
    var msg = "ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '" + oldValue + "'. Current value: '" + currValue + "'.";
    if (isFirstCheck) {
      msg += " It seems like the view has been created after its parent and its children have been dirty checked." + " Has it been created in a change detection hook ?";
    }
    return viewDebugError(msg, context);
  }
  function viewWrappedDebugError(err, context) {
    if (!(err instanceof Error)) {
      err = new Error(err.toString());
    }
    _addDebugContext(err, context);
    return err;
  }
  function viewDebugError(msg, context) {
    var err = new Error(msg);
    _addDebugContext(err, context);
    return err;
  }
  function _addDebugContext(err, context) {
    ((err))[ERROR_DEBUG_CONTEXT] = context;
    ((err))[ERROR_LOGGER] = context.logError.bind(context);
  }
  function isViewDebugError(err) {
    return !!getDebugContext(err);
  }
  function viewDestroyedError(action) {
    return new Error("ViewDestroyedError: Attempt to use a destroyed view: " + action);
  }
  var NOOP = function() {};
  var _tokenKeyCache = new Map();
  function tokenKey(token) {
    var key = _tokenKeyCache.get(token);
    if (!key) {
      key = stringify(token) + '_' + _tokenKeyCache.size;
      _tokenKeyCache.set(token, key);
    }
    return key;
  }
  function unwrapValue(view, nodeIdx, bindingIdx, value) {
    if (value instanceof WrappedValue) {
      value = value.wrapped;
      var globalBindingIdx = view.def.nodes[nodeIdx].bindingIndex + bindingIdx;
      var oldValue = view.oldValues[globalBindingIdx];
      if (oldValue instanceof WrappedValue) {
        oldValue = oldValue.wrapped;
      }
      view.oldValues[globalBindingIdx] = new WrappedValue(oldValue);
    }
    return value;
  }
  var UNDEFINED_RENDERER_TYPE_ID = '$$undefined';
  var EMPTY_RENDERER_TYPE_ID = '$$empty';
  function createRendererType2(values) {
    return {
      id: UNDEFINED_RENDERER_TYPE_ID,
      styles: values.styles,
      encapsulation: values.encapsulation,
      data: values.data
    };
  }
  var _renderCompCount = 0;
  function resolveRendererType2(type) {
    if (type && type.id === UNDEFINED_RENDERER_TYPE_ID) {
      var isFilled = ((type.encapsulation != null && type.encapsulation !== ViewEncapsulation.None) || type.styles.length || Object.keys(type.data).length);
      if (isFilled) {
        type.id = "c" + _renderCompCount++;
      } else {
        type.id = EMPTY_RENDERER_TYPE_ID;
      }
    }
    if (type && type.id === EMPTY_RENDERER_TYPE_ID) {
      type = null;
    }
    return type || null;
  }
  function checkBinding(view, def, bindingIdx, value) {
    var oldValues = view.oldValues;
    if ((view.state & 2) || !looseIdentical(oldValues[def.bindingIndex + bindingIdx], value)) {
      return true;
    }
    return false;
  }
  function checkAndUpdateBinding(view, def, bindingIdx, value) {
    if (checkBinding(view, def, bindingIdx, value)) {
      view.oldValues[def.bindingIndex + bindingIdx] = value;
      return true;
    }
    return false;
  }
  function checkBindingNoChanges(view, def, bindingIdx, value) {
    var oldValue = view.oldValues[def.bindingIndex + bindingIdx];
    if ((view.state & 1) || !devModeEqual(oldValue, value)) {
      throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, def.index), oldValue, value, (view.state & 1) !== 0);
    }
  }
  function markParentViewsForCheck(view) {
    var currView = view;
    while (currView) {
      if (currView.def.flags & 2) {
        currView.state |= 8;
      }
      currView = currView.viewContainerParent || currView.parent;
    }
  }
  function markParentViewsForCheckProjectedViews(view, endView) {
    var currView = view;
    while (currView && currView !== endView) {
      currView.state |= 64;
      currView = currView.viewContainerParent || currView.parent;
    }
  }
  function dispatchEvent(view, nodeIndex, eventName, event) {
    var nodeDef = view.def.nodes[nodeIndex];
    var startView = nodeDef.flags & 33554432 ? asElementData(view, nodeIndex).componentView : view;
    markParentViewsForCheck(startView);
    return Services.handleEvent(view, nodeIndex, eventName, event);
  }
  function declaredViewContainer(view) {
    if (view.parent) {
      var parentView = view.parent;
      return asElementData(parentView, ((view.parentNodeDef)).index);
    }
    return null;
  }
  function viewParentEl(view) {
    var parentView = view.parent;
    if (parentView) {
      return ((view.parentNodeDef)).parent;
    } else {
      return null;
    }
  }
  function renderNode(view, def) {
    switch (def.flags & 201347067) {
      case 1:
        return asElementData(view, def.index).renderElement;
      case 2:
        return asTextData(view, def.index).renderText;
    }
  }
  function elementEventFullName(target, name) {
    return target ? target + ":" + name : name;
  }
  function isComponentView(view) {
    return !!view.parent && !!(((view.parentNodeDef)).flags & 32768);
  }
  function isEmbeddedView(view) {
    return !!view.parent && !(((view.parentNodeDef)).flags & 32768);
  }
  function filterQueryId(queryId) {
    return 1 << (queryId % 32);
  }
  function splitMatchedQueriesDsl(matchedQueriesDsl) {
    var matchedQueries = {};
    var matchedQueryIds = 0;
    var references = {};
    if (matchedQueriesDsl) {
      matchedQueriesDsl.forEach(function(_a) {
        var queryId = _a[0],
            valueType = _a[1];
        if (typeof queryId === 'number') {
          matchedQueries[queryId] = valueType;
          matchedQueryIds |= filterQueryId(queryId);
        } else {
          references[queryId] = valueType;
        }
      });
    }
    return {
      matchedQueries: matchedQueries,
      references: references,
      matchedQueryIds: matchedQueryIds
    };
  }
  function splitDepsDsl(deps) {
    return deps.map(function(value) {
      var token;
      var flags;
      if (Array.isArray(value)) {
        flags = value[0], token = value[1];
      } else {
        flags = 0;
        token = value;
      }
      return {
        flags: flags,
        token: token,
        tokenKey: tokenKey(token)
      };
    });
  }
  function getParentRenderElement(view, renderHost, def) {
    var renderParent = def.renderParent;
    if (renderParent) {
      if ((renderParent.flags & 1) === 0 || (renderParent.flags & 33554432) === 0 || (((renderParent.element)).componentRendererType && ((((renderParent.element)).componentRendererType)).encapsulation === ViewEncapsulation.Native)) {
        return asElementData(view, ((def.renderParent)).index).renderElement;
      }
    } else {
      return renderHost;
    }
  }
  var DEFINITION_CACHE = new WeakMap();
  function resolveDefinition(factory) {
    var value = (((DEFINITION_CACHE.get(factory))));
    if (!value) {
      value = factory(function() {
        return NOOP;
      });
      value.factory = factory;
      DEFINITION_CACHE.set(factory, value);
    }
    return value;
  }
  function rootRenderNodes(view) {
    var renderNodes = [];
    visitRootRenderNodes(view, 0, undefined, undefined, renderNodes);
    return renderNodes;
  }
  function visitRootRenderNodes(view, action, parentNode, nextSibling, target) {
    if (action === 3) {
      parentNode = view.renderer.parentNode(renderNode(view, ((view.def.lastRenderRootNode))));
    }
    visitSiblingRenderNodes(view, action, 0, view.def.nodes.length - 1, parentNode, nextSibling, target);
  }
  function visitSiblingRenderNodes(view, action, startIndex, endIndex, parentNode, nextSibling, target) {
    for (var i = startIndex; i <= endIndex; i++) {
      var nodeDef = view.def.nodes[i];
      if (nodeDef.flags & (1 | 2 | 8)) {
        visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target);
      }
      i += nodeDef.childCount;
    }
  }
  function visitProjectedRenderNodes(view, ngContentIndex, action, parentNode, nextSibling, target) {
    var compView = view;
    while (compView && !isComponentView(compView)) {
      compView = compView.parent;
    }
    var hostView = ((compView)).parent;
    var hostElDef = viewParentEl(((compView)));
    var startIndex = ((hostElDef)).index + 1;
    var endIndex = ((hostElDef)).index + ((hostElDef)).childCount;
    for (var i = startIndex; i <= endIndex; i++) {
      var nodeDef = ((hostView)).def.nodes[i];
      if (nodeDef.ngContentIndex === ngContentIndex) {
        visitRenderNode(((hostView)), nodeDef, action, parentNode, nextSibling, target);
      }
      i += nodeDef.childCount;
    }
    if (!((hostView)).parent) {
      var projectedNodes = view.root.projectableNodes[ngContentIndex];
      if (projectedNodes) {
        for (var i = 0; i < projectedNodes.length; i++) {
          execRenderNodeAction(view, projectedNodes[i], action, parentNode, nextSibling, target);
        }
      }
    }
  }
  function visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target) {
    if (nodeDef.flags & 8) {
      visitProjectedRenderNodes(view, ((nodeDef.ngContent)).index, action, parentNode, nextSibling, target);
    } else {
      var rn = renderNode(view, nodeDef);
      if (action === 3 && (nodeDef.flags & 33554432) && (nodeDef.bindingFlags & 48)) {
        if (nodeDef.bindingFlags & (16)) {
          execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);
        }
        if (nodeDef.bindingFlags & (32)) {
          var compView = asElementData(view, nodeDef.index).componentView;
          execRenderNodeAction(compView, rn, action, parentNode, nextSibling, target);
        }
      } else {
        execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);
      }
      if (nodeDef.flags & 16777216) {
        var embeddedViews = ((asElementData(view, nodeDef.index).viewContainer))._embeddedViews;
        for (var k = 0; k < embeddedViews.length; k++) {
          visitRootRenderNodes(embeddedViews[k], action, parentNode, nextSibling, target);
        }
      }
      if (nodeDef.flags & 1 && !((nodeDef.element)).name) {
        visitSiblingRenderNodes(view, action, nodeDef.index + 1, nodeDef.index + nodeDef.childCount, parentNode, nextSibling, target);
      }
    }
  }
  function execRenderNodeAction(view, renderNode, action, parentNode, nextSibling, target) {
    var renderer = view.renderer;
    switch (action) {
      case 1:
        renderer.appendChild(parentNode, renderNode);
        break;
      case 2:
        renderer.insertBefore(parentNode, renderNode, nextSibling);
        break;
      case 3:
        renderer.removeChild(parentNode, renderNode);
        break;
      case 0:
        ((target)).push(renderNode);
        break;
    }
  }
  var NS_PREFIX_RE = /^:([^:]+):(.+)$/;
  function splitNamespace(name) {
    if (name[0] === ':') {
      var match = ((name.match(NS_PREFIX_RE)));
      return [match[1], match[2]];
    }
    return ['', name];
  }
  function calcBindingFlags(bindings) {
    var flags = 0;
    for (var i = 0; i < bindings.length; i++) {
      flags |= bindings[i].flags;
    }
    return flags;
  }
  function interpolate(valueCount, constAndInterp) {
    var result = '';
    for (var i = 0; i < valueCount * 2; i = i + 2) {
      result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);
    }
    return result + constAndInterp[valueCount * 2];
  }
  function inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
    switch (valueCount) {
      case 1:
        return c0 + _toStringWithNull(a1) + c1;
      case 2:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
      case 3:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3;
      case 4:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4;
      case 5:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
      case 6:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
      case 7:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7;
      case 8:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
      case 9:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
      default:
        throw new Error("Does not support more than 9 expressions");
    }
  }
  function _toStringWithNull(v) {
    return v != null ? v.toString() : '';
  }
  var EMPTY_ARRAY = [];
  var EMPTY_MAP = {};
  function anchorDef(flags, matchedQueriesDsl, ngContentIndex, childCount, handleEvent, templateFactory) {
    flags |= 1;
    var _a = splitMatchedQueriesDsl(matchedQueriesDsl),
        matchedQueries = _a.matchedQueries,
        references = _a.references,
        matchedQueryIds = _a.matchedQueryIds;
    var template = templateFactory ? resolveDefinition(templateFactory) : null;
    return {
      index: -1,
      parent: null,
      renderParent: null,
      bindingIndex: -1,
      outputIndex: -1,
      flags: flags,
      childFlags: 0,
      directChildFlags: 0,
      childMatchedQueries: 0,
      matchedQueries: matchedQueries,
      matchedQueryIds: matchedQueryIds,
      references: references,
      ngContentIndex: ngContentIndex,
      childCount: childCount,
      bindings: [],
      bindingFlags: 0,
      outputs: [],
      element: {
        ns: null,
        name: null,
        attrs: null,
        template: template,
        componentProvider: null,
        componentView: null,
        componentRendererType: null,
        publicProviders: null,
        allProviders: null,
        handleEvent: handleEvent || NOOP
      },
      provider: null,
      text: null,
      query: null,
      ngContent: null
    };
  }
  function elementDef(flags, matchedQueriesDsl, ngContentIndex, childCount, namespaceAndName, fixedAttrs, bindings, outputs, handleEvent, componentView, componentRendererType) {
    if (fixedAttrs === void 0) {
      fixedAttrs = [];
    }
    if (!handleEvent) {
      handleEvent = NOOP;
    }
    var _a = splitMatchedQueriesDsl(matchedQueriesDsl),
        matchedQueries = _a.matchedQueries,
        references = _a.references,
        matchedQueryIds = _a.matchedQueryIds;
    var ns = ((null));
    var name = ((null));
    if (namespaceAndName) {
      _b = splitNamespace(namespaceAndName), ns = _b[0], name = _b[1];
    }
    bindings = bindings || [];
    var bindingDefs = new Array(bindings.length);
    for (var i = 0; i < bindings.length; i++) {
      var _c = bindings[i],
          bindingFlags = _c[0],
          namespaceAndName_1 = _c[1],
          suffixOrSecurityContext = _c[2];
      var _d = splitNamespace(namespaceAndName_1),
          ns_1 = _d[0],
          name_1 = _d[1];
      var securityContext = ((undefined));
      var suffix = ((undefined));
      switch (bindingFlags & 15) {
        case 4:
          suffix = (suffixOrSecurityContext);
          break;
        case 1:
        case 8:
          securityContext = (suffixOrSecurityContext);
          break;
      }
      bindingDefs[i] = {
        flags: bindingFlags,
        ns: ns_1,
        name: name_1,
        nonMinifiedName: name_1,
        securityContext: securityContext,
        suffix: suffix
      };
    }
    outputs = outputs || [];
    var outputDefs = new Array(outputs.length);
    for (var i = 0; i < outputs.length; i++) {
      var _e = outputs[i],
          target = _e[0],
          eventName = _e[1];
      outputDefs[i] = {
        type: 0,
        target: (target),
        eventName: eventName,
        propName: null
      };
    }
    fixedAttrs = fixedAttrs || [];
    var attrs = (fixedAttrs.map(function(_a) {
      var namespaceAndName = _a[0],
          value = _a[1];
      var _b = splitNamespace(namespaceAndName),
          ns = _b[0],
          name = _b[1];
      return [ns, name, value];
    }));
    componentRendererType = resolveRendererType2(componentRendererType);
    if (componentView) {
      flags |= 33554432;
    }
    flags |= 1;
    return {
      index: -1,
      parent: null,
      renderParent: null,
      bindingIndex: -1,
      outputIndex: -1,
      flags: flags,
      childFlags: 0,
      directChildFlags: 0,
      childMatchedQueries: 0,
      matchedQueries: matchedQueries,
      matchedQueryIds: matchedQueryIds,
      references: references,
      ngContentIndex: ngContentIndex,
      childCount: childCount,
      bindings: bindingDefs,
      bindingFlags: calcBindingFlags(bindingDefs),
      outputs: outputDefs,
      element: {
        ns: ns,
        name: name,
        attrs: attrs,
        template: null,
        componentProvider: null,
        componentView: componentView || null,
        componentRendererType: componentRendererType,
        publicProviders: null,
        allProviders: null,
        handleEvent: handleEvent || NOOP
      },
      provider: null,
      text: null,
      query: null,
      ngContent: null
    };
    var _b;
  }
  function createElement(view, renderHost, def) {
    var elDef = ((def.element));
    var rootSelectorOrNode = view.root.selectorOrNode;
    var renderer = view.renderer;
    var el;
    if (view.parent || !rootSelectorOrNode) {
      if (elDef.name) {
        el = renderer.createElement(elDef.name, elDef.ns);
      } else {
        el = renderer.createComment('');
      }
      var parentEl = getParentRenderElement(view, renderHost, def);
      if (parentEl) {
        renderer.appendChild(parentEl, el);
      }
    } else {
      el = renderer.selectRootElement(rootSelectorOrNode);
    }
    if (elDef.attrs) {
      for (var i = 0; i < elDef.attrs.length; i++) {
        var _a = elDef.attrs[i],
            ns = _a[0],
            name = _a[1],
            value = _a[2];
        renderer.setAttribute(el, name, value, ns);
      }
    }
    return el;
  }
  function listenToElementOutputs(view, compView, def, el) {
    for (var i = 0; i < def.outputs.length; i++) {
      var output = def.outputs[i];
      var handleEventClosure = renderEventHandlerClosure(view, def.index, elementEventFullName(output.target, output.eventName));
      var listenTarget = output.target;
      var listenerView = view;
      if (output.target === 'component') {
        listenTarget = null;
        listenerView = compView;
      }
      var disposable = (listenerView.renderer.listen(listenTarget || el, output.eventName, handleEventClosure));
      ((view.disposables))[def.outputIndex + i] = disposable;
    }
  }
  function renderEventHandlerClosure(view, index, eventName) {
    return function(event) {
      try {
        return dispatchEvent(view, index, eventName, event);
      } catch (e) {
        view.root.errorHandler.handleError(e);
      }
    };
  }
  function checkAndUpdateElementInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
    var bindLen = def.bindings.length;
    var changed = false;
    if (bindLen > 0 && checkAndUpdateElementValue(view, def, 0, v0))
      changed = true;
    if (bindLen > 1 && checkAndUpdateElementValue(view, def, 1, v1))
      changed = true;
    if (bindLen > 2 && checkAndUpdateElementValue(view, def, 2, v2))
      changed = true;
    if (bindLen > 3 && checkAndUpdateElementValue(view, def, 3, v3))
      changed = true;
    if (bindLen > 4 && checkAndUpdateElementValue(view, def, 4, v4))
      changed = true;
    if (bindLen > 5 && checkAndUpdateElementValue(view, def, 5, v5))
      changed = true;
    if (bindLen > 6 && checkAndUpdateElementValue(view, def, 6, v6))
      changed = true;
    if (bindLen > 7 && checkAndUpdateElementValue(view, def, 7, v7))
      changed = true;
    if (bindLen > 8 && checkAndUpdateElementValue(view, def, 8, v8))
      changed = true;
    if (bindLen > 9 && checkAndUpdateElementValue(view, def, 9, v9))
      changed = true;
    return changed;
  }
  function checkAndUpdateElementDynamic(view, def, values) {
    var changed = false;
    for (var i = 0; i < values.length; i++) {
      if (checkAndUpdateElementValue(view, def, i, values[i]))
        changed = true;
    }
    return changed;
  }
  function checkAndUpdateElementValue(view, def, bindingIdx, value) {
    if (!checkAndUpdateBinding(view, def, bindingIdx, value)) {
      return false;
    }
    var binding = def.bindings[bindingIdx];
    var elData = asElementData(view, def.index);
    var renderNode$$1 = elData.renderElement;
    var name = ((binding.name));
    switch (binding.flags & 15) {
      case 1:
        setElementAttribute(view, binding, renderNode$$1, binding.ns, name, value);
        break;
      case 2:
        setElementClass(view, renderNode$$1, name, value);
        break;
      case 4:
        setElementStyle(view, binding, renderNode$$1, name, value);
        break;
      case 8:
        var bindView = (def.flags & 33554432 && binding.flags & 32) ? elData.componentView : view;
        setElementProperty(bindView, binding, renderNode$$1, name, value);
        break;
    }
    return true;
  }
  function setElementAttribute(view, binding, renderNode$$1, ns, name, value) {
    var securityContext = binding.securityContext;
    var renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
    renderValue = renderValue != null ? renderValue.toString() : null;
    var renderer = view.renderer;
    if (value != null) {
      renderer.setAttribute(renderNode$$1, name, renderValue, ns);
    } else {
      renderer.removeAttribute(renderNode$$1, name, ns);
    }
  }
  function setElementClass(view, renderNode$$1, name, value) {
    var renderer = view.renderer;
    if (value) {
      renderer.addClass(renderNode$$1, name);
    } else {
      renderer.removeClass(renderNode$$1, name);
    }
  }
  function setElementStyle(view, binding, renderNode$$1, name, value) {
    var renderValue = view.root.sanitizer.sanitize(SecurityContext.STYLE, (value));
    if (renderValue != null) {
      renderValue = renderValue.toString();
      var unit = binding.suffix;
      if (unit != null) {
        renderValue = renderValue + unit;
      }
    } else {
      renderValue = null;
    }
    var renderer = view.renderer;
    if (renderValue != null) {
      renderer.setStyle(renderNode$$1, name, renderValue);
    } else {
      renderer.removeStyle(renderNode$$1, name);
    }
  }
  function setElementProperty(view, binding, renderNode$$1, name, value) {
    var securityContext = binding.securityContext;
    var renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
    view.renderer.setProperty(renderNode$$1, name, renderValue);
  }
  var NOT_CREATED$1 = new Object();
  var InjectorRefTokenKey$1 = tokenKey(Injector);
  var NgModuleRefTokenKey = tokenKey(NgModuleRef);
  function moduleProvideDef(flags, token, value, deps) {
    var depDefs = splitDepsDsl(deps);
    return {
      index: -1,
      deps: depDefs,
      flags: flags,
      token: token,
      value: value
    };
  }
  function moduleDef(providers) {
    var providersByKey = {};
    for (var i = 0; i < providers.length; i++) {
      var provider = providers[i];
      provider.index = i;
      providersByKey[tokenKey(provider.token)] = provider;
    }
    return {
      factory: null,
      providersByKey: providersByKey,
      providers: providers
    };
  }
  function initNgModule(data) {
    var def = data._def;
    var providers = data._providers = new Array(def.providers.length);
    for (var i = 0; i < def.providers.length; i++) {
      var provDef = def.providers[i];
      providers[i] = provDef.flags & 4096 ? NOT_CREATED$1 : _createProviderInstance$1(data, provDef);
    }
  }
  function resolveNgModuleDep(data, depDef, notFoundValue) {
    if (notFoundValue === void 0) {
      notFoundValue = Injector.THROW_IF_NOT_FOUND;
    }
    if (depDef.flags & 8) {
      return depDef.token;
    }
    if (depDef.flags & 2) {
      notFoundValue = null;
    }
    if (depDef.flags & 1) {
      return data._parent.get(depDef.token, notFoundValue);
    }
    var tokenKey$$1 = depDef.tokenKey;
    switch (tokenKey$$1) {
      case InjectorRefTokenKey$1:
      case NgModuleRefTokenKey:
        return data;
    }
    var providerDef = data._def.providersByKey[tokenKey$$1];
    if (providerDef) {
      var providerInstance = data._providers[providerDef.index];
      if (providerInstance === NOT_CREATED$1) {
        providerInstance = data._providers[providerDef.index] = _createProviderInstance$1(data, providerDef);
      }
      return providerInstance;
    }
    return data._parent.get(depDef.token, notFoundValue);
  }
  function _createProviderInstance$1(ngModule, providerDef) {
    var injectable;
    switch (providerDef.flags & 201347067) {
      case 512:
        injectable = _createClass(ngModule, providerDef.value, providerDef.deps);
        break;
      case 1024:
        injectable = _callFactory(ngModule, providerDef.value, providerDef.deps);
        break;
      case 2048:
        injectable = resolveNgModuleDep(ngModule, providerDef.deps[0]);
        break;
      case 256:
        injectable = providerDef.value;
        break;
    }
    return injectable;
  }
  function _createClass(ngModule, ctor, deps) {
    var len = deps.length;
    var injectable;
    switch (len) {
      case 0:
        injectable = new ctor();
        break;
      case 1:
        injectable = new ctor(resolveNgModuleDep(ngModule, deps[0]));
        break;
      case 2:
        injectable = new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));
        break;
      case 3:
        injectable = new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));
        break;
      default:
        var depValues = new Array(len);
        for (var i = 0; i < len; i++) {
          depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
        }
        injectable = new (ctor.bind.apply(ctor, [void 0].concat(depValues)))();
    }
    return injectable;
  }
  function _callFactory(ngModule, factory, deps) {
    var len = deps.length;
    var injectable;
    switch (len) {
      case 0:
        injectable = factory();
        break;
      case 1:
        injectable = factory(resolveNgModuleDep(ngModule, deps[0]));
        break;
      case 2:
        injectable = factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));
        break;
      case 3:
        injectable = factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));
        break;
      default:
        var depValues = Array(len);
        for (var i = 0; i < len; i++) {
          depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
        }
        injectable = factory.apply(void 0, depValues);
    }
    return injectable;
  }
  function callNgModuleLifecycle(ngModule, lifecycles) {
    var def = ngModule._def;
    for (var i = 0; i < def.providers.length; i++) {
      var provDef = def.providers[i];
      if (provDef.flags & 131072) {
        var instance = ngModule._providers[i];
        if (instance && instance !== NOT_CREATED$1) {
          instance.ngOnDestroy();
        }
      }
    }
  }
  function attachEmbeddedView(parentView, elementData, viewIndex, view) {
    var embeddedViews = ((elementData.viewContainer))._embeddedViews;
    if (viewIndex === null || viewIndex === undefined) {
      viewIndex = embeddedViews.length;
    }
    view.viewContainerParent = parentView;
    addToArray(embeddedViews, ((viewIndex)), view);
    attachProjectedView(elementData, view);
    Services.dirtyParentQueries(view);
    var prevView = ((viewIndex)) > 0 ? embeddedViews[((viewIndex)) - 1] : null;
    renderAttachEmbeddedView(elementData, prevView, view);
  }
  function attachProjectedView(vcElementData, view) {
    var dvcElementData = declaredViewContainer(view);
    if (!dvcElementData || dvcElementData === vcElementData || view.state & 16) {
      return;
    }
    view.state |= 16;
    var projectedViews = dvcElementData.template._projectedViews;
    if (!projectedViews) {
      projectedViews = dvcElementData.template._projectedViews = [];
    }
    projectedViews.push(view);
    markNodeAsProjectedTemplate(((view.parent)).def, ((view.parentNodeDef)));
  }
  function markNodeAsProjectedTemplate(viewDef, nodeDef) {
    if (nodeDef.flags & 4) {
      return;
    }
    viewDef.nodeFlags |= 4;
    nodeDef.flags |= 4;
    var parentNodeDef = nodeDef.parent;
    while (parentNodeDef) {
      parentNodeDef.childFlags |= 4;
      parentNodeDef = parentNodeDef.parent;
    }
  }
  function detachEmbeddedView(elementData, viewIndex) {
    var embeddedViews = ((elementData.viewContainer))._embeddedViews;
    if (viewIndex == null || viewIndex >= embeddedViews.length) {
      viewIndex = embeddedViews.length - 1;
    }
    if (viewIndex < 0) {
      return null;
    }
    var view = embeddedViews[viewIndex];
    view.viewContainerParent = null;
    removeFromArray(embeddedViews, viewIndex);
    Services.dirtyParentQueries(view);
    renderDetachView(view);
    return view;
  }
  function detachProjectedView(view) {
    if (!(view.state & 16)) {
      return;
    }
    var dvcElementData = declaredViewContainer(view);
    if (dvcElementData) {
      var projectedViews = dvcElementData.template._projectedViews;
      if (projectedViews) {
        removeFromArray(projectedViews, projectedViews.indexOf(view));
        Services.dirtyParentQueries(view);
      }
    }
  }
  function moveEmbeddedView(elementData, oldViewIndex, newViewIndex) {
    var embeddedViews = ((elementData.viewContainer))._embeddedViews;
    var view = embeddedViews[oldViewIndex];
    removeFromArray(embeddedViews, oldViewIndex);
    if (newViewIndex == null) {
      newViewIndex = embeddedViews.length;
    }
    addToArray(embeddedViews, newViewIndex, view);
    Services.dirtyParentQueries(view);
    renderDetachView(view);
    var prevView = newViewIndex > 0 ? embeddedViews[newViewIndex - 1] : null;
    renderAttachEmbeddedView(elementData, prevView, view);
    return view;
  }
  function renderAttachEmbeddedView(elementData, prevView, view) {
    var prevRenderNode = prevView ? renderNode(prevView, ((prevView.def.lastRenderRootNode))) : elementData.renderElement;
    var parentNode = view.renderer.parentNode(prevRenderNode);
    var nextSibling = view.renderer.nextSibling(prevRenderNode);
    visitRootRenderNodes(view, 2, parentNode, nextSibling, undefined);
  }
  function renderDetachView(view) {
    visitRootRenderNodes(view, 3, null, null, undefined);
  }
  function addToArray(arr, index, value) {
    if (index >= arr.length) {
      arr.push(value);
    } else {
      arr.splice(index, 0, value);
    }
  }
  function removeFromArray(arr, index) {
    if (index >= arr.length - 1) {
      arr.pop();
    } else {
      arr.splice(index, 1);
    }
  }
  var EMPTY_CONTEXT = new Object();
  function createComponentFactory(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors) {
    return new ComponentFactory_(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors);
  }
  function getComponentViewDefinitionFactory(componentFactory) {
    return ((componentFactory)).viewDefFactory;
  }
  var ComponentFactory_ = (function(_super) {
    __extends(ComponentFactory_, _super);
    function ComponentFactory_(selector, componentType, viewDefFactory, _inputs, _outputs, ngContentSelectors) {
      var _this = _super.call(this) || this;
      _this.selector = selector;
      _this.componentType = componentType;
      _this._inputs = _inputs;
      _this._outputs = _outputs;
      _this.ngContentSelectors = ngContentSelectors;
      _this.viewDefFactory = viewDefFactory;
      return _this;
    }
    Object.defineProperty(ComponentFactory_.prototype, "inputs", {
      get: function() {
        var inputsArr = [];
        var inputs = ((this._inputs));
        for (var propName in inputs) {
          var templateName = inputs[propName];
          inputsArr.push({
            propName: propName,
            templateName: templateName
          });
        }
        return inputsArr;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentFactory_.prototype, "outputs", {
      get: function() {
        var outputsArr = [];
        for (var propName in this._outputs) {
          var templateName = this._outputs[propName];
          outputsArr.push({
            propName: propName,
            templateName: templateName
          });
        }
        return outputsArr;
      },
      enumerable: true,
      configurable: true
    });
    ComponentFactory_.prototype.create = function(injector, projectableNodes, rootSelectorOrNode, ngModule) {
      if (!ngModule) {
        throw new Error('ngModule should be provided');
      }
      var viewDef = resolveDefinition(this.viewDefFactory);
      var componentNodeIndex = ((((viewDef.nodes[0].element)).componentProvider)).index;
      var view = Services.createRootView(injector, projectableNodes || [], rootSelectorOrNode, viewDef, ngModule, EMPTY_CONTEXT);
      var component = asProviderData(view, componentNodeIndex).instance;
      if (rootSelectorOrNode) {
        view.renderer.setAttribute(asElementData(view, 0).renderElement, 'ng-version', VERSION.full);
      }
      return new ComponentRef_(view, new ViewRef_(view), component);
    };
    return ComponentFactory_;
  }(ComponentFactory));
  var ComponentRef_ = (function(_super) {
    __extends(ComponentRef_, _super);
    function ComponentRef_(_view, _viewRef, _component) {
      var _this = _super.call(this) || this;
      _this._view = _view;
      _this._viewRef = _viewRef;
      _this._component = _component;
      _this._elDef = _this._view.def.nodes[0];
      return _this;
    }
    Object.defineProperty(ComponentRef_.prototype, "location", {
      get: function() {
        return new ElementRef(asElementData(this._view, this._elDef.index).renderElement);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef_.prototype, "injector", {
      get: function() {
        return new Injector_(this._view, this._elDef);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef_.prototype, "instance", {
      get: function() {
        return this._component;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef_.prototype, "hostView", {
      get: function() {
        return this._viewRef;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
      get: function() {
        return this._viewRef;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef_.prototype, "componentType", {
      get: function() {
        return (this._component.constructor);
      },
      enumerable: true,
      configurable: true
    });
    ComponentRef_.prototype.destroy = function() {
      this._viewRef.destroy();
    };
    ComponentRef_.prototype.onDestroy = function(callback) {
      this._viewRef.onDestroy(callback);
    };
    return ComponentRef_;
  }(ComponentRef));
  function createViewContainerData(view, elDef, elData) {
    return new ViewContainerRef_(view, elDef, elData);
  }
  var ViewContainerRef_ = (function() {
    function ViewContainerRef_(_view, _elDef, _data) {
      this._view = _view;
      this._elDef = _elDef;
      this._data = _data;
      this._embeddedViews = [];
    }
    Object.defineProperty(ViewContainerRef_.prototype, "element", {
      get: function() {
        return new ElementRef(this._data.renderElement);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef_.prototype, "injector", {
      get: function() {
        return new Injector_(this._view, this._elDef);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
      get: function() {
        var view = this._view;
        var elDef = this._elDef.parent;
        while (!elDef && view) {
          elDef = viewParentEl(view);
          view = ((view.parent));
        }
        return view ? new Injector_(view, elDef) : new Injector_(this._view, null);
      },
      enumerable: true,
      configurable: true
    });
    ViewContainerRef_.prototype.clear = function() {
      var len = this._embeddedViews.length;
      for (var i = len - 1; i >= 0; i--) {
        var view = ((detachEmbeddedView(this._data, i)));
        Services.destroyView(view);
      }
    };
    ViewContainerRef_.prototype.get = function(index) {
      var view = this._embeddedViews[index];
      if (view) {
        var ref = new ViewRef_(view);
        ref.attachToViewContainerRef(this);
        return ref;
      }
      return null;
    };
    Object.defineProperty(ViewContainerRef_.prototype, "length", {
      get: function() {
        return this._embeddedViews.length;
      },
      enumerable: true,
      configurable: true
    });
    ViewContainerRef_.prototype.createEmbeddedView = function(templateRef, context, index) {
      var viewRef = templateRef.createEmbeddedView(context || ({}));
      this.insert(viewRef, index);
      return viewRef;
    };
    ViewContainerRef_.prototype.createComponent = function(componentFactory, index, injector, projectableNodes, ngModuleRef) {
      var contextInjector = injector || this.parentInjector;
      if (!ngModuleRef && !(componentFactory instanceof ComponentFactoryBoundToModule)) {
        ngModuleRef = contextInjector.get(NgModuleRef);
      }
      var componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);
      this.insert(componentRef.hostView, index);
      return componentRef;
    };
    ViewContainerRef_.prototype.insert = function(viewRef, index) {
      var viewRef_ = (viewRef);
      var viewData = viewRef_._view;
      attachEmbeddedView(this._view, this._data, index, viewData);
      viewRef_.attachToViewContainerRef(this);
      return viewRef;
    };
    ViewContainerRef_.prototype.move = function(viewRef, currentIndex) {
      var previousIndex = this._embeddedViews.indexOf(viewRef._view);
      moveEmbeddedView(this._data, previousIndex, currentIndex);
      return viewRef;
    };
    ViewContainerRef_.prototype.indexOf = function(viewRef) {
      return this._embeddedViews.indexOf(((viewRef))._view);
    };
    ViewContainerRef_.prototype.remove = function(index) {
      var viewData = detachEmbeddedView(this._data, index);
      if (viewData) {
        Services.destroyView(viewData);
      }
    };
    ViewContainerRef_.prototype.detach = function(index) {
      var view = detachEmbeddedView(this._data, index);
      return view ? new ViewRef_(view) : null;
    };
    return ViewContainerRef_;
  }());
  function createChangeDetectorRef(view) {
    return new ViewRef_(view);
  }
  var ViewRef_ = (function() {
    function ViewRef_(_view) {
      this._view = _view;
      this._viewContainerRef = null;
      this._appRef = null;
    }
    Object.defineProperty(ViewRef_.prototype, "rootNodes", {
      get: function() {
        return rootRenderNodes(this._view);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "context", {
      get: function() {
        return this._view.context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "destroyed", {
      get: function() {
        return (this._view.state & 128) !== 0;
      },
      enumerable: true,
      configurable: true
    });
    ViewRef_.prototype.markForCheck = function() {
      markParentViewsForCheck(this._view);
    };
    ViewRef_.prototype.detach = function() {
      this._view.state &= ~4;
    };
    ViewRef_.prototype.detectChanges = function() {
      var fs = this._view.root.rendererFactory;
      if (fs.begin) {
        fs.begin();
      }
      Services.checkAndUpdateView(this._view);
      if (fs.end) {
        fs.end();
      }
    };
    ViewRef_.prototype.checkNoChanges = function() {
      Services.checkNoChangesView(this._view);
    };
    ViewRef_.prototype.reattach = function() {
      this._view.state |= 4;
    };
    ViewRef_.prototype.onDestroy = function(callback) {
      if (!this._view.disposables) {
        this._view.disposables = [];
      }
      this._view.disposables.push((callback));
    };
    ViewRef_.prototype.destroy = function() {
      if (this._appRef) {
        this._appRef.detachView(this);
      } else if (this._viewContainerRef) {
        this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));
      }
      Services.destroyView(this._view);
    };
    ViewRef_.prototype.detachFromAppRef = function() {
      this._appRef = null;
      renderDetachView(this._view);
      Services.dirtyParentQueries(this._view);
    };
    ViewRef_.prototype.attachToAppRef = function(appRef) {
      if (this._viewContainerRef) {
        throw new Error('This view is already attached to a ViewContainer!');
      }
      this._appRef = appRef;
    };
    ViewRef_.prototype.attachToViewContainerRef = function(vcRef) {
      if (this._appRef) {
        throw new Error('This view is already attached directly to the ApplicationRef!');
      }
      this._viewContainerRef = vcRef;
    };
    return ViewRef_;
  }());
  function createTemplateData(view, def) {
    return new TemplateRef_(view, def);
  }
  var TemplateRef_ = (function(_super) {
    __extends(TemplateRef_, _super);
    function TemplateRef_(_parentView, _def) {
      var _this = _super.call(this) || this;
      _this._parentView = _parentView;
      _this._def = _def;
      return _this;
    }
    TemplateRef_.prototype.createEmbeddedView = function(context) {
      return new ViewRef_(Services.createEmbeddedView(this._parentView, this._def, ((((this._def.element)).template)), context));
    };
    Object.defineProperty(TemplateRef_.prototype, "elementRef", {
      get: function() {
        return new ElementRef(asElementData(this._parentView, this._def.index).renderElement);
      },
      enumerable: true,
      configurable: true
    });
    return TemplateRef_;
  }(TemplateRef));
  function createInjector(view, elDef) {
    return new Injector_(view, elDef);
  }
  var Injector_ = (function() {
    function Injector_(view, elDef) {
      this.view = view;
      this.elDef = elDef;
    }
    Injector_.prototype.get = function(token, notFoundValue) {
      if (notFoundValue === void 0) {
        notFoundValue = Injector.THROW_IF_NOT_FOUND;
      }
      var allowPrivateServices = this.elDef ? (this.elDef.flags & 33554432) !== 0 : false;
      return Services.resolveDep(this.view, this.elDef, allowPrivateServices, {
        flags: 0,
        token: token,
        tokenKey: tokenKey(token)
      }, notFoundValue);
    };
    return Injector_;
  }());
  function nodeValue(view, index) {
    var def = view.def.nodes[index];
    if (def.flags & 1) {
      var elData = asElementData(view, def.index);
      return ((def.element)).template ? elData.template : elData.renderElement;
    } else if (def.flags & 2) {
      return asTextData(view, def.index).renderText;
    } else if (def.flags & (20224 | 16)) {
      return asProviderData(view, def.index).instance;
    }
    throw new Error("Illegal state: read nodeValue for node index " + index);
  }
  function createRendererV1(view) {
    return new RendererAdapter(view.renderer);
  }
  var RendererAdapter = (function() {
    function RendererAdapter(delegate) {
      this.delegate = delegate;
    }
    RendererAdapter.prototype.selectRootElement = function(selectorOrNode) {
      return this.delegate.selectRootElement(selectorOrNode);
    };
    RendererAdapter.prototype.createElement = function(parent, namespaceAndName) {
      var _a = splitNamespace(namespaceAndName),
          ns = _a[0],
          name = _a[1];
      var el = this.delegate.createElement(name, ns);
      if (parent) {
        this.delegate.appendChild(parent, el);
      }
      return el;
    };
    RendererAdapter.prototype.createViewRoot = function(hostElement) {
      return hostElement;
    };
    RendererAdapter.prototype.createTemplateAnchor = function(parentElement) {
      var comment = this.delegate.createComment('');
      if (parentElement) {
        this.delegate.appendChild(parentElement, comment);
      }
      return comment;
    };
    RendererAdapter.prototype.createText = function(parentElement, value) {
      var node = this.delegate.createText(value);
      if (parentElement) {
        this.delegate.appendChild(parentElement, node);
      }
      return node;
    };
    RendererAdapter.prototype.projectNodes = function(parentElement, nodes) {
      for (var i = 0; i < nodes.length; i++) {
        this.delegate.appendChild(parentElement, nodes[i]);
      }
    };
    RendererAdapter.prototype.attachViewAfter = function(node, viewRootNodes) {
      var parentElement = this.delegate.parentNode(node);
      var nextSibling = this.delegate.nextSibling(node);
      for (var i = 0; i < viewRootNodes.length; i++) {
        this.delegate.insertBefore(parentElement, viewRootNodes[i], nextSibling);
      }
    };
    RendererAdapter.prototype.detachView = function(viewRootNodes) {
      for (var i = 0; i < viewRootNodes.length; i++) {
        var node = viewRootNodes[i];
        var parentElement = this.delegate.parentNode(node);
        this.delegate.removeChild(parentElement, node);
      }
    };
    RendererAdapter.prototype.destroyView = function(hostElement, viewAllNodes) {
      for (var i = 0; i < viewAllNodes.length; i++) {
        ((this.delegate.destroyNode))(viewAllNodes[i]);
      }
    };
    RendererAdapter.prototype.listen = function(renderElement, name, callback) {
      return this.delegate.listen(renderElement, name, (callback));
    };
    RendererAdapter.prototype.listenGlobal = function(target, name, callback) {
      return this.delegate.listen(target, name, (callback));
    };
    RendererAdapter.prototype.setElementProperty = function(renderElement, propertyName, propertyValue) {
      this.delegate.setProperty(renderElement, propertyName, propertyValue);
    };
    RendererAdapter.prototype.setElementAttribute = function(renderElement, namespaceAndName, attributeValue) {
      var _a = splitNamespace(namespaceAndName),
          ns = _a[0],
          name = _a[1];
      if (attributeValue != null) {
        this.delegate.setAttribute(renderElement, name, attributeValue, ns);
      } else {
        this.delegate.removeAttribute(renderElement, name, ns);
      }
    };
    RendererAdapter.prototype.setBindingDebugInfo = function(renderElement, propertyName, propertyValue) {};
    RendererAdapter.prototype.setElementClass = function(renderElement, className, isAdd) {
      if (isAdd) {
        this.delegate.addClass(renderElement, className);
      } else {
        this.delegate.removeClass(renderElement, className);
      }
    };
    RendererAdapter.prototype.setElementStyle = function(renderElement, styleName, styleValue) {
      if (styleValue != null) {
        this.delegate.setStyle(renderElement, styleName, styleValue);
      } else {
        this.delegate.removeStyle(renderElement, styleName);
      }
    };
    RendererAdapter.prototype.invokeElementMethod = function(renderElement, methodName, args) {
      ((renderElement))[methodName].apply(renderElement, args);
    };
    RendererAdapter.prototype.setText = function(renderNode$$1, text) {
      this.delegate.setValue(renderNode$$1, text);
    };
    RendererAdapter.prototype.animate = function() {
      throw new Error('Renderer.animate is no longer supported!');
    };
    return RendererAdapter;
  }());
  function createNgModuleRef(moduleType, parent, bootstrapComponents, def) {
    return new NgModuleRef_(moduleType, parent, bootstrapComponents, def);
  }
  var NgModuleRef_ = (function() {
    function NgModuleRef_(_moduleType, _parent, _bootstrapComponents, _def) {
      this._moduleType = _moduleType;
      this._parent = _parent;
      this._bootstrapComponents = _bootstrapComponents;
      this._def = _def;
      this._destroyListeners = [];
      this._destroyed = false;
      initNgModule(this);
    }
    NgModuleRef_.prototype.get = function(token, notFoundValue) {
      if (notFoundValue === void 0) {
        notFoundValue = Injector.THROW_IF_NOT_FOUND;
      }
      return resolveNgModuleDep(this, {
        token: token,
        tokenKey: tokenKey(token),
        flags: 0
      }, notFoundValue);
    };
    Object.defineProperty(NgModuleRef_.prototype, "instance", {
      get: function() {
        return this.get(this._moduleType);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgModuleRef_.prototype, "componentFactoryResolver", {
      get: function() {
        return this.get(ComponentFactoryResolver);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgModuleRef_.prototype, "injector", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    NgModuleRef_.prototype.destroy = function() {
      if (this._destroyed) {
        throw new Error("The ng module " + stringify(this.instance.constructor) + " has already been destroyed.");
      }
      this._destroyed = true;
      callNgModuleLifecycle(this, 131072);
      this._destroyListeners.forEach(function(listener) {
        return listener();
      });
    };
    NgModuleRef_.prototype.onDestroy = function(callback) {
      this._destroyListeners.push(callback);
    };
    return NgModuleRef_;
  }());
  var RendererV1TokenKey = tokenKey(Renderer);
  var Renderer2TokenKey = tokenKey(Renderer2);
  var ElementRefTokenKey = tokenKey(ElementRef);
  var ViewContainerRefTokenKey = tokenKey(ViewContainerRef);
  var TemplateRefTokenKey = tokenKey(TemplateRef);
  var ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);
  var InjectorRefTokenKey = tokenKey(Injector);
  var NOT_CREATED = new Object();
  function directiveDef(flags, matchedQueries, childCount, ctor, deps, props, outputs) {
    var bindings = [];
    if (props) {
      for (var prop in props) {
        var _a = props[prop],
            bindingIndex = _a[0],
            nonMinifiedName = _a[1];
        bindings[bindingIndex] = {
          flags: 8,
          name: prop,
          nonMinifiedName: nonMinifiedName,
          ns: null,
          securityContext: null,
          suffix: null
        };
      }
    }
    var outputDefs = [];
    if (outputs) {
      for (var propName in outputs) {
        outputDefs.push({
          type: 1,
          propName: propName,
          target: null,
          eventName: outputs[propName]
        });
      }
    }
    flags |= 16384;
    return _def(flags, matchedQueries, childCount, ctor, ctor, deps, bindings, outputDefs);
  }
  function pipeDef(flags, ctor, deps) {
    flags |= 16;
    return _def(flags, null, 0, ctor, ctor, deps);
  }
  function providerDef(flags, matchedQueries, token, value, deps) {
    return _def(flags, matchedQueries, 0, token, value, deps);
  }
  function _def(flags, matchedQueriesDsl, childCount, token, value, deps, bindings, outputs) {
    var _a = splitMatchedQueriesDsl(matchedQueriesDsl),
        matchedQueries = _a.matchedQueries,
        references = _a.references,
        matchedQueryIds = _a.matchedQueryIds;
    if (!outputs) {
      outputs = [];
    }
    if (!bindings) {
      bindings = [];
    }
    var depDefs = splitDepsDsl(deps);
    return {
      index: -1,
      parent: null,
      renderParent: null,
      bindingIndex: -1,
      outputIndex: -1,
      flags: flags,
      childFlags: 0,
      directChildFlags: 0,
      childMatchedQueries: 0,
      matchedQueries: matchedQueries,
      matchedQueryIds: matchedQueryIds,
      references: references,
      ngContentIndex: -1,
      childCount: childCount,
      bindings: bindings,
      bindingFlags: calcBindingFlags(bindings),
      outputs: outputs,
      element: null,
      provider: {
        token: token,
        value: value,
        deps: depDefs
      },
      text: null,
      query: null,
      ngContent: null
    };
  }
  function createProviderInstance(view, def) {
    return def.flags & 4096 ? NOT_CREATED : _createProviderInstance(view, def);
  }
  function createPipeInstance(view, def) {
    var compView = view;
    while (compView.parent && !isComponentView(compView)) {
      compView = compView.parent;
    }
    var allowPrivateServices = true;
    return createClass(((compView.parent)), ((viewParentEl(compView))), allowPrivateServices, ((def.provider)).value, ((def.provider)).deps);
  }
  function createDirectiveInstance(view, def) {
    var allowPrivateServices = (def.flags & 32768) > 0;
    var instance = createClass(view, ((def.parent)), allowPrivateServices, ((def.provider)).value, ((def.provider)).deps);
    if (def.outputs.length) {
      for (var i = 0; i < def.outputs.length; i++) {
        var output = def.outputs[i];
        var subscription = instance[((output.propName))].subscribe(eventHandlerClosure(view, ((def.parent)).index, output.eventName));
        ((view.disposables))[def.outputIndex + i] = subscription.unsubscribe.bind(subscription);
      }
    }
    return instance;
  }
  function eventHandlerClosure(view, index, eventName) {
    return function(event) {
      try {
        return dispatchEvent(view, index, eventName, event);
      } catch (e) {
        view.root.errorHandler.handleError(e);
      }
    };
  }
  function checkAndUpdateDirectiveInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
    var providerData = asProviderData(view, def.index);
    var directive = providerData.instance;
    var changed = false;
    var changes = ((undefined));
    var bindLen = def.bindings.length;
    if (bindLen > 0 && checkBinding(view, def, 0, v0)) {
      changed = true;
      changes = updateProp(view, providerData, def, 0, v0, changes);
    }
    if (bindLen > 1 && checkBinding(view, def, 1, v1)) {
      changed = true;
      changes = updateProp(view, providerData, def, 1, v1, changes);
    }
    if (bindLen > 2 && checkBinding(view, def, 2, v2)) {
      changed = true;
      changes = updateProp(view, providerData, def, 2, v2, changes);
    }
    if (bindLen > 3 && checkBinding(view, def, 3, v3)) {
      changed = true;
      changes = updateProp(view, providerData, def, 3, v3, changes);
    }
    if (bindLen > 4 && checkBinding(view, def, 4, v4)) {
      changed = true;
      changes = updateProp(view, providerData, def, 4, v4, changes);
    }
    if (bindLen > 5 && checkBinding(view, def, 5, v5)) {
      changed = true;
      changes = updateProp(view, providerData, def, 5, v5, changes);
    }
    if (bindLen > 6 && checkBinding(view, def, 6, v6)) {
      changed = true;
      changes = updateProp(view, providerData, def, 6, v6, changes);
    }
    if (bindLen > 7 && checkBinding(view, def, 7, v7)) {
      changed = true;
      changes = updateProp(view, providerData, def, 7, v7, changes);
    }
    if (bindLen > 8 && checkBinding(view, def, 8, v8)) {
      changed = true;
      changes = updateProp(view, providerData, def, 8, v8, changes);
    }
    if (bindLen > 9 && checkBinding(view, def, 9, v9)) {
      changed = true;
      changes = updateProp(view, providerData, def, 9, v9, changes);
    }
    if (changes) {
      directive.ngOnChanges(changes);
    }
    if ((view.state & 2) && (def.flags & 65536)) {
      directive.ngOnInit();
    }
    if (def.flags & 262144) {
      directive.ngDoCheck();
    }
    return changed;
  }
  function checkAndUpdateDirectiveDynamic(view, def, values) {
    var providerData = asProviderData(view, def.index);
    var directive = providerData.instance;
    var changed = false;
    var changes = ((undefined));
    for (var i = 0; i < values.length; i++) {
      if (checkBinding(view, def, i, values[i])) {
        changed = true;
        changes = updateProp(view, providerData, def, i, values[i], changes);
      }
    }
    if (changes) {
      directive.ngOnChanges(changes);
    }
    if ((view.state & 2) && (def.flags & 65536)) {
      directive.ngOnInit();
    }
    if (def.flags & 262144) {
      directive.ngDoCheck();
    }
    return changed;
  }
  function _createProviderInstance(view, def) {
    var allowPrivateServices = (def.flags & 8192) > 0;
    var providerDef = def.provider;
    var injectable;
    switch (def.flags & 201347067) {
      case 512:
        injectable = createClass(view, ((def.parent)), allowPrivateServices, ((providerDef)).value, ((providerDef)).deps);
        break;
      case 1024:
        injectable = callFactory(view, ((def.parent)), allowPrivateServices, ((providerDef)).value, ((providerDef)).deps);
        break;
      case 2048:
        injectable = resolveDep(view, ((def.parent)), allowPrivateServices, ((providerDef)).deps[0]);
        break;
      case 256:
        injectable = ((providerDef)).value;
        break;
    }
    return injectable;
  }
  function createClass(view, elDef, allowPrivateServices, ctor, deps) {
    var len = deps.length;
    var injectable;
    switch (len) {
      case 0:
        injectable = new ctor();
        break;
      case 1:
        injectable = new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]));
        break;
      case 2:
        injectable = new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));
        break;
      case 3:
        injectable = new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));
        break;
      default:
        var depValues = new Array(len);
        for (var i = 0; i < len; i++) {
          depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);
        }
        injectable = new (ctor.bind.apply(ctor, [void 0].concat(depValues)))();
    }
    return injectable;
  }
  function callFactory(view, elDef, allowPrivateServices, factory, deps) {
    var len = deps.length;
    var injectable;
    switch (len) {
      case 0:
        injectable = factory();
        break;
      case 1:
        injectable = factory(resolveDep(view, elDef, allowPrivateServices, deps[0]));
        break;
      case 2:
        injectable = factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));
        break;
      case 3:
        injectable = factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));
        break;
      default:
        var depValues = Array(len);
        for (var i = 0; i < len; i++) {
          depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);
        }
        injectable = factory.apply(void 0, depValues);
    }
    return injectable;
  }
  var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
  function resolveDep(view, elDef, allowPrivateServices, depDef, notFoundValue) {
    if (notFoundValue === void 0) {
      notFoundValue = Injector.THROW_IF_NOT_FOUND;
    }
    if (depDef.flags & 8) {
      return depDef.token;
    }
    var startView = view;
    if (depDef.flags & 2) {
      notFoundValue = null;
    }
    var tokenKey$$1 = depDef.tokenKey;
    if (tokenKey$$1 === ChangeDetectorRefTokenKey) {
      allowPrivateServices = !!(elDef && ((elDef.element)).componentView);
    }
    if (elDef && (depDef.flags & 1)) {
      allowPrivateServices = false;
      elDef = ((elDef.parent));
    }
    while (view) {
      if (elDef) {
        switch (tokenKey$$1) {
          case RendererV1TokenKey:
            {
              var compView = findCompView(view, elDef, allowPrivateServices);
              return createRendererV1(compView);
            }
          case Renderer2TokenKey:
            {
              var compView = findCompView(view, elDef, allowPrivateServices);
              return compView.renderer;
            }
          case ElementRefTokenKey:
            return new ElementRef(asElementData(view, elDef.index).renderElement);
          case ViewContainerRefTokenKey:
            return asElementData(view, elDef.index).viewContainer;
          case TemplateRefTokenKey:
            {
              if (((elDef.element)).template) {
                return asElementData(view, elDef.index).template;
              }
              break;
            }
          case ChangeDetectorRefTokenKey:
            {
              var cdView = findCompView(view, elDef, allowPrivateServices);
              return createChangeDetectorRef(cdView);
            }
          case InjectorRefTokenKey:
            return createInjector(view, elDef);
          default:
            var providerDef_1 = (((allowPrivateServices ? ((elDef.element)).allProviders : ((elDef.element)).publicProviders)))[tokenKey$$1];
            if (providerDef_1) {
              var providerData = asProviderData(view, providerDef_1.index);
              if (providerData.instance === NOT_CREATED) {
                providerData.instance = _createProviderInstance(view, providerDef_1);
              }
              return providerData.instance;
            }
        }
      }
      allowPrivateServices = isComponentView(view);
      elDef = ((viewParentEl(view)));
      view = ((view.parent));
    }
    var value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);
    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
      return value;
    }
    return startView.root.ngModule.injector.get(depDef.token, notFoundValue);
  }
  function findCompView(view, elDef, allowPrivateServices) {
    var compView;
    if (allowPrivateServices) {
      compView = asElementData(view, elDef.index).componentView;
    } else {
      compView = view;
      while (compView.parent && !isComponentView(compView)) {
        compView = compView.parent;
      }
    }
    return compView;
  }
  function updateProp(view, providerData, def, bindingIdx, value, changes) {
    if (def.flags & 32768) {
      var compView = asElementData(view, ((def.parent)).index).componentView;
      if (compView.def.flags & 2) {
        compView.state |= 8;
      }
    }
    var binding = def.bindings[bindingIdx];
    var propName = ((binding.name));
    providerData.instance[propName] = value;
    if (def.flags & 524288) {
      changes = changes || {};
      var oldValue = view.oldValues[def.bindingIndex + bindingIdx];
      if (oldValue instanceof WrappedValue) {
        oldValue = oldValue.wrapped;
      }
      var binding_1 = def.bindings[bindingIdx];
      changes[((binding_1.nonMinifiedName))] = new SimpleChange(oldValue, value, (view.state & 2) !== 0);
    }
    view.oldValues[def.bindingIndex + bindingIdx] = value;
    return changes;
  }
  function callLifecycleHooksChildrenFirst(view, lifecycles) {
    if (!(view.def.nodeFlags & lifecycles)) {
      return;
    }
    var nodes = view.def.nodes;
    for (var i = 0; i < nodes.length; i++) {
      var nodeDef = nodes[i];
      var parent = nodeDef.parent;
      if (!parent && nodeDef.flags & lifecycles) {
        callProviderLifecycles(view, i, nodeDef.flags & lifecycles);
      }
      if ((nodeDef.childFlags & lifecycles) === 0) {
        i += nodeDef.childCount;
      }
      while (parent && (parent.flags & 1) && i === parent.index + parent.childCount) {
        if (parent.directChildFlags & lifecycles) {
          callElementProvidersLifecycles(view, parent, lifecycles);
        }
        parent = parent.parent;
      }
    }
  }
  function callElementProvidersLifecycles(view, elDef, lifecycles) {
    for (var i = elDef.index + 1; i <= elDef.index + elDef.childCount; i++) {
      var nodeDef = view.def.nodes[i];
      if (nodeDef.flags & lifecycles) {
        callProviderLifecycles(view, i, nodeDef.flags & lifecycles);
      }
      i += nodeDef.childCount;
    }
  }
  function callProviderLifecycles(view, index, lifecycles) {
    var provider = asProviderData(view, index).instance;
    if (provider === NOT_CREATED) {
      return;
    }
    Services.setCurrentNode(view, index);
    if (lifecycles & 1048576) {
      provider.ngAfterContentInit();
    }
    if (lifecycles & 2097152) {
      provider.ngAfterContentChecked();
    }
    if (lifecycles & 4194304) {
      provider.ngAfterViewInit();
    }
    if (lifecycles & 8388608) {
      provider.ngAfterViewChecked();
    }
    if (lifecycles & 131072) {
      provider.ngOnDestroy();
    }
  }
  function queryDef(flags, id, bindings) {
    var bindingDefs = [];
    for (var propName in bindings) {
      var bindingType = bindings[propName];
      bindingDefs.push({
        propName: propName,
        bindingType: bindingType
      });
    }
    return {
      index: -1,
      parent: null,
      renderParent: null,
      bindingIndex: -1,
      outputIndex: -1,
      flags: flags,
      childFlags: 0,
      directChildFlags: 0,
      childMatchedQueries: 0,
      ngContentIndex: -1,
      matchedQueries: {},
      matchedQueryIds: 0,
      references: {},
      childCount: 0,
      bindings: [],
      bindingFlags: 0,
      outputs: [],
      element: null,
      provider: null,
      text: null,
      query: {
        id: id,
        filterId: filterQueryId(id),
        bindings: bindingDefs
      },
      ngContent: null
    };
  }
  function createQuery() {
    return new QueryList();
  }
  function dirtyParentQueries(view) {
    var queryIds = view.def.nodeMatchedQueries;
    while (view.parent && isEmbeddedView(view)) {
      var tplDef = ((view.parentNodeDef));
      view = view.parent;
      var end = tplDef.index + tplDef.childCount;
      for (var i = 0; i <= end; i++) {
        var nodeDef = view.def.nodes[i];
        if ((nodeDef.flags & 67108864) && (nodeDef.flags & 536870912) && (((nodeDef.query)).filterId & queryIds) === ((nodeDef.query)).filterId) {
          asQueryList(view, i).setDirty();
        }
        if ((nodeDef.flags & 1 && i + nodeDef.childCount < tplDef.index) || !(nodeDef.childFlags & 67108864) || !(nodeDef.childFlags & 536870912)) {
          i += nodeDef.childCount;
        }
      }
    }
    if (view.def.nodeFlags & 134217728) {
      for (var i = 0; i < view.def.nodes.length; i++) {
        var nodeDef = view.def.nodes[i];
        if ((nodeDef.flags & 134217728) && (nodeDef.flags & 536870912)) {
          asQueryList(view, i).setDirty();
        }
        i += nodeDef.childCount;
      }
    }
  }
  function checkAndUpdateQuery(view, nodeDef) {
    var queryList = asQueryList(view, nodeDef.index);
    if (!queryList.dirty) {
      return;
    }
    var directiveInstance;
    var newValues = ((undefined));
    if (nodeDef.flags & 67108864) {
      var elementDef_1 = ((((nodeDef.parent)).parent));
      newValues = calcQueryValues(view, elementDef_1.index, elementDef_1.index + elementDef_1.childCount, ((nodeDef.query)), []);
      directiveInstance = asProviderData(view, ((nodeDef.parent)).index).instance;
    } else if (nodeDef.flags & 134217728) {
      newValues = calcQueryValues(view, 0, view.def.nodes.length - 1, ((nodeDef.query)), []);
      directiveInstance = view.component;
    }
    queryList.reset(newValues);
    var bindings = ((nodeDef.query)).bindings;
    var notify = false;
    for (var i = 0; i < bindings.length; i++) {
      var binding = bindings[i];
      var boundValue = void 0;
      switch (binding.bindingType) {
        case 0:
          boundValue = queryList.first;
          break;
        case 1:
          boundValue = queryList;
          notify = true;
          break;
      }
      directiveInstance[binding.propName] = boundValue;
    }
    if (notify) {
      queryList.notifyOnChanges();
    }
  }
  function calcQueryValues(view, startIndex, endIndex, queryDef, values) {
    for (var i = startIndex; i <= endIndex; i++) {
      var nodeDef = view.def.nodes[i];
      var valueType = nodeDef.matchedQueries[queryDef.id];
      if (valueType != null) {
        values.push(getQueryValue(view, nodeDef, valueType));
      }
      if (nodeDef.flags & 1 && ((nodeDef.element)).template && (((((nodeDef.element)).template)).nodeMatchedQueries & queryDef.filterId) === queryDef.filterId) {
        var elementData = asElementData(view, i);
        if (nodeDef.flags & 16777216) {
          var embeddedViews = ((elementData.viewContainer))._embeddedViews;
          for (var k = 0; k < embeddedViews.length; k++) {
            var embeddedView = embeddedViews[k];
            var dvc = declaredViewContainer(embeddedView);
            if (dvc && dvc === elementData) {
              calcQueryValues(embeddedView, 0, embeddedView.def.nodes.length - 1, queryDef, values);
            }
          }
        }
        var projectedViews = elementData.template._projectedViews;
        if (projectedViews) {
          for (var k = 0; k < projectedViews.length; k++) {
            var projectedView = projectedViews[k];
            calcQueryValues(projectedView, 0, projectedView.def.nodes.length - 1, queryDef, values);
          }
        }
      }
      if ((nodeDef.childMatchedQueries & queryDef.filterId) !== queryDef.filterId) {
        i += nodeDef.childCount;
      }
    }
    return values;
  }
  function getQueryValue(view, nodeDef, queryValueType) {
    if (queryValueType != null) {
      var value = void 0;
      switch (queryValueType) {
        case 1:
          value = asElementData(view, nodeDef.index).renderElement;
          break;
        case 0:
          value = new ElementRef(asElementData(view, nodeDef.index).renderElement);
          break;
        case 2:
          value = asElementData(view, nodeDef.index).template;
          break;
        case 3:
          value = asElementData(view, nodeDef.index).viewContainer;
          break;
        case 4:
          value = asProviderData(view, nodeDef.index).instance;
          break;
      }
      return value;
    }
  }
  function ngContentDef(ngContentIndex, index) {
    return {
      index: -1,
      parent: null,
      renderParent: null,
      bindingIndex: -1,
      outputIndex: -1,
      flags: 8,
      childFlags: 0,
      directChildFlags: 0,
      childMatchedQueries: 0,
      matchedQueries: {},
      matchedQueryIds: 0,
      references: {},
      ngContentIndex: ngContentIndex,
      childCount: 0,
      bindings: [],
      bindingFlags: 0,
      outputs: [],
      element: null,
      provider: null,
      text: null,
      query: null,
      ngContent: {index: index}
    };
  }
  function appendNgContent(view, renderHost, def) {
    var parentEl = getParentRenderElement(view, renderHost, def);
    if (!parentEl) {
      return;
    }
    var ngContentIndex = ((def.ngContent)).index;
    visitProjectedRenderNodes(view, ngContentIndex, 1, parentEl, null, undefined);
  }
  function purePipeDef(argCount) {
    return _pureExpressionDef(128, new Array(argCount + 1));
  }
  function pureArrayDef(argCount) {
    return _pureExpressionDef(32, new Array(argCount));
  }
  function pureObjectDef(propToIndex) {
    var keys = Object.keys(propToIndex);
    var nbKeys = keys.length;
    var propertyNames = new Array(nbKeys);
    for (var i = 0; i < nbKeys; i++) {
      var key = keys[i];
      var index = propToIndex[key];
      propertyNames[index] = key;
    }
    return _pureExpressionDef(64, propertyNames);
  }
  function _pureExpressionDef(flags, propertyNames) {
    var bindings = new Array(propertyNames.length);
    for (var i = 0; i < propertyNames.length; i++) {
      var prop = propertyNames[i];
      bindings[i] = {
        flags: 8,
        name: prop,
        ns: null,
        nonMinifiedName: prop,
        securityContext: null,
        suffix: null
      };
    }
    return {
      index: -1,
      parent: null,
      renderParent: null,
      bindingIndex: -1,
      outputIndex: -1,
      flags: flags,
      childFlags: 0,
      directChildFlags: 0,
      childMatchedQueries: 0,
      matchedQueries: {},
      matchedQueryIds: 0,
      references: {},
      ngContentIndex: -1,
      childCount: 0,
      bindings: bindings,
      bindingFlags: calcBindingFlags(bindings),
      outputs: [],
      element: null,
      provider: null,
      text: null,
      query: null,
      ngContent: null
    };
  }
  function createPureExpression(view, def) {
    return {value: undefined};
  }
  function checkAndUpdatePureExpressionInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
    var bindings = def.bindings;
    var changed = false;
    var bindLen = bindings.length;
    if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))
      changed = true;
    if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))
      changed = true;
    if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))
      changed = true;
    if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))
      changed = true;
    if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))
      changed = true;
    if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))
      changed = true;
    if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))
      changed = true;
    if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))
      changed = true;
    if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))
      changed = true;
    if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))
      changed = true;
    if (changed) {
      var data = asPureExpressionData(view, def.index);
      var value = void 0;
      switch (def.flags & 201347067) {
        case 32:
          value = new Array(bindings.length);
          if (bindLen > 0)
            value[0] = v0;
          if (bindLen > 1)
            value[1] = v1;
          if (bindLen > 2)
            value[2] = v2;
          if (bindLen > 3)
            value[3] = v3;
          if (bindLen > 4)
            value[4] = v4;
          if (bindLen > 5)
            value[5] = v5;
          if (bindLen > 6)
            value[6] = v6;
          if (bindLen > 7)
            value[7] = v7;
          if (bindLen > 8)
            value[8] = v8;
          if (bindLen > 9)
            value[9] = v9;
          break;
        case 64:
          value = {};
          if (bindLen > 0)
            value[((bindings[0].name))] = v0;
          if (bindLen > 1)
            value[((bindings[1].name))] = v1;
          if (bindLen > 2)
            value[((bindings[2].name))] = v2;
          if (bindLen > 3)
            value[((bindings[3].name))] = v3;
          if (bindLen > 4)
            value[((bindings[4].name))] = v4;
          if (bindLen > 5)
            value[((bindings[5].name))] = v5;
          if (bindLen > 6)
            value[((bindings[6].name))] = v6;
          if (bindLen > 7)
            value[((bindings[7].name))] = v7;
          if (bindLen > 8)
            value[((bindings[8].name))] = v8;
          if (bindLen > 9)
            value[((bindings[9].name))] = v9;
          break;
        case 128:
          var pipe = v0;
          switch (bindLen) {
            case 1:
              value = pipe.transform(v0);
              break;
            case 2:
              value = pipe.transform(v1);
              break;
            case 3:
              value = pipe.transform(v1, v2);
              break;
            case 4:
              value = pipe.transform(v1, v2, v3);
              break;
            case 5:
              value = pipe.transform(v1, v2, v3, v4);
              break;
            case 6:
              value = pipe.transform(v1, v2, v3, v4, v5);
              break;
            case 7:
              value = pipe.transform(v1, v2, v3, v4, v5, v6);
              break;
            case 8:
              value = pipe.transform(v1, v2, v3, v4, v5, v6, v7);
              break;
            case 9:
              value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8);
              break;
            case 10:
              value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8, v9);
              break;
          }
          break;
      }
      data.value = value;
    }
    return changed;
  }
  function checkAndUpdatePureExpressionDynamic(view, def, values) {
    var bindings = def.bindings;
    var changed = false;
    for (var i = 0; i < values.length; i++) {
      if (checkAndUpdateBinding(view, def, i, values[i])) {
        changed = true;
      }
    }
    if (changed) {
      var data = asPureExpressionData(view, def.index);
      var value = void 0;
      switch (def.flags & 201347067) {
        case 32:
          value = values;
          break;
        case 64:
          value = {};
          for (var i = 0; i < values.length; i++) {
            value[((bindings[i].name))] = values[i];
          }
          break;
        case 128:
          var pipe = values[0];
          var params = values.slice(1);
          value = pipe.transform.apply(pipe, params);
          break;
      }
      data.value = value;
    }
    return changed;
  }
  function textDef(ngContentIndex, constants) {
    var bindings = new Array(constants.length - 1);
    for (var i = 1; i < constants.length; i++) {
      bindings[i - 1] = {
        flags: 8,
        name: null,
        ns: null,
        nonMinifiedName: null,
        securityContext: null,
        suffix: constants[i]
      };
    }
    var flags = 2;
    return {
      index: -1,
      parent: null,
      renderParent: null,
      bindingIndex: -1,
      outputIndex: -1,
      flags: flags,
      childFlags: 0,
      directChildFlags: 0,
      childMatchedQueries: 0,
      matchedQueries: {},
      matchedQueryIds: 0,
      references: {},
      ngContentIndex: ngContentIndex,
      childCount: 0,
      bindings: bindings,
      bindingFlags: calcBindingFlags(bindings),
      outputs: [],
      element: null,
      provider: null,
      text: {prefix: constants[0]},
      query: null,
      ngContent: null
    };
  }
  function createText(view, renderHost, def) {
    var renderNode$$1;
    var renderer = view.renderer;
    renderNode$$1 = renderer.createText(((def.text)).prefix);
    var parentEl = getParentRenderElement(view, renderHost, def);
    if (parentEl) {
      renderer.appendChild(parentEl, renderNode$$1);
    }
    return {renderText: renderNode$$1};
  }
  function checkAndUpdateTextInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
    var changed = false;
    var bindings = def.bindings;
    var bindLen = bindings.length;
    if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))
      changed = true;
    if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))
      changed = true;
    if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))
      changed = true;
    if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))
      changed = true;
    if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))
      changed = true;
    if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))
      changed = true;
    if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))
      changed = true;
    if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))
      changed = true;
    if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))
      changed = true;
    if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))
      changed = true;
    if (changed) {
      var value = ((def.text)).prefix;
      if (bindLen > 0)
        value += _addInterpolationPart(v0, bindings[0]);
      if (bindLen > 1)
        value += _addInterpolationPart(v1, bindings[1]);
      if (bindLen > 2)
        value += _addInterpolationPart(v2, bindings[2]);
      if (bindLen > 3)
        value += _addInterpolationPart(v3, bindings[3]);
      if (bindLen > 4)
        value += _addInterpolationPart(v4, bindings[4]);
      if (bindLen > 5)
        value += _addInterpolationPart(v5, bindings[5]);
      if (bindLen > 6)
        value += _addInterpolationPart(v6, bindings[6]);
      if (bindLen > 7)
        value += _addInterpolationPart(v7, bindings[7]);
      if (bindLen > 8)
        value += _addInterpolationPart(v8, bindings[8]);
      if (bindLen > 9)
        value += _addInterpolationPart(v9, bindings[9]);
      var renderNode$$1 = asTextData(view, def.index).renderText;
      view.renderer.setValue(renderNode$$1, value);
    }
    return changed;
  }
  function checkAndUpdateTextDynamic(view, def, values) {
    var bindings = def.bindings;
    var changed = false;
    for (var i = 0; i < values.length; i++) {
      if (checkAndUpdateBinding(view, def, i, values[i])) {
        changed = true;
      }
    }
    if (changed) {
      var value = '';
      for (var i = 0; i < values.length; i++) {
        value = value + _addInterpolationPart(values[i], bindings[i]);
      }
      value = ((def.text)).prefix + value;
      var renderNode$$1 = asTextData(view, def.index).renderText;
      view.renderer.setValue(renderNode$$1, value);
    }
    return changed;
  }
  function _addInterpolationPart(value, binding) {
    var valueStr = value != null ? value.toString() : '';
    return valueStr + binding.suffix;
  }
  function viewDef(flags, nodes, updateDirectives, updateRenderer) {
    var viewBindingCount = 0;
    var viewDisposableCount = 0;
    var viewNodeFlags = 0;
    var viewRootNodeFlags = 0;
    var viewMatchedQueries = 0;
    var currentParent = null;
    var currentElementHasPublicProviders = false;
    var currentElementHasPrivateProviders = false;
    var lastRenderRootNode = null;
    for (var i = 0; i < nodes.length; i++) {
      while (currentParent && i > currentParent.index + currentParent.childCount) {
        var newParent = currentParent.parent;
        if (newParent) {
          newParent.childFlags |= ((currentParent.childFlags));
          newParent.childMatchedQueries |= currentParent.childMatchedQueries;
        }
        currentParent = newParent;
      }
      var node = nodes[i];
      node.index = i;
      node.parent = currentParent;
      node.bindingIndex = viewBindingCount;
      node.outputIndex = viewDisposableCount;
      var currentRenderParent = void 0;
      if (currentParent && currentParent.flags & 1 && !((currentParent.element)).name) {
        currentRenderParent = currentParent.renderParent;
      } else {
        currentRenderParent = currentParent;
      }
      node.renderParent = currentRenderParent;
      if (node.element) {
        var elDef = node.element;
        elDef.publicProviders = currentParent ? ((currentParent.element)).publicProviders : Object.create(null);
        elDef.allProviders = elDef.publicProviders;
        currentElementHasPublicProviders = false;
        currentElementHasPrivateProviders = false;
      }
      validateNode(currentParent, node, nodes.length);
      viewNodeFlags |= node.flags;
      viewMatchedQueries |= node.matchedQueryIds;
      if (node.element && node.element.template) {
        viewMatchedQueries |= node.element.template.nodeMatchedQueries;
      }
      if (currentParent) {
        currentParent.childFlags |= node.flags;
        currentParent.directChildFlags |= node.flags;
        currentParent.childMatchedQueries |= node.matchedQueryIds;
        if (node.element && node.element.template) {
          currentParent.childMatchedQueries |= node.element.template.nodeMatchedQueries;
        }
      } else {
        viewRootNodeFlags |= node.flags;
      }
      viewBindingCount += node.bindings.length;
      viewDisposableCount += node.outputs.length;
      if (!currentRenderParent && (node.flags & 3)) {
        lastRenderRootNode = node;
      }
      if (node.flags & 20224) {
        if (!currentElementHasPublicProviders) {
          currentElementHasPublicProviders = true;
          ((((currentParent)).element)).publicProviders = Object.create(((((currentParent)).element)).publicProviders);
          ((((currentParent)).element)).allProviders = ((((currentParent)).element)).publicProviders;
        }
        var isPrivateService = (node.flags & 8192) !== 0;
        var isComponent = (node.flags & 32768) !== 0;
        if (!isPrivateService || isComponent) {
          ((((((currentParent)).element)).publicProviders))[tokenKey(((node.provider)).token)] = node;
        } else {
          if (!currentElementHasPrivateProviders) {
            currentElementHasPrivateProviders = true;
            ((((currentParent)).element)).allProviders = Object.create(((((currentParent)).element)).publicProviders);
          }
          ((((((currentParent)).element)).allProviders))[tokenKey(((node.provider)).token)] = node;
        }
        if (isComponent) {
          ((((currentParent)).element)).componentProvider = node;
        }
      }
      if (node.childCount) {
        currentParent = node;
      }
    }
    while (currentParent) {
      var newParent = currentParent.parent;
      if (newParent) {
        newParent.childFlags |= currentParent.childFlags;
        newParent.childMatchedQueries |= currentParent.childMatchedQueries;
      }
      currentParent = newParent;
    }
    var handleEvent = function(view, nodeIndex, eventName, event) {
      return ((((nodes[nodeIndex].element)).handleEvent))(view, eventName, event);
    };
    return {
      factory: null,
      nodeFlags: viewNodeFlags,
      rootNodeFlags: viewRootNodeFlags,
      nodeMatchedQueries: viewMatchedQueries,
      flags: flags,
      nodes: nodes,
      updateDirectives: updateDirectives || NOOP,
      updateRenderer: updateRenderer || NOOP,
      handleEvent: handleEvent || NOOP,
      bindingCount: viewBindingCount,
      outputCount: viewDisposableCount,
      lastRenderRootNode: lastRenderRootNode
    };
  }
  function validateNode(parent, node, nodeCount) {
    var template = node.element && node.element.template;
    if (template) {
      if (!template.lastRenderRootNode) {
        throw new Error("Illegal State: Embedded templates without nodes are not allowed!");
      }
      if (template.lastRenderRootNode && template.lastRenderRootNode.flags & 16777216) {
        throw new Error("Illegal State: Last root node of a template can't have embedded views, at index " + node.index + "!");
      }
    }
    if (node.flags & 20224) {
      var parentFlags = parent ? parent.flags : 0;
      if ((parentFlags & 1) === 0) {
        throw new Error("Illegal State: Provider/Directive nodes need to be children of elements or anchors, at index " + node.index + "!");
      }
    }
    if (node.query) {
      if (node.flags & 67108864 && (!parent || (parent.flags & 16384) === 0)) {
        throw new Error("Illegal State: Content Query nodes need to be children of directives, at index " + node.index + "!");
      }
      if (node.flags & 134217728 && parent) {
        throw new Error("Illegal State: View Query nodes have to be top level nodes, at index " + node.index + "!");
      }
    }
    if (node.childCount) {
      var parentEnd = parent ? parent.index + parent.childCount : nodeCount - 1;
      if (node.index <= parentEnd && node.index + node.childCount > parentEnd) {
        throw new Error("Illegal State: childCount of node leads outside of parent, at index " + node.index + "!");
      }
    }
  }
  function createEmbeddedView(parent, anchorDef$$1, viewDef, context) {
    var view = createView(parent.root, parent.renderer, parent, anchorDef$$1, viewDef);
    initView(view, parent.component, context);
    createViewNodes(view);
    return view;
  }
  function createRootView(root, def, context) {
    var view = createView(root, root.renderer, null, null, def);
    initView(view, context, context);
    createViewNodes(view);
    return view;
  }
  function createComponentView(parentView, nodeDef, viewDef, hostElement) {
    var rendererType = ((nodeDef.element)).componentRendererType;
    var compRenderer;
    if (!rendererType) {
      compRenderer = parentView.root.renderer;
    } else {
      compRenderer = parentView.root.rendererFactory.createRenderer(hostElement, rendererType);
    }
    return createView(parentView.root, compRenderer, parentView, ((nodeDef.element)).componentProvider, viewDef);
  }
  function createView(root, renderer, parent, parentNodeDef, def) {
    var nodes = new Array(def.nodes.length);
    var disposables = def.outputCount ? new Array(def.outputCount) : null;
    var view = {
      def: def,
      parent: parent,
      viewContainerParent: null,
      parentNodeDef: parentNodeDef,
      context: null,
      component: null,
      nodes: nodes,
      state: 13,
      root: root,
      renderer: renderer,
      oldValues: new Array(def.bindingCount),
      disposables: disposables
    };
    return view;
  }
  function initView(view, component, context) {
    view.component = component;
    view.context = context;
  }
  function createViewNodes(view) {
    var renderHost;
    if (isComponentView(view)) {
      var hostDef = view.parentNodeDef;
      renderHost = asElementData(((view.parent)), ((((hostDef)).parent)).index).renderElement;
    }
    var def = view.def;
    var nodes = view.nodes;
    for (var i = 0; i < def.nodes.length; i++) {
      var nodeDef = def.nodes[i];
      Services.setCurrentNode(view, i);
      var nodeData = void 0;
      switch (nodeDef.flags & 201347067) {
        case 1:
          var el = (createElement(view, renderHost, nodeDef));
          var componentView = ((undefined));
          if (nodeDef.flags & 33554432) {
            var compViewDef = resolveDefinition(((((nodeDef.element)).componentView)));
            componentView = Services.createComponentView(view, nodeDef, compViewDef, el);
          }
          listenToElementOutputs(view, componentView, nodeDef, el);
          nodeData = ({
            renderElement: el,
            componentView: componentView,
            viewContainer: null,
            template: ((nodeDef.element)).template ? createTemplateData(view, nodeDef) : undefined
          });
          if (nodeDef.flags & 16777216) {
            nodeData.viewContainer = createViewContainerData(view, nodeDef, nodeData);
          }
          break;
        case 2:
          nodeData = (createText(view, renderHost, nodeDef));
          break;
        case 512:
        case 1024:
        case 2048:
        case 256:
          {
            var instance = createProviderInstance(view, nodeDef);
            nodeData = ({instance: instance});
            break;
          }
        case 16:
          {
            var instance = createPipeInstance(view, nodeDef);
            nodeData = ({instance: instance});
            break;
          }
        case 16384:
          {
            var instance = createDirectiveInstance(view, nodeDef);
            nodeData = ({instance: instance});
            if (nodeDef.flags & 32768) {
              var compView = asElementData(view, ((nodeDef.parent)).index).componentView;
              initView(compView, instance, instance);
            }
            break;
          }
        case 32:
        case 64:
        case 128:
          nodeData = (createPureExpression(view, nodeDef));
          break;
        case 67108864:
        case 134217728:
          nodeData = (createQuery());
          break;
        case 8:
          appendNgContent(view, renderHost, nodeDef);
          nodeData = undefined;
          break;
      }
      nodes[i] = nodeData;
    }
    execComponentViewsAction(view, ViewAction.CreateViewNodes);
    execQueriesAction(view, 67108864 | 134217728, 268435456, 0);
  }
  function checkNoChangesView(view) {
    markProjectedViewsForCheck(view);
    Services.updateDirectives(view, 1);
    execEmbeddedViewsAction(view, ViewAction.CheckNoChanges);
    Services.updateRenderer(view, 1);
    execComponentViewsAction(view, ViewAction.CheckNoChanges);
    view.state &= ~(64 | 32);
  }
  function checkAndUpdateView(view) {
    if (view.state & 1) {
      view.state &= ~1;
      view.state |= 2;
    } else {
      view.state &= ~2;
    }
    markProjectedViewsForCheck(view);
    Services.updateDirectives(view, 0);
    execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate);
    execQueriesAction(view, 67108864, 536870912, 0);
    callLifecycleHooksChildrenFirst(view, 2097152 | (view.state & 2 ? 1048576 : 0));
    Services.updateRenderer(view, 0);
    execComponentViewsAction(view, ViewAction.CheckAndUpdate);
    execQueriesAction(view, 134217728, 536870912, 0);
    callLifecycleHooksChildrenFirst(view, 8388608 | (view.state & 2 ? 4194304 : 0));
    if (view.def.flags & 2) {
      view.state &= ~8;
    }
    view.state &= ~(64 | 32);
  }
  function checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
    if (argStyle === 0) {
      return checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    } else {
      return checkAndUpdateNodeDynamic(view, nodeDef, v0);
    }
  }
  function markProjectedViewsForCheck(view) {
    var def = view.def;
    if (!(def.nodeFlags & 4)) {
      return;
    }
    for (var i = 0; i < def.nodes.length; i++) {
      var nodeDef = def.nodes[i];
      if (nodeDef.flags & 4) {
        var projectedViews = asElementData(view, i).template._projectedViews;
        if (projectedViews) {
          for (var i_1 = 0; i_1 < projectedViews.length; i_1++) {
            var projectedView = projectedViews[i_1];
            projectedView.state |= 32;
            markParentViewsForCheckProjectedViews(projectedView, view);
          }
        }
      } else if ((nodeDef.childFlags & 4) === 0) {
        i += nodeDef.childCount;
      }
    }
  }
  function checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
    var changed = false;
    switch (nodeDef.flags & 201347067) {
      case 1:
        changed = checkAndUpdateElementInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
        break;
      case 2:
        changed = checkAndUpdateTextInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
        break;
      case 16384:
        changed = checkAndUpdateDirectiveInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
        break;
      case 32:
      case 64:
      case 128:
        changed = checkAndUpdatePureExpressionInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
        break;
    }
    return changed;
  }
  function checkAndUpdateNodeDynamic(view, nodeDef, values) {
    var changed = false;
    switch (nodeDef.flags & 201347067) {
      case 1:
        changed = checkAndUpdateElementDynamic(view, nodeDef, values);
        break;
      case 2:
        changed = checkAndUpdateTextDynamic(view, nodeDef, values);
        break;
      case 16384:
        changed = checkAndUpdateDirectiveDynamic(view, nodeDef, values);
        break;
      case 32:
      case 64:
      case 128:
        changed = checkAndUpdatePureExpressionDynamic(view, nodeDef, values);
        break;
    }
    if (changed) {
      var bindLen = nodeDef.bindings.length;
      var bindingStart = nodeDef.bindingIndex;
      var oldValues = view.oldValues;
      for (var i = 0; i < bindLen; i++) {
        oldValues[bindingStart + i] = values[i];
      }
    }
    return changed;
  }
  function checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
    if (argStyle === 0) {
      checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    } else {
      checkNoChangesNodeDynamic(view, nodeDef, v0);
    }
    return false;
  }
  function checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
    var bindLen = nodeDef.bindings.length;
    if (bindLen > 0)
      checkBindingNoChanges(view, nodeDef, 0, v0);
    if (bindLen > 1)
      checkBindingNoChanges(view, nodeDef, 1, v1);
    if (bindLen > 2)
      checkBindingNoChanges(view, nodeDef, 2, v2);
    if (bindLen > 3)
      checkBindingNoChanges(view, nodeDef, 3, v3);
    if (bindLen > 4)
      checkBindingNoChanges(view, nodeDef, 4, v4);
    if (bindLen > 5)
      checkBindingNoChanges(view, nodeDef, 5, v5);
    if (bindLen > 6)
      checkBindingNoChanges(view, nodeDef, 6, v6);
    if (bindLen > 7)
      checkBindingNoChanges(view, nodeDef, 7, v7);
    if (bindLen > 8)
      checkBindingNoChanges(view, nodeDef, 8, v8);
    if (bindLen > 9)
      checkBindingNoChanges(view, nodeDef, 9, v9);
  }
  function checkNoChangesNodeDynamic(view, nodeDef, values) {
    for (var i = 0; i < values.length; i++) {
      checkBindingNoChanges(view, nodeDef, i, values[i]);
    }
  }
  function checkNoChangesQuery(view, nodeDef) {
    var queryList = asQueryList(view, nodeDef.index);
    if (queryList.dirty) {
      throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, nodeDef.index), "Query " + ((nodeDef.query)).id + " not dirty", "Query " + ((nodeDef.query)).id + " dirty", (view.state & 1) !== 0);
    }
  }
  function destroyView(view) {
    if (view.state & 128) {
      return;
    }
    execEmbeddedViewsAction(view, ViewAction.Destroy);
    execComponentViewsAction(view, ViewAction.Destroy);
    callLifecycleHooksChildrenFirst(view, 131072);
    if (view.disposables) {
      for (var i = 0; i < view.disposables.length; i++) {
        view.disposables[i]();
      }
    }
    detachProjectedView(view);
    if (view.renderer.destroyNode) {
      destroyViewNodes(view);
    }
    if (isComponentView(view)) {
      view.renderer.destroy();
    }
    view.state |= 128;
  }
  function destroyViewNodes(view) {
    var len = view.def.nodes.length;
    for (var i = 0; i < len; i++) {
      var def = view.def.nodes[i];
      if (def.flags & 1) {
        ((view.renderer.destroyNode))(asElementData(view, i).renderElement);
      } else if (def.flags & 2) {
        ((view.renderer.destroyNode))(asTextData(view, i).renderText);
      }
    }
  }
  var ViewAction = {};
  ViewAction.CreateViewNodes = 0;
  ViewAction.CheckNoChanges = 1;
  ViewAction.CheckNoChangesProjectedViews = 2;
  ViewAction.CheckAndUpdate = 3;
  ViewAction.CheckAndUpdateProjectedViews = 4;
  ViewAction.Destroy = 5;
  ViewAction[ViewAction.CreateViewNodes] = "CreateViewNodes";
  ViewAction[ViewAction.CheckNoChanges] = "CheckNoChanges";
  ViewAction[ViewAction.CheckNoChangesProjectedViews] = "CheckNoChangesProjectedViews";
  ViewAction[ViewAction.CheckAndUpdate] = "CheckAndUpdate";
  ViewAction[ViewAction.CheckAndUpdateProjectedViews] = "CheckAndUpdateProjectedViews";
  ViewAction[ViewAction.Destroy] = "Destroy";
  function execComponentViewsAction(view, action) {
    var def = view.def;
    if (!(def.nodeFlags & 33554432)) {
      return;
    }
    for (var i = 0; i < def.nodes.length; i++) {
      var nodeDef = def.nodes[i];
      if (nodeDef.flags & 33554432) {
        callViewAction(asElementData(view, i).componentView, action);
      } else if ((nodeDef.childFlags & 33554432) === 0) {
        i += nodeDef.childCount;
      }
    }
  }
  function execEmbeddedViewsAction(view, action) {
    var def = view.def;
    if (!(def.nodeFlags & 16777216)) {
      return;
    }
    for (var i = 0; i < def.nodes.length; i++) {
      var nodeDef = def.nodes[i];
      if (nodeDef.flags & 16777216) {
        var embeddedViews = ((asElementData(view, i).viewContainer))._embeddedViews;
        for (var k = 0; k < embeddedViews.length; k++) {
          callViewAction(embeddedViews[k], action);
        }
      } else if ((nodeDef.childFlags & 16777216) === 0) {
        i += nodeDef.childCount;
      }
    }
  }
  function callViewAction(view, action) {
    var viewState = view.state;
    switch (action) {
      case ViewAction.CheckNoChanges:
        if ((viewState & 128) === 0) {
          if ((viewState & 12) === 12) {
            checkNoChangesView(view);
          } else if (viewState & 64) {
            execProjectedViewsAction(view, ViewAction.CheckNoChangesProjectedViews);
          }
        }
        break;
      case ViewAction.CheckNoChangesProjectedViews:
        if ((viewState & 128) === 0) {
          if (viewState & 32) {
            checkNoChangesView(view);
          } else if (viewState & 64) {
            execProjectedViewsAction(view, action);
          }
        }
        break;
      case ViewAction.CheckAndUpdate:
        if ((viewState & 128) === 0) {
          if ((viewState & 12) === 12) {
            checkAndUpdateView(view);
          } else if (viewState & 64) {
            execProjectedViewsAction(view, ViewAction.CheckAndUpdateProjectedViews);
          }
        }
        break;
      case ViewAction.CheckAndUpdateProjectedViews:
        if ((viewState & 128) === 0) {
          if (viewState & 32) {
            checkAndUpdateView(view);
          } else if (viewState & 64) {
            execProjectedViewsAction(view, action);
          }
        }
        break;
      case ViewAction.Destroy:
        destroyView(view);
        break;
      case ViewAction.CreateViewNodes:
        createViewNodes(view);
        break;
    }
  }
  function execProjectedViewsAction(view, action) {
    execEmbeddedViewsAction(view, action);
    execComponentViewsAction(view, action);
  }
  function execQueriesAction(view, queryFlags, staticDynamicQueryFlag, checkType) {
    if (!(view.def.nodeFlags & queryFlags) || !(view.def.nodeFlags & staticDynamicQueryFlag)) {
      return;
    }
    var nodeCount = view.def.nodes.length;
    for (var i = 0; i < nodeCount; i++) {
      var nodeDef = view.def.nodes[i];
      if ((nodeDef.flags & queryFlags) && (nodeDef.flags & staticDynamicQueryFlag)) {
        Services.setCurrentNode(view, nodeDef.index);
        switch (checkType) {
          case 0:
            checkAndUpdateQuery(view, nodeDef);
            break;
          case 1:
            checkNoChangesQuery(view, nodeDef);
            break;
        }
      }
      if (!(nodeDef.childFlags & queryFlags) || !(nodeDef.childFlags & staticDynamicQueryFlag)) {
        i += nodeDef.childCount;
      }
    }
  }
  var initialized = false;
  function initServicesIfNeeded() {
    if (initialized) {
      return;
    }
    initialized = true;
    var services = isDevMode() ? createDebugServices() : createProdServices();
    Services.setCurrentNode = services.setCurrentNode;
    Services.createRootView = services.createRootView;
    Services.createEmbeddedView = services.createEmbeddedView;
    Services.createComponentView = services.createComponentView;
    Services.createNgModuleRef = services.createNgModuleRef;
    Services.overrideProvider = services.overrideProvider;
    Services.clearProviderOverrides = services.clearProviderOverrides;
    Services.checkAndUpdateView = services.checkAndUpdateView;
    Services.checkNoChangesView = services.checkNoChangesView;
    Services.destroyView = services.destroyView;
    Services.resolveDep = resolveDep;
    Services.createDebugContext = services.createDebugContext;
    Services.handleEvent = services.handleEvent;
    Services.updateDirectives = services.updateDirectives;
    Services.updateRenderer = services.updateRenderer;
    Services.dirtyParentQueries = dirtyParentQueries;
  }
  function createProdServices() {
    return {
      setCurrentNode: function() {},
      createRootView: createProdRootView,
      createEmbeddedView: createEmbeddedView,
      createComponentView: createComponentView,
      createNgModuleRef: createNgModuleRef,
      overrideProvider: NOOP,
      clearProviderOverrides: NOOP,
      checkAndUpdateView: checkAndUpdateView,
      checkNoChangesView: checkNoChangesView,
      destroyView: destroyView,
      createDebugContext: function(view, nodeIndex) {
        return new DebugContext_(view, nodeIndex);
      },
      handleEvent: function(view, nodeIndex, eventName, event) {
        return view.def.handleEvent(view, nodeIndex, eventName, event);
      },
      updateDirectives: function(view, checkType) {
        return view.def.updateDirectives(checkType === 0 ? prodCheckAndUpdateNode : prodCheckNoChangesNode, view);
      },
      updateRenderer: function(view, checkType) {
        return view.def.updateRenderer(checkType === 0 ? prodCheckAndUpdateNode : prodCheckNoChangesNode, view);
      }
    };
  }
  function createDebugServices() {
    return {
      setCurrentNode: debugSetCurrentNode,
      createRootView: debugCreateRootView,
      createEmbeddedView: debugCreateEmbeddedView,
      createComponentView: debugCreateComponentView,
      createNgModuleRef: debugCreateNgModuleRef,
      overrideProvider: debugOverrideProvider,
      clearProviderOverrides: debugClearProviderOverrides,
      checkAndUpdateView: debugCheckAndUpdateView,
      checkNoChangesView: debugCheckNoChangesView,
      destroyView: debugDestroyView,
      createDebugContext: function(view, nodeIndex) {
        return new DebugContext_(view, nodeIndex);
      },
      handleEvent: debugHandleEvent,
      updateDirectives: debugUpdateDirectives,
      updateRenderer: debugUpdateRenderer
    };
  }
  function createProdRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
    var rendererFactory = ngModule.injector.get(RendererFactory2);
    return createRootView(createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode), def, context);
  }
  function debugCreateRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
    var rendererFactory = ngModule.injector.get(RendererFactory2);
    var root = createRootData(elInjector, ngModule, new DebugRendererFactory2(rendererFactory), projectableNodes, rootSelectorOrNode);
    var defWithOverride = applyProviderOverridesToView(def);
    return callWithDebugContext(DebugAction.create, createRootView, null, [root, defWithOverride, context]);
  }
  function createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode) {
    var sanitizer = ngModule.injector.get(Sanitizer);
    var errorHandler = ngModule.injector.get(ErrorHandler);
    var renderer = rendererFactory.createRenderer(null, null);
    return {
      ngModule: ngModule,
      injector: elInjector,
      projectableNodes: projectableNodes,
      selectorOrNode: rootSelectorOrNode,
      sanitizer: sanitizer,
      rendererFactory: rendererFactory,
      renderer: renderer,
      errorHandler: errorHandler
    };
  }
  function debugCreateEmbeddedView(parentView, anchorDef, viewDef$$1, context) {
    var defWithOverride = applyProviderOverridesToView(viewDef$$1);
    return callWithDebugContext(DebugAction.create, createEmbeddedView, null, [parentView, anchorDef, defWithOverride, context]);
  }
  function debugCreateComponentView(parentView, nodeDef, viewDef$$1, hostElement) {
    var defWithOverride = applyProviderOverridesToView(viewDef$$1);
    return callWithDebugContext(DebugAction.create, createComponentView, null, [parentView, nodeDef, defWithOverride, hostElement]);
  }
  function debugCreateNgModuleRef(moduleType, parentInjector, bootstrapComponents, def) {
    var defWithOverride = applyProviderOverridesToNgModule(def);
    return createNgModuleRef(moduleType, parentInjector, bootstrapComponents, defWithOverride);
  }
  var providerOverrides = new Map();
  function debugOverrideProvider(override) {
    providerOverrides.set(override.token, override);
  }
  function debugClearProviderOverrides() {
    providerOverrides.clear();
  }
  function applyProviderOverridesToView(def) {
    if (providerOverrides.size === 0) {
      return def;
    }
    var elementIndicesWithOverwrittenProviders = findElementIndicesWithOverwrittenProviders(def);
    if (elementIndicesWithOverwrittenProviders.length === 0) {
      return def;
    }
    def = ((def.factory))(function() {
      return NOOP;
    });
    for (var i = 0; i < elementIndicesWithOverwrittenProviders.length; i++) {
      applyProviderOverridesToElement(def, elementIndicesWithOverwrittenProviders[i]);
    }
    return def;
    function findElementIndicesWithOverwrittenProviders(def) {
      var elIndicesWithOverwrittenProviders = [];
      var lastElementDef = null;
      for (var i = 0; i < def.nodes.length; i++) {
        var nodeDef = def.nodes[i];
        if (nodeDef.flags & 1) {
          lastElementDef = nodeDef;
        }
        if (lastElementDef && nodeDef.flags & 3840 && providerOverrides.has(((nodeDef.provider)).token)) {
          elIndicesWithOverwrittenProviders.push(((lastElementDef)).index);
          lastElementDef = null;
        }
      }
      return elIndicesWithOverwrittenProviders;
    }
    function applyProviderOverridesToElement(viewDef$$1, elIndex) {
      for (var i = elIndex + 1; i < viewDef$$1.nodes.length; i++) {
        var nodeDef = viewDef$$1.nodes[i];
        if (nodeDef.flags & 1) {
          return;
        }
        if (nodeDef.flags & 3840) {
          nodeDef.flags |= 4096;
          var provider = ((nodeDef.provider));
          var override = providerOverrides.get(provider.token);
          if (override) {
            nodeDef.flags = (nodeDef.flags & ~3840) | override.flags;
            provider.deps = splitDepsDsl(override.deps);
            provider.value = override.value;
          }
        }
      }
    }
  }
  function applyProviderOverridesToNgModule(def) {
    if (providerOverrides.size === 0 || !hasOverrrides(def)) {
      return def;
    }
    def = ((def.factory))(function() {
      return NOOP;
    });
    applyProviderOverrides(def);
    return def;
    function hasOverrrides(def) {
      return def.providers.some(function(node) {
        return !!(node.flags & 3840) && providerOverrides.has(node.token);
      });
    }
    function applyProviderOverrides(def) {
      for (var i = 0; i < def.providers.length; i++) {
        var provider = def.providers[i];
        provider.flags |= 4096;
        var override = providerOverrides.get(provider.token);
        if (override) {
          provider.flags = (provider.flags & ~3840) | override.flags;
          provider.deps = splitDepsDsl(override.deps);
          provider.value = override.value;
        }
      }
    }
  }
  function prodCheckAndUpdateNode(view, nodeIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
    var nodeDef = view.def.nodes[nodeIndex];
    checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    return (nodeDef.flags & 224) ? asPureExpressionData(view, nodeIndex).value : undefined;
  }
  function prodCheckNoChangesNode(view, nodeIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
    var nodeDef = view.def.nodes[nodeIndex];
    checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    return (nodeDef.flags & 224) ? asPureExpressionData(view, nodeIndex).value : undefined;
  }
  function debugCheckAndUpdateView(view) {
    return callWithDebugContext(DebugAction.detectChanges, checkAndUpdateView, null, [view]);
  }
  function debugCheckNoChangesView(view) {
    return callWithDebugContext(DebugAction.checkNoChanges, checkNoChangesView, null, [view]);
  }
  function debugDestroyView(view) {
    return callWithDebugContext(DebugAction.destroy, destroyView, null, [view]);
  }
  var DebugAction = {};
  DebugAction.create = 0;
  DebugAction.detectChanges = 1;
  DebugAction.checkNoChanges = 2;
  DebugAction.destroy = 3;
  DebugAction.handleEvent = 4;
  DebugAction[DebugAction.create] = "create";
  DebugAction[DebugAction.detectChanges] = "detectChanges";
  DebugAction[DebugAction.checkNoChanges] = "checkNoChanges";
  DebugAction[DebugAction.destroy] = "destroy";
  DebugAction[DebugAction.handleEvent] = "handleEvent";
  var _currentAction;
  var _currentView;
  var _currentNodeIndex;
  function debugSetCurrentNode(view, nodeIndex) {
    _currentView = view;
    _currentNodeIndex = nodeIndex;
  }
  function debugHandleEvent(view, nodeIndex, eventName, event) {
    debugSetCurrentNode(view, nodeIndex);
    return callWithDebugContext(DebugAction.handleEvent, view.def.handleEvent, null, [view, nodeIndex, eventName, event]);
  }
  function debugUpdateDirectives(view, checkType) {
    if (view.state & 128) {
      throw viewDestroyedError(DebugAction[_currentAction]);
    }
    debugSetCurrentNode(view, nextDirectiveWithBinding(view, 0));
    return view.def.updateDirectives(debugCheckDirectivesFn, view);
    function debugCheckDirectivesFn(view, nodeIndex, argStyle) {
      var values = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        values[_i - 3] = arguments[_i];
      }
      var nodeDef = view.def.nodes[nodeIndex];
      if (checkType === 0) {
        debugCheckAndUpdateNode(view, nodeDef, argStyle, values);
      } else {
        debugCheckNoChangesNode(view, nodeDef, argStyle, values);
      }
      if (nodeDef.flags & 16384) {
        debugSetCurrentNode(view, nextDirectiveWithBinding(view, nodeIndex));
      }
      return (nodeDef.flags & 224) ? asPureExpressionData(view, nodeDef.index).value : undefined;
    }
  }
  function debugUpdateRenderer(view, checkType) {
    if (view.state & 128) {
      throw viewDestroyedError(DebugAction[_currentAction]);
    }
    debugSetCurrentNode(view, nextRenderNodeWithBinding(view, 0));
    return view.def.updateRenderer(debugCheckRenderNodeFn, view);
    function debugCheckRenderNodeFn(view, nodeIndex, argStyle) {
      var values = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        values[_i - 3] = arguments[_i];
      }
      var nodeDef = view.def.nodes[nodeIndex];
      if (checkType === 0) {
        debugCheckAndUpdateNode(view, nodeDef, argStyle, values);
      } else {
        debugCheckNoChangesNode(view, nodeDef, argStyle, values);
      }
      if (nodeDef.flags & 3) {
        debugSetCurrentNode(view, nextRenderNodeWithBinding(view, nodeIndex));
      }
      return (nodeDef.flags & 224) ? asPureExpressionData(view, nodeDef.index).value : undefined;
    }
  }
  function debugCheckAndUpdateNode(view, nodeDef, argStyle, givenValues) {
    var changed = ((checkAndUpdateNode)).apply(void 0, [view, nodeDef, argStyle].concat(givenValues));
    if (changed) {
      var values = argStyle === 1 ? givenValues[0] : givenValues;
      if (nodeDef.flags & 16384) {
        var bindingValues = {};
        for (var i = 0; i < nodeDef.bindings.length; i++) {
          var binding = nodeDef.bindings[i];
          var value = values[i];
          if (binding.flags & 8) {
            bindingValues[normalizeDebugBindingName(((binding.nonMinifiedName)))] = normalizeDebugBindingValue(value);
          }
        }
        var elDef = ((nodeDef.parent));
        var el = asElementData(view, elDef.index).renderElement;
        if (!((elDef.element)).name) {
          view.renderer.setValue(el, "bindings=" + JSON.stringify(bindingValues, null, 2));
        } else {
          for (var attr in bindingValues) {
            var value = bindingValues[attr];
            if (value != null) {
              view.renderer.setAttribute(el, attr, value);
            } else {
              view.renderer.removeAttribute(el, attr);
            }
          }
        }
      }
    }
  }
  function debugCheckNoChangesNode(view, nodeDef, argStyle, values) {
    ((checkNoChangesNode)).apply(void 0, [view, nodeDef, argStyle].concat(values));
  }
  function normalizeDebugBindingName(name) {
    name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));
    return "ng-reflect-" + name;
  }
  var CAMEL_CASE_REGEXP = /([A-Z])/g;
  function camelCaseToDashCase(input) {
    return input.replace(CAMEL_CASE_REGEXP, function() {
      var m = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        m[_i] = arguments[_i];
      }
      return '-' + m[1].toLowerCase();
    });
  }
  function normalizeDebugBindingValue(value) {
    try {
      return value != null ? value.toString().slice(0, 30) : value;
    } catch (e) {
      return '[ERROR] Exception while trying to serialize the value';
    }
  }
  function nextDirectiveWithBinding(view, nodeIndex) {
    for (var i = nodeIndex; i < view.def.nodes.length; i++) {
      var nodeDef = view.def.nodes[i];
      if (nodeDef.flags & 16384 && nodeDef.bindings && nodeDef.bindings.length) {
        return i;
      }
    }
    return null;
  }
  function nextRenderNodeWithBinding(view, nodeIndex) {
    for (var i = nodeIndex; i < view.def.nodes.length; i++) {
      var nodeDef = view.def.nodes[i];
      if ((nodeDef.flags & 3) && nodeDef.bindings && nodeDef.bindings.length) {
        return i;
      }
    }
    return null;
  }
  var DebugContext_ = (function() {
    function DebugContext_(view, nodeIndex) {
      this.view = view;
      this.nodeIndex = nodeIndex;
      if (nodeIndex == null) {
        this.nodeIndex = nodeIndex = 0;
      }
      this.nodeDef = view.def.nodes[nodeIndex];
      var elDef = this.nodeDef;
      var elView = view;
      while (elDef && (elDef.flags & 1) === 0) {
        elDef = elDef.parent;
      }
      if (!elDef) {
        while (!elDef && elView) {
          elDef = viewParentEl(elView);
          elView = elView.parent;
        }
      }
      this.elDef = elDef;
      this.elView = elView;
    }
    Object.defineProperty(DebugContext_.prototype, "elOrCompView", {
      get: function() {
        return asElementData(this.elView, this.elDef.index).componentView || this.view;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext_.prototype, "injector", {
      get: function() {
        return createInjector(this.elView, this.elDef);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext_.prototype, "component", {
      get: function() {
        return this.elOrCompView.component;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext_.prototype, "context", {
      get: function() {
        return this.elOrCompView.context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext_.prototype, "providerTokens", {
      get: function() {
        var tokens = [];
        if (this.elDef) {
          for (var i = this.elDef.index + 1; i <= this.elDef.index + this.elDef.childCount; i++) {
            var childDef = this.elView.def.nodes[i];
            if (childDef.flags & 20224) {
              tokens.push(((childDef.provider)).token);
            }
            i += childDef.childCount;
          }
        }
        return tokens;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext_.prototype, "references", {
      get: function() {
        var references = {};
        if (this.elDef) {
          collectReferences(this.elView, this.elDef, references);
          for (var i = this.elDef.index + 1; i <= this.elDef.index + this.elDef.childCount; i++) {
            var childDef = this.elView.def.nodes[i];
            if (childDef.flags & 20224) {
              collectReferences(this.elView, childDef, references);
            }
            i += childDef.childCount;
          }
        }
        return references;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext_.prototype, "componentRenderElement", {
      get: function() {
        var elData = findHostElement(this.elOrCompView);
        return elData ? elData.renderElement : undefined;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext_.prototype, "renderNode", {
      get: function() {
        return this.nodeDef.flags & 2 ? renderNode(this.view, this.nodeDef) : renderNode(this.elView, this.elDef);
      },
      enumerable: true,
      configurable: true
    });
    DebugContext_.prototype.logError = function(console) {
      var values = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
      }
      var logViewDef;
      var logNodeIndex;
      if (this.nodeDef.flags & 2) {
        logViewDef = this.view.def;
        logNodeIndex = this.nodeDef.index;
      } else {
        logViewDef = this.elView.def;
        logNodeIndex = this.elDef.index;
      }
      var renderNodeIndex = getRenderNodeIndex(logViewDef, logNodeIndex);
      var currRenderNodeIndex = -1;
      var nodeLogger = function() {
        currRenderNodeIndex++;
        if (currRenderNodeIndex === renderNodeIndex) {
          return (_a = console.error).bind.apply(_a, [console].concat(values));
        } else {
          return NOOP;
        }
        var _a;
      };
      ((logViewDef.factory))(nodeLogger);
      if (currRenderNodeIndex < renderNodeIndex) {
        console.error('Illegal state: the ViewDefinitionFactory did not call the logger!');
        console.error.apply(console, values);
      }
    };
    return DebugContext_;
  }());
  function getRenderNodeIndex(viewDef$$1, nodeIndex) {
    var renderNodeIndex = -1;
    for (var i = 0; i <= nodeIndex; i++) {
      var nodeDef = viewDef$$1.nodes[i];
      if (nodeDef.flags & 3) {
        renderNodeIndex++;
      }
    }
    return renderNodeIndex;
  }
  function findHostElement(view) {
    while (view && !isComponentView(view)) {
      view = ((view.parent));
    }
    if (view.parent) {
      return asElementData(view.parent, ((viewParentEl(view))).index);
    }
    return null;
  }
  function collectReferences(view, nodeDef, references) {
    for (var refName in nodeDef.references) {
      references[refName] = getQueryValue(view, nodeDef, nodeDef.references[refName]);
    }
  }
  function callWithDebugContext(action, fn, self, args) {
    var oldAction = _currentAction;
    var oldView = _currentView;
    var oldNodeIndex = _currentNodeIndex;
    try {
      _currentAction = action;
      var result = fn.apply(self, args);
      _currentView = oldView;
      _currentNodeIndex = oldNodeIndex;
      _currentAction = oldAction;
      return result;
    } catch (e) {
      if (isViewDebugError(e) || !_currentView) {
        throw e;
      }
      throw viewWrappedDebugError(e, ((getCurrentDebugContext())));
    }
  }
  function getCurrentDebugContext() {
    return _currentView ? new DebugContext_(_currentView, _currentNodeIndex) : null;
  }
  var DebugRendererFactory2 = (function() {
    function DebugRendererFactory2(delegate) {
      this.delegate = delegate;
    }
    DebugRendererFactory2.prototype.createRenderer = function(element, renderData) {
      return new DebugRenderer2(this.delegate.createRenderer(element, renderData));
    };
    DebugRendererFactory2.prototype.begin = function() {
      if (this.delegate.begin) {
        this.delegate.begin();
      }
    };
    DebugRendererFactory2.prototype.end = function() {
      if (this.delegate.end) {
        this.delegate.end();
      }
    };
    DebugRendererFactory2.prototype.whenRenderingDone = function() {
      if (this.delegate.whenRenderingDone) {
        return this.delegate.whenRenderingDone();
      }
      return Promise.resolve(null);
    };
    return DebugRendererFactory2;
  }());
  var DebugRenderer2 = (function() {
    function DebugRenderer2(delegate) {
      this.delegate = delegate;
    }
    Object.defineProperty(DebugRenderer2.prototype, "data", {
      get: function() {
        return this.delegate.data;
      },
      enumerable: true,
      configurable: true
    });
    DebugRenderer2.prototype.destroyNode = function(node) {
      removeDebugNodeFromIndex(((getDebugNode(node))));
      if (this.delegate.destroyNode) {
        this.delegate.destroyNode(node);
      }
    };
    DebugRenderer2.prototype.destroy = function() {
      this.delegate.destroy();
    };
    DebugRenderer2.prototype.createElement = function(name, namespace) {
      var el = this.delegate.createElement(name, namespace);
      var debugCtx = getCurrentDebugContext();
      if (debugCtx) {
        var debugEl = new DebugElement(el, null, debugCtx);
        debugEl.name = name;
        indexDebugNode(debugEl);
      }
      return el;
    };
    DebugRenderer2.prototype.createComment = function(value) {
      var comment = this.delegate.createComment(value);
      var debugCtx = getCurrentDebugContext();
      if (debugCtx) {
        indexDebugNode(new DebugNode(comment, null, debugCtx));
      }
      return comment;
    };
    DebugRenderer2.prototype.createText = function(value) {
      var text = this.delegate.createText(value);
      var debugCtx = getCurrentDebugContext();
      if (debugCtx) {
        indexDebugNode(new DebugNode(text, null, debugCtx));
      }
      return text;
    };
    DebugRenderer2.prototype.appendChild = function(parent, newChild) {
      var debugEl = getDebugNode(parent);
      var debugChildEl = getDebugNode(newChild);
      if (debugEl && debugChildEl && debugEl instanceof DebugElement) {
        debugEl.addChild(debugChildEl);
      }
      this.delegate.appendChild(parent, newChild);
    };
    DebugRenderer2.prototype.insertBefore = function(parent, newChild, refChild) {
      var debugEl = getDebugNode(parent);
      var debugChildEl = getDebugNode(newChild);
      var debugRefEl = ((getDebugNode(refChild)));
      if (debugEl && debugChildEl && debugEl instanceof DebugElement) {
        debugEl.insertBefore(debugRefEl, debugChildEl);
      }
      this.delegate.insertBefore(parent, newChild, refChild);
    };
    DebugRenderer2.prototype.removeChild = function(parent, oldChild) {
      var debugEl = getDebugNode(parent);
      var debugChildEl = getDebugNode(oldChild);
      if (debugEl && debugChildEl && debugEl instanceof DebugElement) {
        debugEl.removeChild(debugChildEl);
      }
      this.delegate.removeChild(parent, oldChild);
    };
    DebugRenderer2.prototype.selectRootElement = function(selectorOrNode) {
      var el = this.delegate.selectRootElement(selectorOrNode);
      var debugCtx = getCurrentDebugContext();
      if (debugCtx) {
        indexDebugNode(new DebugElement(el, null, debugCtx));
      }
      return el;
    };
    DebugRenderer2.prototype.setAttribute = function(el, name, value, namespace) {
      var debugEl = getDebugNode(el);
      if (debugEl && debugEl instanceof DebugElement) {
        var fullName = namespace ? namespace + ':' + name : name;
        debugEl.attributes[fullName] = value;
      }
      this.delegate.setAttribute(el, name, value, namespace);
    };
    DebugRenderer2.prototype.removeAttribute = function(el, name, namespace) {
      var debugEl = getDebugNode(el);
      if (debugEl && debugEl instanceof DebugElement) {
        var fullName = namespace ? namespace + ':' + name : name;
        debugEl.attributes[fullName] = null;
      }
      this.delegate.removeAttribute(el, name, namespace);
    };
    DebugRenderer2.prototype.addClass = function(el, name) {
      var debugEl = getDebugNode(el);
      if (debugEl && debugEl instanceof DebugElement) {
        debugEl.classes[name] = true;
      }
      this.delegate.addClass(el, name);
    };
    DebugRenderer2.prototype.removeClass = function(el, name) {
      var debugEl = getDebugNode(el);
      if (debugEl && debugEl instanceof DebugElement) {
        debugEl.classes[name] = false;
      }
      this.delegate.removeClass(el, name);
    };
    DebugRenderer2.prototype.setStyle = function(el, style, value, flags) {
      var debugEl = getDebugNode(el);
      if (debugEl && debugEl instanceof DebugElement) {
        debugEl.styles[style] = value;
      }
      this.delegate.setStyle(el, style, value, flags);
    };
    DebugRenderer2.prototype.removeStyle = function(el, style, flags) {
      var debugEl = getDebugNode(el);
      if (debugEl && debugEl instanceof DebugElement) {
        debugEl.styles[style] = null;
      }
      this.delegate.removeStyle(el, style, flags);
    };
    DebugRenderer2.prototype.setProperty = function(el, name, value) {
      var debugEl = getDebugNode(el);
      if (debugEl && debugEl instanceof DebugElement) {
        debugEl.properties[name] = value;
      }
      this.delegate.setProperty(el, name, value);
    };
    DebugRenderer2.prototype.listen = function(target, eventName, callback) {
      if (typeof target !== 'string') {
        var debugEl = getDebugNode(target);
        if (debugEl) {
          debugEl.listeners.push(new EventListener(eventName, callback));
        }
      }
      return this.delegate.listen(target, eventName, callback);
    };
    DebugRenderer2.prototype.parentNode = function(node) {
      return this.delegate.parentNode(node);
    };
    DebugRenderer2.prototype.nextSibling = function(node) {
      return this.delegate.nextSibling(node);
    };
    DebugRenderer2.prototype.setValue = function(node, value) {
      return this.delegate.setValue(node, value);
    };
    return DebugRenderer2;
  }());
  function overrideProvider(override) {
    initServicesIfNeeded();
    return Services.overrideProvider(override);
  }
  function clearProviderOverrides() {
    initServicesIfNeeded();
    return Services.clearProviderOverrides();
  }
  function createNgModuleFactory(ngModuleType, bootstrapComponents, defFactory) {
    return new NgModuleFactory_(ngModuleType, bootstrapComponents, defFactory);
  }
  var NgModuleFactory_ = (function(_super) {
    __extends(NgModuleFactory_, _super);
    function NgModuleFactory_(moduleType, _bootstrapComponents, _ngModuleDefFactory) {
      var _this = _super.call(this) || this;
      _this.moduleType = moduleType;
      _this._bootstrapComponents = _bootstrapComponents;
      _this._ngModuleDefFactory = _ngModuleDefFactory;
      return _this;
    }
    NgModuleFactory_.prototype.create = function(parentInjector) {
      initServicesIfNeeded();
      var def = resolveDefinition(this._ngModuleDefFactory);
      return Services.createNgModuleRef(this.moduleType, parentInjector || Injector.NULL, this._bootstrapComponents, def);
    };
    return NgModuleFactory_;
  }(NgModuleFactory));
  function trigger$1(name, definitions) {
    return {
      type: 7,
      name: name,
      definitions: definitions,
      options: {}
    };
  }
  function animate$1(timings, styles) {
    if (styles === void 0) {
      styles = null;
    }
    return {
      type: 4,
      styles: styles,
      timings: timings
    };
  }
  function group$1(steps, options) {
    if (options === void 0) {
      options = null;
    }
    return {
      type: 3,
      steps: steps,
      options: options
    };
  }
  function sequence$1(steps, options) {
    if (options === void 0) {
      options = null;
    }
    return {
      type: 2,
      steps: steps,
      options: options
    };
  }
  function style$1(tokens) {
    return {
      type: 6,
      styles: tokens,
      offset: null
    };
  }
  function state$1(name, styles, options) {
    return {
      type: 0,
      name: name,
      styles: styles,
      options: options
    };
  }
  function keyframes$1(steps) {
    return {
      type: 5,
      steps: steps
    };
  }
  function transition$1(stateChangeExpr, steps, options) {
    if (options === void 0) {
      options = null;
    }
    return {
      type: 1,
      expr: stateChangeExpr,
      animation: steps,
      options: options
    };
  }
  var AUTO_STYLE$$1 = '*';
  function trigger$$1(name, definitions) {
    return trigger$1(name, definitions);
  }
  function animate$$1(timings, styles) {
    return animate$1(timings, styles);
  }
  function group$$1(steps) {
    return group$1(steps);
  }
  function sequence$$1(steps) {
    return sequence$1(steps);
  }
  function style$$1(tokens) {
    return style$1(tokens);
  }
  function state$$1(name, styles) {
    return state$1(name, styles);
  }
  function keyframes$$1(steps) {
    return keyframes$1(steps);
  }
  function transition$$1(stateChangeExpr, steps) {
    return transition$1(stateChangeExpr, steps);
  }
  exports.Class = Class;
  exports.createPlatform = createPlatform;
  exports.assertPlatform = assertPlatform;
  exports.destroyPlatform = destroyPlatform;
  exports.getPlatform = getPlatform;
  exports.PlatformRef = PlatformRef;
  exports.ApplicationRef = ApplicationRef;
  exports.enableProdMode = enableProdMode;
  exports.isDevMode = isDevMode;
  exports.createPlatformFactory = createPlatformFactory;
  exports.NgProbeToken = NgProbeToken;
  exports.APP_ID = APP_ID;
  exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;
  exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;
  exports.PLATFORM_ID = PLATFORM_ID;
  exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;
  exports.APP_INITIALIZER = APP_INITIALIZER;
  exports.ApplicationInitStatus = ApplicationInitStatus;
  exports.DebugElement = DebugElement;
  exports.DebugNode = DebugNode;
  exports.asNativeElements = asNativeElements;
  exports.getDebugNode = getDebugNode;
  exports.Testability = Testability;
  exports.TestabilityRegistry = TestabilityRegistry;
  exports.setTestabilityGetter = setTestabilityGetter;
  exports.TRANSLATIONS = TRANSLATIONS;
  exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;
  exports.LOCALE_ID = LOCALE_ID;
  exports.MissingTranslationStrategy = MissingTranslationStrategy;
  exports.ApplicationModule = ApplicationModule;
  exports.wtfCreateScope = wtfCreateScope;
  exports.wtfLeave = wtfLeave;
  exports.wtfStartTimeRange = wtfStartTimeRange;
  exports.wtfEndTimeRange = wtfEndTimeRange;
  exports.Type = Type;
  exports.EventEmitter = EventEmitter;
  exports.ErrorHandler = ErrorHandler;
  exports.Sanitizer = Sanitizer;
  exports.SecurityContext = SecurityContext;
  exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;
  exports.Attribute = Attribute;
  exports.ContentChild = ContentChild;
  exports.ContentChildren = ContentChildren;
  exports.Query = Query;
  exports.ViewChild = ViewChild;
  exports.ViewChildren = ViewChildren;
  exports.Component = Component;
  exports.Directive = Directive;
  exports.HostBinding = HostBinding;
  exports.HostListener = HostListener;
  exports.Input = Input;
  exports.Output = Output;
  exports.Pipe = Pipe;
  exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;
  exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;
  exports.NgModule = NgModule;
  exports.ViewEncapsulation = ViewEncapsulation;
  exports.Version = Version;
  exports.VERSION = VERSION;
  exports.forwardRef = forwardRef;
  exports.resolveForwardRef = resolveForwardRef;
  exports.Injector = Injector;
  exports.ReflectiveInjector = ReflectiveInjector;
  exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
  exports.ReflectiveKey = ReflectiveKey;
  exports.InjectionToken = InjectionToken;
  exports.OpaqueToken = OpaqueToken;
  exports.Inject = Inject;
  exports.Optional = Optional;
  exports.Injectable = Injectable;
  exports.Self = Self;
  exports.SkipSelf = SkipSelf;
  exports.Host = Host;
  exports.NgZone = NgZone;
  exports.RenderComponentType = RenderComponentType;
  exports.Renderer = Renderer;
  exports.Renderer2 = Renderer2;
  exports.RendererFactory2 = RendererFactory2;
  exports.RendererStyleFlags2 = RendererStyleFlags2;
  exports.RootRenderer = RootRenderer;
  exports.COMPILER_OPTIONS = COMPILER_OPTIONS;
  exports.Compiler = Compiler;
  exports.CompilerFactory = CompilerFactory;
  exports.ModuleWithComponentFactories = ModuleWithComponentFactories;
  exports.ComponentFactory = ComponentFactory;
  exports.ComponentRef = ComponentRef;
  exports.ComponentFactoryResolver = ComponentFactoryResolver;
  exports.ElementRef = ElementRef;
  exports.NgModuleFactory = NgModuleFactory;
  exports.NgModuleRef = NgModuleRef;
  exports.NgModuleFactoryLoader = NgModuleFactoryLoader;
  exports.getModuleFactory = getModuleFactory;
  exports.QueryList = QueryList;
  exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;
  exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;
  exports.TemplateRef = TemplateRef;
  exports.ViewContainerRef = ViewContainerRef;
  exports.EmbeddedViewRef = EmbeddedViewRef;
  exports.ViewRef = ViewRef;
  exports.ChangeDetectionStrategy = ChangeDetectionStrategy;
  exports.ChangeDetectorRef = ChangeDetectorRef;
  exports.DefaultIterableDiffer = DefaultIterableDiffer;
  exports.IterableDiffers = IterableDiffers;
  exports.KeyValueDiffers = KeyValueDiffers;
  exports.SimpleChange = SimpleChange;
  exports.WrappedValue = WrappedValue;
  exports.platformCore = platformCore;
  exports.ɵALLOW_MULTIPLE_PLATFORMS = ALLOW_MULTIPLE_PLATFORMS;
  exports.ɵAPP_ID_RANDOM_PROVIDER = APP_ID_RANDOM_PROVIDER;
  exports.ɵValueUnwrapper = ValueUnwrapper;
  exports.ɵdevModeEqual = devModeEqual;
  exports.ɵisListLikeIterable = isListLikeIterable;
  exports.ɵChangeDetectorStatus = ChangeDetectorStatus;
  exports.ɵisDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;
  exports.ɵConsole = Console;
  exports.ɵERROR_COMPONENT_TYPE = ERROR_COMPONENT_TYPE;
  exports.ɵComponentFactory = ComponentFactory;
  exports.ɵCodegenComponentFactoryResolver = CodegenComponentFactoryResolver;
  exports.ɵViewMetadata = ViewMetadata;
  exports.ɵReflectionCapabilities = ReflectionCapabilities;
  exports.ɵRenderDebugInfo = RenderDebugInfo;
  exports.ɵglobal = _global;
  exports.ɵlooseIdentical = looseIdentical;
  exports.ɵstringify = stringify;
  exports.ɵmakeDecorator = makeDecorator;
  exports.ɵisObservable = isObservable;
  exports.ɵisPromise = isPromise;
  exports.ɵclearProviderOverrides = clearProviderOverrides;
  exports.ɵoverrideProvider = overrideProvider;
  exports.ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR;
  exports.ɵregisterModuleFactory = registerModuleFactory;
  exports.ɵEMPTY_ARRAY = EMPTY_ARRAY;
  exports.ɵEMPTY_MAP = EMPTY_MAP;
  exports.ɵand = anchorDef;
  exports.ɵccf = createComponentFactory;
  exports.ɵcmf = createNgModuleFactory;
  exports.ɵcrt = createRendererType2;
  exports.ɵdid = directiveDef;
  exports.ɵeld = elementDef;
  exports.ɵelementEventFullName = elementEventFullName;
  exports.ɵgetComponentViewDefinitionFactory = getComponentViewDefinitionFactory;
  exports.ɵinlineInterpolate = inlineInterpolate;
  exports.ɵinterpolate = interpolate;
  exports.ɵmod = moduleDef;
  exports.ɵmpd = moduleProvideDef;
  exports.ɵncd = ngContentDef;
  exports.ɵnov = nodeValue;
  exports.ɵpid = pipeDef;
  exports.ɵprd = providerDef;
  exports.ɵpad = pureArrayDef;
  exports.ɵpod = pureObjectDef;
  exports.ɵppd = purePipeDef;
  exports.ɵqud = queryDef;
  exports.ɵted = textDef;
  exports.ɵunv = unwrapValue;
  exports.ɵvid = viewDef;
  exports.AUTO_STYLE = AUTO_STYLE$$1;
  exports.trigger = trigger$$1;
  exports.animate = animate$$1;
  exports.group = group$$1;
  exports.sequence = sequence$$1;
  exports.style = style$$1;
  exports.state = state$$1;
  exports.keyframes = keyframes$$1;
  exports.transition = transition$$1;
  exports.ɵx = animate$1;
  exports.ɵy = group$1;
  exports.ɵbc = keyframes$1;
  exports.ɵz = sequence$1;
  exports.ɵbb = state$1;
  exports.ɵba = style$1;
  exports.ɵbd = transition$1;
  exports.ɵw = trigger$1;
  exports.ɵk = _iterableDiffersFactory;
  exports.ɵl = _keyValueDiffersFactory;
  exports.ɵm = _localeFactory;
  exports.ɵe = ApplicationRef_;
  exports.ɵf = _appIdRandomProviderFactory;
  exports.ɵg = defaultIterableDiffers;
  exports.ɵh = defaultKeyValueDiffers;
  exports.ɵi = DefaultIterableDifferFactory;
  exports.ɵj = DefaultKeyValueDifferFactory;
  exports.ɵb = ReflectiveInjector_;
  exports.ɵc = ReflectiveDependency;
  exports.ɵd = resolveReflectiveProviders;
  exports.ɵn = wtfEnabled;
  exports.ɵp = createScope$1;
  exports.ɵo = detectWTF;
  exports.ɵs = endTimeRange;
  exports.ɵq = leave;
  exports.ɵr = startTimeRange;
  exports.ɵa = makeParamDecorator;
  exports.ɵt = _def;
  exports.ɵu = DebugContext;
  Object.defineProperty(exports, '__esModule', {value: true});
})));

})();
(function() {
var define = System.amdDefine;
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core')) : typeof define === 'function' && define.amd ? define("node_modules/@angular/platform-browser/bundles/platform-browser.umd.js", ["exports", "node_modules/@angular/common/bundles/common.umd.js", "node_modules/@angular/core/bundles/core.umd.js"], factory) : (factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}), global.ng.common, global.ng.core));
}(this, (function(exports, _angular_common, _angular_core) {
  'use strict';
  var extendStatics = Object.setPrototypeOf || ({__proto__: []} instanceof Array && function(d, b) {
    d.__proto__ = b;
  }) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
  };
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var _DOM = ((null));
  function getDOM() {
    return _DOM;
  }
  function setRootDomAdapter(adapter) {
    if (!_DOM) {
      _DOM = adapter;
    }
  }
  var DomAdapter = (function() {
    function DomAdapter() {
      this.resourceLoaderType = ((null));
    }
    DomAdapter.prototype.hasProperty = function(element, name) {};
    DomAdapter.prototype.setProperty = function(el, name, value) {};
    DomAdapter.prototype.getProperty = function(el, name) {};
    DomAdapter.prototype.invoke = function(el, methodName, args) {};
    DomAdapter.prototype.logError = function(error) {};
    DomAdapter.prototype.log = function(error) {};
    DomAdapter.prototype.logGroup = function(error) {};
    DomAdapter.prototype.logGroupEnd = function() {};
    Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
      get: function() {
        return this._attrToPropMap;
      },
      set: function(value) {
        this._attrToPropMap = value;
      },
      enumerable: true,
      configurable: true
    });
    DomAdapter.prototype.contains = function(nodeA, nodeB) {};
    DomAdapter.prototype.parse = function(templateHtml) {};
    DomAdapter.prototype.querySelector = function(el, selector) {};
    DomAdapter.prototype.querySelectorAll = function(el, selector) {};
    DomAdapter.prototype.on = function(el, evt, listener) {};
    DomAdapter.prototype.onAndCancel = function(el, evt, listener) {};
    DomAdapter.prototype.dispatchEvent = function(el, evt) {};
    DomAdapter.prototype.createMouseEvent = function(eventType) {};
    DomAdapter.prototype.createEvent = function(eventType) {};
    DomAdapter.prototype.preventDefault = function(evt) {};
    DomAdapter.prototype.isPrevented = function(evt) {};
    DomAdapter.prototype.getInnerHTML = function(el) {};
    DomAdapter.prototype.getTemplateContent = function(el) {};
    DomAdapter.prototype.getOuterHTML = function(el) {};
    DomAdapter.prototype.nodeName = function(node) {};
    DomAdapter.prototype.nodeValue = function(node) {};
    DomAdapter.prototype.type = function(node) {};
    DomAdapter.prototype.content = function(node) {};
    DomAdapter.prototype.firstChild = function(el) {};
    DomAdapter.prototype.nextSibling = function(el) {};
    DomAdapter.prototype.parentElement = function(el) {};
    DomAdapter.prototype.childNodes = function(el) {};
    DomAdapter.prototype.childNodesAsList = function(el) {};
    DomAdapter.prototype.clearNodes = function(el) {};
    DomAdapter.prototype.appendChild = function(el, node) {};
    DomAdapter.prototype.removeChild = function(el, node) {};
    DomAdapter.prototype.replaceChild = function(el, newNode, oldNode) {};
    DomAdapter.prototype.remove = function(el) {};
    DomAdapter.prototype.insertBefore = function(parent, ref, node) {};
    DomAdapter.prototype.insertAllBefore = function(parent, ref, nodes) {};
    DomAdapter.prototype.insertAfter = function(parent, el, node) {};
    DomAdapter.prototype.setInnerHTML = function(el, value) {};
    DomAdapter.prototype.getText = function(el) {};
    DomAdapter.prototype.setText = function(el, value) {};
    DomAdapter.prototype.getValue = function(el) {};
    DomAdapter.prototype.setValue = function(el, value) {};
    DomAdapter.prototype.getChecked = function(el) {};
    DomAdapter.prototype.setChecked = function(el, value) {};
    DomAdapter.prototype.createComment = function(text) {};
    DomAdapter.prototype.createTemplate = function(html) {};
    DomAdapter.prototype.createElement = function(tagName, doc) {};
    DomAdapter.prototype.createElementNS = function(ns, tagName, doc) {};
    DomAdapter.prototype.createTextNode = function(text, doc) {};
    DomAdapter.prototype.createScriptTag = function(attrName, attrValue, doc) {};
    DomAdapter.prototype.createStyleElement = function(css, doc) {};
    DomAdapter.prototype.createShadowRoot = function(el) {};
    DomAdapter.prototype.getShadowRoot = function(el) {};
    DomAdapter.prototype.getHost = function(el) {};
    DomAdapter.prototype.getDistributedNodes = function(el) {};
    DomAdapter.prototype.clone = function(node) {};
    DomAdapter.prototype.getElementsByClassName = function(element, name) {};
    DomAdapter.prototype.getElementsByTagName = function(element, name) {};
    DomAdapter.prototype.classList = function(element) {};
    DomAdapter.prototype.addClass = function(element, className) {};
    DomAdapter.prototype.removeClass = function(element, className) {};
    DomAdapter.prototype.hasClass = function(element, className) {};
    DomAdapter.prototype.setStyle = function(element, styleName, styleValue) {};
    DomAdapter.prototype.removeStyle = function(element, styleName) {};
    DomAdapter.prototype.getStyle = function(element, styleName) {};
    DomAdapter.prototype.hasStyle = function(element, styleName, styleValue) {};
    DomAdapter.prototype.tagName = function(element) {};
    DomAdapter.prototype.attributeMap = function(element) {};
    DomAdapter.prototype.hasAttribute = function(element, attribute) {};
    DomAdapter.prototype.hasAttributeNS = function(element, ns, attribute) {};
    DomAdapter.prototype.getAttribute = function(element, attribute) {};
    DomAdapter.prototype.getAttributeNS = function(element, ns, attribute) {};
    DomAdapter.prototype.setAttribute = function(element, name, value) {};
    DomAdapter.prototype.setAttributeNS = function(element, ns, name, value) {};
    DomAdapter.prototype.removeAttribute = function(element, attribute) {};
    DomAdapter.prototype.removeAttributeNS = function(element, ns, attribute) {};
    DomAdapter.prototype.templateAwareRoot = function(el) {};
    DomAdapter.prototype.createHtmlDocument = function() {};
    DomAdapter.prototype.getBoundingClientRect = function(el) {};
    DomAdapter.prototype.getTitle = function(doc) {};
    DomAdapter.prototype.setTitle = function(doc, newTitle) {};
    DomAdapter.prototype.elementMatches = function(n, selector) {};
    DomAdapter.prototype.isTemplateElement = function(el) {};
    DomAdapter.prototype.isTextNode = function(node) {};
    DomAdapter.prototype.isCommentNode = function(node) {};
    DomAdapter.prototype.isElementNode = function(node) {};
    DomAdapter.prototype.hasShadowRoot = function(node) {};
    DomAdapter.prototype.isShadowRoot = function(node) {};
    DomAdapter.prototype.importIntoDoc = function(node) {};
    DomAdapter.prototype.adoptNode = function(node) {};
    DomAdapter.prototype.getHref = function(element) {};
    DomAdapter.prototype.getEventKey = function(event) {};
    DomAdapter.prototype.resolveAndSetHref = function(element, baseUrl, href) {};
    DomAdapter.prototype.supportsDOMEvents = function() {};
    DomAdapter.prototype.supportsNativeShadowDOM = function() {};
    DomAdapter.prototype.getGlobalEventTarget = function(doc, target) {};
    DomAdapter.prototype.getHistory = function() {};
    DomAdapter.prototype.getLocation = function() {};
    DomAdapter.prototype.getBaseHref = function(doc) {};
    DomAdapter.prototype.resetBaseElement = function() {};
    DomAdapter.prototype.getUserAgent = function() {};
    DomAdapter.prototype.setData = function(element, name, value) {};
    DomAdapter.prototype.getComputedStyle = function(element) {};
    DomAdapter.prototype.getData = function(element, name) {};
    DomAdapter.prototype.supportsWebAnimation = function() {};
    DomAdapter.prototype.performanceNow = function() {};
    DomAdapter.prototype.getAnimationPrefix = function() {};
    DomAdapter.prototype.getTransitionEnd = function() {};
    DomAdapter.prototype.supportsAnimation = function() {};
    DomAdapter.prototype.supportsCookies = function() {};
    DomAdapter.prototype.getCookie = function(name) {};
    DomAdapter.prototype.setCookie = function(name, value) {};
    return DomAdapter;
  }());
  var GenericBrowserDomAdapter = (function(_super) {
    __extends(GenericBrowserDomAdapter, _super);
    function GenericBrowserDomAdapter() {
      var _this = _super.call(this) || this;
      _this._animationPrefix = null;
      _this._transitionEnd = null;
      try {
        var element_1 = _this.createElement('div', document);
        if (_this.getStyle(element_1, 'animationName') != null) {
          _this._animationPrefix = '';
        } else {
          var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
          for (var i = 0; i < domPrefixes.length; i++) {
            if (_this.getStyle(element_1, domPrefixes[i] + 'AnimationName') != null) {
              _this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
              break;
            }
          }
        }
        var transEndEventNames_1 = {
          WebkitTransition: 'webkitTransitionEnd',
          MozTransition: 'transitionend',
          OTransition: 'oTransitionEnd otransitionend',
          transition: 'transitionend'
        };
        Object.keys(transEndEventNames_1).forEach(function(key) {
          if (_this.getStyle(element_1, key) != null) {
            _this._transitionEnd = transEndEventNames_1[key];
          }
        });
      } catch (e) {
        _this._animationPrefix = null;
        _this._transitionEnd = null;
      }
      return _this;
    }
    GenericBrowserDomAdapter.prototype.getDistributedNodes = function(el) {
      return ((el)).getDistributedNodes();
    };
    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function(el, baseUrl, href) {
      el.href = href == null ? baseUrl : baseUrl + '/../' + href;
    };
    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function() {
      return true;
    };
    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function() {
      return typeof((document.body)).createShadowRoot === 'function';
    };
    GenericBrowserDomAdapter.prototype.getAnimationPrefix = function() {
      return this._animationPrefix ? this._animationPrefix : '';
    };
    GenericBrowserDomAdapter.prototype.getTransitionEnd = function() {
      return this._transitionEnd ? this._transitionEnd : '';
    };
    GenericBrowserDomAdapter.prototype.supportsAnimation = function() {
      return this._animationPrefix != null && this._transitionEnd != null;
    };
    return GenericBrowserDomAdapter;
  }(DomAdapter));
  var _attrToPropMap = {
    'class': 'className',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex'
  };
  var DOM_KEY_LOCATION_NUMPAD = 3;
  var _keyMap = {
    '\b': 'Backspace',
    '\t': 'Tab',
    '\x7F': 'Delete',
    '\x1B': 'Escape',
    'Del': 'Delete',
    'Esc': 'Escape',
    'Left': 'ArrowLeft',
    'Right': 'ArrowRight',
    'Up': 'ArrowUp',
    'Down': 'ArrowDown',
    'Menu': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'Win': 'OS'
  };
  var _chromeNumKeyPadMap = {
    'A': '1',
    'B': '2',
    'C': '3',
    'D': '4',
    'E': '5',
    'F': '6',
    'G': '7',
    'H': '8',
    'I': '9',
    'J': '*',
    'K': '+',
    'M': '-',
    'N': '.',
    'O': '/',
    '\x60': '0',
    '\x90': 'NumLock'
  };
  var nodeContains;
  if (_angular_core.ɵglobal['Node']) {
    nodeContains = _angular_core.ɵglobal['Node'].prototype.contains || function(node) {
      return !!(this.compareDocumentPosition(node) & 16);
    };
  }
  var BrowserDomAdapter = (function(_super) {
    __extends(BrowserDomAdapter, _super);
    function BrowserDomAdapter() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BrowserDomAdapter.prototype.parse = function(templateHtml) {
      throw new Error('parse not implemented');
    };
    BrowserDomAdapter.makeCurrent = function() {
      setRootDomAdapter(new BrowserDomAdapter());
    };
    BrowserDomAdapter.prototype.hasProperty = function(element, name) {
      return name in element;
    };
    BrowserDomAdapter.prototype.setProperty = function(el, name, value) {
      ((el))[name] = value;
    };
    BrowserDomAdapter.prototype.getProperty = function(el, name) {
      return ((el))[name];
    };
    BrowserDomAdapter.prototype.invoke = function(el, methodName, args) {
      ((el))[methodName].apply(((el)), args);
    };
    BrowserDomAdapter.prototype.logError = function(error) {
      if (window.console) {
        if (console.error) {
          console.error(error);
        } else {
          console.log(error);
        }
      }
    };
    BrowserDomAdapter.prototype.log = function(error) {
      if (window.console) {
        window.console.log && window.console.log(error);
      }
    };
    BrowserDomAdapter.prototype.logGroup = function(error) {
      if (window.console) {
        window.console.group && window.console.group(error);
      }
    };
    BrowserDomAdapter.prototype.logGroupEnd = function() {
      if (window.console) {
        window.console.groupEnd && window.console.groupEnd();
      }
    };
    Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
      get: function() {
        return _attrToPropMap;
      },
      enumerable: true,
      configurable: true
    });
    BrowserDomAdapter.prototype.contains = function(nodeA, nodeB) {
      return nodeContains.call(nodeA, nodeB);
    };
    BrowserDomAdapter.prototype.querySelector = function(el, selector) {
      return el.querySelector(selector);
    };
    BrowserDomAdapter.prototype.querySelectorAll = function(el, selector) {
      return el.querySelectorAll(selector);
    };
    BrowserDomAdapter.prototype.on = function(el, evt, listener) {
      el.addEventListener(evt, listener, false);
    };
    BrowserDomAdapter.prototype.onAndCancel = function(el, evt, listener) {
      el.addEventListener(evt, listener, false);
      return function() {
        el.removeEventListener(evt, listener, false);
      };
    };
    BrowserDomAdapter.prototype.dispatchEvent = function(el, evt) {
      el.dispatchEvent(evt);
    };
    BrowserDomAdapter.prototype.createMouseEvent = function(eventType) {
      var evt = document.createEvent('MouseEvent');
      evt.initEvent(eventType, true, true);
      return evt;
    };
    BrowserDomAdapter.prototype.createEvent = function(eventType) {
      var evt = document.createEvent('Event');
      evt.initEvent(eventType, true, true);
      return evt;
    };
    BrowserDomAdapter.prototype.preventDefault = function(evt) {
      evt.preventDefault();
      evt.returnValue = false;
    };
    BrowserDomAdapter.prototype.isPrevented = function(evt) {
      return evt.defaultPrevented || evt.returnValue != null && !evt.returnValue;
    };
    BrowserDomAdapter.prototype.getInnerHTML = function(el) {
      return el.innerHTML;
    };
    BrowserDomAdapter.prototype.getTemplateContent = function(el) {
      return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;
    };
    BrowserDomAdapter.prototype.getOuterHTML = function(el) {
      return el.outerHTML;
    };
    BrowserDomAdapter.prototype.nodeName = function(node) {
      return node.nodeName;
    };
    BrowserDomAdapter.prototype.nodeValue = function(node) {
      return node.nodeValue;
    };
    BrowserDomAdapter.prototype.type = function(node) {
      return node.type;
    };
    BrowserDomAdapter.prototype.content = function(node) {
      if (this.hasProperty(node, 'content')) {
        return ((node)).content;
      } else {
        return node;
      }
    };
    BrowserDomAdapter.prototype.firstChild = function(el) {
      return el.firstChild;
    };
    BrowserDomAdapter.prototype.nextSibling = function(el) {
      return el.nextSibling;
    };
    BrowserDomAdapter.prototype.parentElement = function(el) {
      return el.parentNode;
    };
    BrowserDomAdapter.prototype.childNodes = function(el) {
      return el.childNodes;
    };
    BrowserDomAdapter.prototype.childNodesAsList = function(el) {
      var childNodes = el.childNodes;
      var res = new Array(childNodes.length);
      for (var i = 0; i < childNodes.length; i++) {
        res[i] = childNodes[i];
      }
      return res;
    };
    BrowserDomAdapter.prototype.clearNodes = function(el) {
      while (el.firstChild) {
        el.removeChild(el.firstChild);
      }
    };
    BrowserDomAdapter.prototype.appendChild = function(el, node) {
      el.appendChild(node);
    };
    BrowserDomAdapter.prototype.removeChild = function(el, node) {
      el.removeChild(node);
    };
    BrowserDomAdapter.prototype.replaceChild = function(el, newChild, oldChild) {
      el.replaceChild(newChild, oldChild);
    };
    BrowserDomAdapter.prototype.remove = function(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
      return node;
    };
    BrowserDomAdapter.prototype.insertBefore = function(parent, ref, node) {
      parent.insertBefore(node, ref);
    };
    BrowserDomAdapter.prototype.insertAllBefore = function(parent, ref, nodes) {
      nodes.forEach(function(n) {
        return parent.insertBefore(n, ref);
      });
    };
    BrowserDomAdapter.prototype.insertAfter = function(parent, ref, node) {
      parent.insertBefore(node, ref.nextSibling);
    };
    BrowserDomAdapter.prototype.setInnerHTML = function(el, value) {
      el.innerHTML = value;
    };
    BrowserDomAdapter.prototype.getText = function(el) {
      return el.textContent;
    };
    BrowserDomAdapter.prototype.setText = function(el, value) {
      el.textContent = value;
    };
    BrowserDomAdapter.prototype.getValue = function(el) {
      return el.value;
    };
    BrowserDomAdapter.prototype.setValue = function(el, value) {
      el.value = value;
    };
    BrowserDomAdapter.prototype.getChecked = function(el) {
      return el.checked;
    };
    BrowserDomAdapter.prototype.setChecked = function(el, value) {
      el.checked = value;
    };
    BrowserDomAdapter.prototype.createComment = function(text) {
      return document.createComment(text);
    };
    BrowserDomAdapter.prototype.createTemplate = function(html) {
      var t = document.createElement('template');
      t.innerHTML = html;
      return t;
    };
    BrowserDomAdapter.prototype.createElement = function(tagName, doc) {
      if (doc === void 0) {
        doc = document;
      }
      return doc.createElement(tagName);
    };
    BrowserDomAdapter.prototype.createElementNS = function(ns, tagName, doc) {
      if (doc === void 0) {
        doc = document;
      }
      return doc.createElementNS(ns, tagName);
    };
    BrowserDomAdapter.prototype.createTextNode = function(text, doc) {
      if (doc === void 0) {
        doc = document;
      }
      return doc.createTextNode(text);
    };
    BrowserDomAdapter.prototype.createScriptTag = function(attrName, attrValue, doc) {
      if (doc === void 0) {
        doc = document;
      }
      var el = (doc.createElement('SCRIPT'));
      el.setAttribute(attrName, attrValue);
      return el;
    };
    BrowserDomAdapter.prototype.createStyleElement = function(css, doc) {
      if (doc === void 0) {
        doc = document;
      }
      var style = (doc.createElement('style'));
      this.appendChild(style, this.createTextNode(css));
      return style;
    };
    BrowserDomAdapter.prototype.createShadowRoot = function(el) {
      return ((el)).createShadowRoot();
    };
    BrowserDomAdapter.prototype.getShadowRoot = function(el) {
      return ((el)).shadowRoot;
    };
    BrowserDomAdapter.prototype.getHost = function(el) {
      return ((el)).host;
    };
    BrowserDomAdapter.prototype.clone = function(node) {
      return node.cloneNode(true);
    };
    BrowserDomAdapter.prototype.getElementsByClassName = function(element, name) {
      return element.getElementsByClassName(name);
    };
    BrowserDomAdapter.prototype.getElementsByTagName = function(element, name) {
      return element.getElementsByTagName(name);
    };
    BrowserDomAdapter.prototype.classList = function(element) {
      return Array.prototype.slice.call(element.classList, 0);
    };
    BrowserDomAdapter.prototype.addClass = function(element, className) {
      element.classList.add(className);
    };
    BrowserDomAdapter.prototype.removeClass = function(element, className) {
      element.classList.remove(className);
    };
    BrowserDomAdapter.prototype.hasClass = function(element, className) {
      return element.classList.contains(className);
    };
    BrowserDomAdapter.prototype.setStyle = function(element, styleName, styleValue) {
      element.style[styleName] = styleValue;
    };
    BrowserDomAdapter.prototype.removeStyle = function(element, stylename) {
      element.style[stylename] = '';
    };
    BrowserDomAdapter.prototype.getStyle = function(element, stylename) {
      return element.style[stylename];
    };
    BrowserDomAdapter.prototype.hasStyle = function(element, styleName, styleValue) {
      var value = this.getStyle(element, styleName) || '';
      return styleValue ? value == styleValue : value.length > 0;
    };
    BrowserDomAdapter.prototype.tagName = function(element) {
      return element.tagName;
    };
    BrowserDomAdapter.prototype.attributeMap = function(element) {
      var res = new Map();
      var elAttrs = element.attributes;
      for (var i = 0; i < elAttrs.length; i++) {
        var attrib = elAttrs[i];
        res.set(attrib.name, attrib.value);
      }
      return res;
    };
    BrowserDomAdapter.prototype.hasAttribute = function(element, attribute) {
      return element.hasAttribute(attribute);
    };
    BrowserDomAdapter.prototype.hasAttributeNS = function(element, ns, attribute) {
      return element.hasAttributeNS(ns, attribute);
    };
    BrowserDomAdapter.prototype.getAttribute = function(element, attribute) {
      return element.getAttribute(attribute);
    };
    BrowserDomAdapter.prototype.getAttributeNS = function(element, ns, name) {
      return element.getAttributeNS(ns, name);
    };
    BrowserDomAdapter.prototype.setAttribute = function(element, name, value) {
      element.setAttribute(name, value);
    };
    BrowserDomAdapter.prototype.setAttributeNS = function(element, ns, name, value) {
      element.setAttributeNS(ns, name, value);
    };
    BrowserDomAdapter.prototype.removeAttribute = function(element, attribute) {
      element.removeAttribute(attribute);
    };
    BrowserDomAdapter.prototype.removeAttributeNS = function(element, ns, name) {
      element.removeAttributeNS(ns, name);
    };
    BrowserDomAdapter.prototype.templateAwareRoot = function(el) {
      return this.isTemplateElement(el) ? this.content(el) : el;
    };
    BrowserDomAdapter.prototype.createHtmlDocument = function() {
      return document.implementation.createHTMLDocument('fakeTitle');
    };
    BrowserDomAdapter.prototype.getBoundingClientRect = function(el) {
      try {
        return el.getBoundingClientRect();
      } catch (e) {
        return {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
    };
    BrowserDomAdapter.prototype.getTitle = function(doc) {
      return document.title;
    };
    BrowserDomAdapter.prototype.setTitle = function(doc, newTitle) {
      document.title = newTitle || '';
    };
    BrowserDomAdapter.prototype.elementMatches = function(n, selector) {
      if (n instanceof HTMLElement) {
        return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
      }
      return false;
    };
    BrowserDomAdapter.prototype.isTemplateElement = function(el) {
      return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
    };
    BrowserDomAdapter.prototype.isTextNode = function(node) {
      return node.nodeType === Node.TEXT_NODE;
    };
    BrowserDomAdapter.prototype.isCommentNode = function(node) {
      return node.nodeType === Node.COMMENT_NODE;
    };
    BrowserDomAdapter.prototype.isElementNode = function(node) {
      return node.nodeType === Node.ELEMENT_NODE;
    };
    BrowserDomAdapter.prototype.hasShadowRoot = function(node) {
      return node.shadowRoot != null && node instanceof HTMLElement;
    };
    BrowserDomAdapter.prototype.isShadowRoot = function(node) {
      return node instanceof DocumentFragment;
    };
    BrowserDomAdapter.prototype.importIntoDoc = function(node) {
      return document.importNode(this.templateAwareRoot(node), true);
    };
    BrowserDomAdapter.prototype.adoptNode = function(node) {
      return document.adoptNode(node);
    };
    BrowserDomAdapter.prototype.getHref = function(el) {
      return ((el)).href;
    };
    BrowserDomAdapter.prototype.getEventKey = function(event) {
      var key = event.key;
      if (key == null) {
        key = event.keyIdentifier;
        if (key == null) {
          return 'Unidentified';
        }
        if (key.startsWith('U+')) {
          key = String.fromCharCode(parseInt(key.substring(2), 16));
          if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
            key = ((_chromeNumKeyPadMap))[key];
          }
        }
      }
      return _keyMap[key] || key;
    };
    BrowserDomAdapter.prototype.getGlobalEventTarget = function(doc, target) {
      if (target === 'window') {
        return window;
      }
      if (target === 'document') {
        return document;
      }
      if (target === 'body') {
        return document.body;
      }
      return null;
    };
    BrowserDomAdapter.prototype.getHistory = function() {
      return window.history;
    };
    BrowserDomAdapter.prototype.getLocation = function() {
      return window.location;
    };
    BrowserDomAdapter.prototype.getBaseHref = function(doc) {
      var href = getBaseElementHref();
      return href == null ? null : relativePath(href);
    };
    BrowserDomAdapter.prototype.resetBaseElement = function() {
      baseElement = null;
    };
    BrowserDomAdapter.prototype.getUserAgent = function() {
      return window.navigator.userAgent;
    };
    BrowserDomAdapter.prototype.setData = function(element, name, value) {
      this.setAttribute(element, 'data-' + name, value);
    };
    BrowserDomAdapter.prototype.getData = function(element, name) {
      return this.getAttribute(element, 'data-' + name);
    };
    BrowserDomAdapter.prototype.getComputedStyle = function(element) {
      return getComputedStyle(element);
    };
    BrowserDomAdapter.prototype.supportsWebAnimation = function() {
      return typeof((Element)).prototype['animate'] === 'function';
    };
    BrowserDomAdapter.prototype.performanceNow = function() {
      return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
    };
    BrowserDomAdapter.prototype.supportsCookies = function() {
      return true;
    };
    BrowserDomAdapter.prototype.getCookie = function(name) {
      return _angular_common.ɵparseCookieValue(document.cookie, name);
    };
    BrowserDomAdapter.prototype.setCookie = function(name, value) {
      document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
    };
    return BrowserDomAdapter;
  }(GenericBrowserDomAdapter));
  var baseElement = null;
  function getBaseElementHref() {
    if (!baseElement) {
      baseElement = ((document.querySelector('base')));
      if (!baseElement) {
        return null;
      }
    }
    return baseElement.getAttribute('href');
  }
  var urlParsingNode;
  function relativePath(url) {
    if (!urlParsingNode) {
      urlParsingNode = document.createElement('a');
    }
    urlParsingNode.setAttribute('href', url);
    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname;
  }
  var DOCUMENT$1 = _angular_common.DOCUMENT;
  function supportsState() {
    return !!window.history.pushState;
  }
  var BrowserPlatformLocation = (function(_super) {
    __extends(BrowserPlatformLocation, _super);
    function BrowserPlatformLocation(_doc) {
      var _this = _super.call(this) || this;
      _this._doc = _doc;
      _this._init();
      return _this;
    }
    BrowserPlatformLocation.prototype._init = function() {
      this._location = getDOM().getLocation();
      this._history = getDOM().getHistory();
    };
    Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
      get: function() {
        return this._location;
      },
      enumerable: true,
      configurable: true
    });
    BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function() {
      return ((getDOM().getBaseHref(this._doc)));
    };
    BrowserPlatformLocation.prototype.onPopState = function(fn) {
      getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('popstate', fn, false);
    };
    BrowserPlatformLocation.prototype.onHashChange = function(fn) {
      getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('hashchange', fn, false);
    };
    Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
      get: function() {
        return this._location.pathname;
      },
      set: function(newPath) {
        this._location.pathname = newPath;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
      get: function() {
        return this._location.search;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
      get: function() {
        return this._location.hash;
      },
      enumerable: true,
      configurable: true
    });
    BrowserPlatformLocation.prototype.pushState = function(state, title, url) {
      if (supportsState()) {
        this._history.pushState(state, title, url);
      } else {
        this._location.hash = url;
      }
    };
    BrowserPlatformLocation.prototype.replaceState = function(state, title, url) {
      if (supportsState()) {
        this._history.replaceState(state, title, url);
      } else {
        this._location.hash = url;
      }
    };
    BrowserPlatformLocation.prototype.forward = function() {
      this._history.forward();
    };
    BrowserPlatformLocation.prototype.back = function() {
      this._history.back();
    };
    return BrowserPlatformLocation;
  }(_angular_common.PlatformLocation));
  BrowserPlatformLocation.decorators = [{type: _angular_core.Injectable}];
  BrowserPlatformLocation.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [DOCUMENT$1]
      }]
    }];
  };
  var Meta = (function() {
    function Meta(_doc) {
      this._doc = _doc;
      this._dom = getDOM();
    }
    Meta.prototype.addTag = function(tag, forceCreation) {
      if (forceCreation === void 0) {
        forceCreation = false;
      }
      if (!tag)
        return null;
      return this._getOrCreateElement(tag, forceCreation);
    };
    Meta.prototype.addTags = function(tags, forceCreation) {
      var _this = this;
      if (forceCreation === void 0) {
        forceCreation = false;
      }
      if (!tags)
        return [];
      return tags.reduce(function(result, tag) {
        if (tag) {
          result.push(_this._getOrCreateElement(tag, forceCreation));
        }
        return result;
      }, []);
    };
    Meta.prototype.getTag = function(attrSelector) {
      if (!attrSelector)
        return null;
      return this._dom.querySelector(this._doc, "meta[" + attrSelector + "]");
    };
    Meta.prototype.getTags = function(attrSelector) {
      if (!attrSelector)
        return [];
      var list = this._dom.querySelectorAll(this._doc, "meta[" + attrSelector + "]");
      return list ? [].slice.call(list) : [];
    };
    Meta.prototype.updateTag = function(tag, selector) {
      if (!tag)
        return null;
      selector = selector || this._parseSelector(tag);
      var meta = ((this.getTag(selector)));
      if (meta) {
        return this._setMetaElementAttributes(tag, meta);
      }
      return this._getOrCreateElement(tag, true);
    };
    Meta.prototype.removeTag = function(attrSelector) {
      this.removeTagElement(((this.getTag(attrSelector))));
    };
    Meta.prototype.removeTagElement = function(meta) {
      if (meta) {
        this._dom.remove(meta);
      }
    };
    Meta.prototype._getOrCreateElement = function(meta, forceCreation) {
      if (forceCreation === void 0) {
        forceCreation = false;
      }
      if (!forceCreation) {
        var selector = this._parseSelector(meta);
        var elem = ((this.getTag(selector)));
        if (elem && this._containsAttributes(meta, elem))
          return elem;
      }
      var element = (this._dom.createElement('meta'));
      this._setMetaElementAttributes(meta, element);
      var head = this._dom.getElementsByTagName(this._doc, 'head')[0];
      this._dom.appendChild(head, element);
      return element;
    };
    Meta.prototype._setMetaElementAttributes = function(tag, el) {
      var _this = this;
      Object.keys(tag).forEach(function(prop) {
        return _this._dom.setAttribute(el, prop, tag[prop]);
      });
      return el;
    };
    Meta.prototype._parseSelector = function(tag) {
      var attr = tag.name ? 'name' : 'property';
      return attr + "=\"" + tag[attr] + "\"";
    };
    Meta.prototype._containsAttributes = function(tag, elem) {
      var _this = this;
      return Object.keys(tag).every(function(key) {
        return _this._dom.getAttribute(elem, key) === tag[key];
      });
    };
    return Meta;
  }());
  Meta.decorators = [{type: _angular_core.Injectable}];
  Meta.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [DOCUMENT$1]
      }]
    }];
  };
  var TRANSITION_ID = new _angular_core.InjectionToken('TRANSITION_ID');
  function appInitializerFactory(transitionId, document, injector) {
    return function() {
      injector.get(_angular_core.ApplicationInitStatus).donePromise.then(function() {
        var dom = getDOM();
        var styles = Array.prototype.slice.apply(dom.querySelectorAll(document, "style[ng-transition]"));
        styles.filter(function(el) {
          return dom.getAttribute(el, 'ng-transition') === transitionId;
        }).forEach(function(el) {
          return dom.remove(el);
        });
      });
    };
  }
  var SERVER_TRANSITION_PROVIDERS = [{
    provide: _angular_core.APP_INITIALIZER,
    useFactory: appInitializerFactory,
    deps: [TRANSITION_ID, DOCUMENT$1, _angular_core.Injector],
    multi: true
  }];
  var BrowserGetTestability = (function() {
    function BrowserGetTestability() {}
    BrowserGetTestability.init = function() {
      _angular_core.setTestabilityGetter(new BrowserGetTestability());
    };
    BrowserGetTestability.prototype.addToWindow = function(registry) {
      _angular_core.ɵglobal['getAngularTestability'] = function(elem, findInAncestors) {
        if (findInAncestors === void 0) {
          findInAncestors = true;
        }
        var testability = registry.findTestabilityInTree(elem, findInAncestors);
        if (testability == null) {
          throw new Error('Could not find testability for element.');
        }
        return testability;
      };
      _angular_core.ɵglobal['getAllAngularTestabilities'] = function() {
        return registry.getAllTestabilities();
      };
      _angular_core.ɵglobal['getAllAngularRootElements'] = function() {
        return registry.getAllRootElements();
      };
      var whenAllStable = function(callback) {
        var testabilities = _angular_core.ɵglobal['getAllAngularTestabilities']();
        var count = testabilities.length;
        var didWork = false;
        var decrement = function(didWork_) {
          didWork = didWork || didWork_;
          count--;
          if (count == 0) {
            callback(didWork);
          }
        };
        testabilities.forEach(function(testability) {
          testability.whenStable(decrement);
        });
      };
      if (!_angular_core.ɵglobal['frameworkStabilizers']) {
        _angular_core.ɵglobal['frameworkStabilizers'] = [];
      }
      _angular_core.ɵglobal['frameworkStabilizers'].push(whenAllStable);
    };
    BrowserGetTestability.prototype.findTestabilityInTree = function(registry, elem, findInAncestors) {
      if (elem == null) {
        return null;
      }
      var t = registry.getTestability(elem);
      if (t != null) {
        return t;
      } else if (!findInAncestors) {
        return null;
      }
      if (getDOM().isShadowRoot(elem)) {
        return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);
      }
      return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);
    };
    return BrowserGetTestability;
  }());
  var Title = (function() {
    function Title(_doc) {
      this._doc = _doc;
    }
    Title.prototype.getTitle = function() {
      return getDOM().getTitle(this._doc);
    };
    Title.prototype.setTitle = function(newTitle) {
      getDOM().setTitle(this._doc, newTitle);
    };
    return Title;
  }());
  Title.decorators = [{type: _angular_core.Injectable}];
  Title.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [DOCUMENT$1]
      }]
    }];
  };
  function exportNgVar(name, value) {
    if (!ng) {
      _angular_core.ɵglobal['ng'] = ng = ((_angular_core.ɵglobal['ng'])) || {};
    }
    ng[name] = value;
  }
  var ng;
  var CORE_TOKENS = {
    'ApplicationRef': _angular_core.ApplicationRef,
    'NgZone': _angular_core.NgZone
  };
  var INSPECT_GLOBAL_NAME = 'probe';
  var CORE_TOKENS_GLOBAL_NAME = 'coreTokens';
  function inspectNativeElement(element) {
    return _angular_core.getDebugNode(element);
  }
  var NgProbeToken$1 = (function() {
    function NgProbeToken$1(name, token) {
      this.name = name;
      this.token = token;
    }
    return NgProbeToken$1;
  }());
  function _createNgProbe(extraTokens, coreTokens) {
    var tokens = (extraTokens || []).concat(coreTokens || []);
    exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
    exportNgVar(CORE_TOKENS_GLOBAL_NAME, Object.assign({}, CORE_TOKENS, _ngProbeTokensToMap(tokens || [])));
    return function() {
      return inspectNativeElement;
    };
  }
  function _ngProbeTokensToMap(tokens) {
    return tokens.reduce(function(prev, t) {
      return (prev[t.name] = t.token, prev);
    }, {});
  }
  var ELEMENT_PROBE_PROVIDERS = [{
    provide: _angular_core.APP_INITIALIZER,
    useFactory: _createNgProbe,
    deps: [[NgProbeToken$1, new _angular_core.Optional()], [_angular_core.NgProbeToken, new _angular_core.Optional()]],
    multi: true
  }];
  var EVENT_MANAGER_PLUGINS = new _angular_core.InjectionToken('EventManagerPlugins');
  var EventManager = (function() {
    function EventManager(plugins, _zone) {
      var _this = this;
      this._zone = _zone;
      this._eventNameToPlugin = new Map();
      plugins.forEach(function(p) {
        return p.manager = _this;
      });
      this._plugins = plugins.slice().reverse();
    }
    EventManager.prototype.addEventListener = function(element, eventName, handler) {
      var plugin = this._findPluginFor(eventName);
      return plugin.addEventListener(element, eventName, handler);
    };
    EventManager.prototype.addGlobalEventListener = function(target, eventName, handler) {
      var plugin = this._findPluginFor(eventName);
      return plugin.addGlobalEventListener(target, eventName, handler);
    };
    EventManager.prototype.getZone = function() {
      return this._zone;
    };
    EventManager.prototype._findPluginFor = function(eventName) {
      var plugin = this._eventNameToPlugin.get(eventName);
      if (plugin) {
        return plugin;
      }
      var plugins = this._plugins;
      for (var i = 0; i < plugins.length; i++) {
        var plugin_1 = plugins[i];
        if (plugin_1.supports(eventName)) {
          this._eventNameToPlugin.set(eventName, plugin_1);
          return plugin_1;
        }
      }
      throw new Error("No event manager plugin found for event " + eventName);
    };
    return EventManager;
  }());
  EventManager.decorators = [{type: _angular_core.Injectable}];
  EventManager.ctorParameters = function() {
    return [{
      type: Array,
      decorators: [{
        type: _angular_core.Inject,
        args: [EVENT_MANAGER_PLUGINS]
      }]
    }, {type: _angular_core.NgZone}];
  };
  var EventManagerPlugin = (function() {
    function EventManagerPlugin(_doc) {
      this._doc = _doc;
    }
    EventManagerPlugin.prototype.supports = function(eventName) {};
    EventManagerPlugin.prototype.addEventListener = function(element, eventName, handler) {};
    EventManagerPlugin.prototype.addGlobalEventListener = function(element, eventName, handler) {
      var target = getDOM().getGlobalEventTarget(this._doc, element);
      if (!target) {
        throw new Error("Unsupported event target " + target + " for event " + eventName);
      }
      return this.addEventListener(target, eventName, handler);
    };
    return EventManagerPlugin;
  }());
  var SharedStylesHost = (function() {
    function SharedStylesHost() {
      this._stylesSet = new Set();
    }
    SharedStylesHost.prototype.addStyles = function(styles) {
      var _this = this;
      var additions = new Set();
      styles.forEach(function(style) {
        if (!_this._stylesSet.has(style)) {
          _this._stylesSet.add(style);
          additions.add(style);
        }
      });
      this.onStylesAdded(additions);
    };
    SharedStylesHost.prototype.onStylesAdded = function(additions) {};
    SharedStylesHost.prototype.getAllStyles = function() {
      return Array.from(this._stylesSet);
    };
    return SharedStylesHost;
  }());
  SharedStylesHost.decorators = [{type: _angular_core.Injectable}];
  SharedStylesHost.ctorParameters = function() {
    return [];
  };
  var DomSharedStylesHost = (function(_super) {
    __extends(DomSharedStylesHost, _super);
    function DomSharedStylesHost(_doc) {
      var _this = _super.call(this) || this;
      _this._doc = _doc;
      _this._hostNodes = new Set();
      _this._styleNodes = new Set();
      _this._hostNodes.add(_doc.head);
      return _this;
    }
    DomSharedStylesHost.prototype._addStylesToHost = function(styles, host) {
      var _this = this;
      styles.forEach(function(style) {
        var styleEl = _this._doc.createElement('style');
        styleEl.textContent = style;
        _this._styleNodes.add(host.appendChild(styleEl));
      });
    };
    DomSharedStylesHost.prototype.addHost = function(hostNode) {
      this._addStylesToHost(this._stylesSet, hostNode);
      this._hostNodes.add(hostNode);
    };
    DomSharedStylesHost.prototype.removeHost = function(hostNode) {
      this._hostNodes.delete(hostNode);
    };
    DomSharedStylesHost.prototype.onStylesAdded = function(additions) {
      var _this = this;
      this._hostNodes.forEach(function(hostNode) {
        return _this._addStylesToHost(additions, hostNode);
      });
    };
    DomSharedStylesHost.prototype.ngOnDestroy = function() {
      this._styleNodes.forEach(function(styleNode) {
        return getDOM().remove(styleNode);
      });
    };
    return DomSharedStylesHost;
  }(SharedStylesHost));
  DomSharedStylesHost.decorators = [{type: _angular_core.Injectable}];
  DomSharedStylesHost.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [DOCUMENT$1]
      }]
    }];
  };
  var NAMESPACE_URIS = {
    'svg': 'http://www.w3.org/2000/svg',
    'xhtml': 'http://www.w3.org/1999/xhtml',
    'xlink': 'http://www.w3.org/1999/xlink',
    'xml': 'http://www.w3.org/XML/1998/namespace',
    'xmlns': 'http://www.w3.org/2000/xmlns/'
  };
  var COMPONENT_REGEX = /%COMP%/g;
  var COMPONENT_VARIABLE = '%COMP%';
  var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
  var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
  function shimContentAttribute(componentShortId) {
    return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
  }
  function shimHostAttribute(componentShortId) {
    return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
  }
  function flattenStyles(compId, styles, target) {
    for (var i = 0; i < styles.length; i++) {
      var style = styles[i];
      if (Array.isArray(style)) {
        flattenStyles(compId, style, target);
      } else {
        style = style.replace(COMPONENT_REGEX, compId);
        target.push(style);
      }
    }
    return target;
  }
  function decoratePreventDefault(eventHandler) {
    return function(event) {
      var allowDefaultBehavior = eventHandler(event);
      if (allowDefaultBehavior === false) {
        event.preventDefault();
        event.returnValue = false;
      }
    };
  }
  var DomRendererFactory2 = (function() {
    function DomRendererFactory2(eventManager, sharedStylesHost) {
      this.eventManager = eventManager;
      this.sharedStylesHost = sharedStylesHost;
      this.rendererByCompId = new Map();
      this.defaultRenderer = new DefaultDomRenderer2(eventManager);
    }
    DomRendererFactory2.prototype.createRenderer = function(element, type) {
      if (!element || !type) {
        return this.defaultRenderer;
      }
      switch (type.encapsulation) {
        case _angular_core.ViewEncapsulation.Emulated:
          {
            var renderer = this.rendererByCompId.get(type.id);
            if (!renderer) {
              renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type);
              this.rendererByCompId.set(type.id, renderer);
            }
            ((renderer)).applyToHost(element);
            return renderer;
          }
        case _angular_core.ViewEncapsulation.Native:
          return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
        default:
          {
            if (!this.rendererByCompId.has(type.id)) {
              var styles = flattenStyles(type.id, type.styles, []);
              this.sharedStylesHost.addStyles(styles);
              this.rendererByCompId.set(type.id, this.defaultRenderer);
            }
            return this.defaultRenderer;
          }
      }
    };
    DomRendererFactory2.prototype.begin = function() {};
    DomRendererFactory2.prototype.end = function() {};
    return DomRendererFactory2;
  }());
  DomRendererFactory2.decorators = [{type: _angular_core.Injectable}];
  DomRendererFactory2.ctorParameters = function() {
    return [{type: EventManager}, {type: DomSharedStylesHost}];
  };
  var DefaultDomRenderer2 = (function() {
    function DefaultDomRenderer2(eventManager) {
      this.eventManager = eventManager;
      this.data = Object.create(null);
    }
    DefaultDomRenderer2.prototype.destroy = function() {};
    DefaultDomRenderer2.prototype.createElement = function(name, namespace) {
      if (namespace) {
        return document.createElementNS(NAMESPACE_URIS[namespace], name);
      }
      return document.createElement(name);
    };
    DefaultDomRenderer2.prototype.createComment = function(value) {
      return document.createComment(value);
    };
    DefaultDomRenderer2.prototype.createText = function(value) {
      return document.createTextNode(value);
    };
    DefaultDomRenderer2.prototype.appendChild = function(parent, newChild) {
      parent.appendChild(newChild);
    };
    DefaultDomRenderer2.prototype.insertBefore = function(parent, newChild, refChild) {
      if (parent) {
        parent.insertBefore(newChild, refChild);
      }
    };
    DefaultDomRenderer2.prototype.removeChild = function(parent, oldChild) {
      if (parent) {
        parent.removeChild(oldChild);
      }
    };
    DefaultDomRenderer2.prototype.selectRootElement = function(selectorOrNode) {
      var el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) : selectorOrNode;
      if (!el) {
        throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
      }
      el.textContent = '';
      return el;
    };
    DefaultDomRenderer2.prototype.parentNode = function(node) {
      return node.parentNode;
    };
    DefaultDomRenderer2.prototype.nextSibling = function(node) {
      return node.nextSibling;
    };
    DefaultDomRenderer2.prototype.setAttribute = function(el, name, value, namespace) {
      if (namespace) {
        name = namespace + ":" + name;
        var namespaceUri = NAMESPACE_URIS[namespace];
        if (namespaceUri) {
          el.setAttributeNS(namespaceUri, name, value);
        } else {
          el.setAttribute(name, value);
        }
      } else {
        el.setAttribute(name, value);
      }
    };
    DefaultDomRenderer2.prototype.removeAttribute = function(el, name, namespace) {
      if (namespace) {
        var namespaceUri = NAMESPACE_URIS[namespace];
        if (namespaceUri) {
          el.removeAttributeNS(namespaceUri, name);
        } else {
          el.removeAttribute(namespace + ":" + name);
        }
      } else {
        el.removeAttribute(name);
      }
    };
    DefaultDomRenderer2.prototype.addClass = function(el, name) {
      el.classList.add(name);
    };
    DefaultDomRenderer2.prototype.removeClass = function(el, name) {
      el.classList.remove(name);
    };
    DefaultDomRenderer2.prototype.setStyle = function(el, style, value, flags) {
      if (flags & _angular_core.RendererStyleFlags2.DashCase) {
        el.style.setProperty(style, value, !!(flags & _angular_core.RendererStyleFlags2.Important) ? 'important' : '');
      } else {
        el.style[style] = value;
      }
    };
    DefaultDomRenderer2.prototype.removeStyle = function(el, style, flags) {
      if (flags & _angular_core.RendererStyleFlags2.DashCase) {
        el.style.removeProperty(style);
      } else {
        el.style[style] = '';
      }
    };
    DefaultDomRenderer2.prototype.setProperty = function(el, name, value) {
      checkNoSyntheticProp(name, 'property');
      el[name] = value;
    };
    DefaultDomRenderer2.prototype.setValue = function(node, value) {
      node.nodeValue = value;
    };
    DefaultDomRenderer2.prototype.listen = function(target, event, callback) {
      checkNoSyntheticProp(event, 'listener');
      if (typeof target === 'string') {
        return (this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback)));
      }
      return ((this.eventManager.addEventListener(target, event, decoratePreventDefault(callback))));
    };
    return DefaultDomRenderer2;
  }());
  var AT_CHARCODE = '@'.charCodeAt(0);
  function checkNoSyntheticProp(name, nameKind) {
    if (name.charCodeAt(0) === AT_CHARCODE) {
      throw new Error("Found the synthetic " + nameKind + " " + name + ". Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.");
    }
  }
  var EmulatedEncapsulationDomRenderer2 = (function(_super) {
    __extends(EmulatedEncapsulationDomRenderer2, _super);
    function EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, component) {
      var _this = _super.call(this, eventManager) || this;
      _this.component = component;
      var styles = flattenStyles(component.id, component.styles, []);
      sharedStylesHost.addStyles(styles);
      _this.contentAttr = shimContentAttribute(component.id);
      _this.hostAttr = shimHostAttribute(component.id);
      return _this;
    }
    EmulatedEncapsulationDomRenderer2.prototype.applyToHost = function(element) {
      _super.prototype.setAttribute.call(this, element, this.hostAttr, '');
    };
    EmulatedEncapsulationDomRenderer2.prototype.createElement = function(parent, name) {
      var el = _super.prototype.createElement.call(this, parent, name);
      _super.prototype.setAttribute.call(this, el, this.contentAttr, '');
      return el;
    };
    return EmulatedEncapsulationDomRenderer2;
  }(DefaultDomRenderer2));
  var ShadowDomRenderer = (function(_super) {
    __extends(ShadowDomRenderer, _super);
    function ShadowDomRenderer(eventManager, sharedStylesHost, hostEl, component) {
      var _this = _super.call(this, eventManager) || this;
      _this.sharedStylesHost = sharedStylesHost;
      _this.hostEl = hostEl;
      _this.component = component;
      _this.shadowRoot = hostEl.createShadowRoot();
      _this.sharedStylesHost.addHost(_this.shadowRoot);
      var styles = flattenStyles(component.id, component.styles, []);
      for (var i = 0; i < styles.length; i++) {
        var styleEl = document.createElement('style');
        styleEl.textContent = styles[i];
        _this.shadowRoot.appendChild(styleEl);
      }
      return _this;
    }
    ShadowDomRenderer.prototype.nodeOrShadowRoot = function(node) {
      return node === this.hostEl ? this.shadowRoot : node;
    };
    ShadowDomRenderer.prototype.destroy = function() {
      this.sharedStylesHost.removeHost(this.shadowRoot);
    };
    ShadowDomRenderer.prototype.appendChild = function(parent, newChild) {
      return _super.prototype.appendChild.call(this, this.nodeOrShadowRoot(parent), newChild);
    };
    ShadowDomRenderer.prototype.insertBefore = function(parent, newChild, refChild) {
      return _super.prototype.insertBefore.call(this, this.nodeOrShadowRoot(parent), newChild, refChild);
    };
    ShadowDomRenderer.prototype.removeChild = function(parent, oldChild) {
      return _super.prototype.removeChild.call(this, this.nodeOrShadowRoot(parent), oldChild);
    };
    ShadowDomRenderer.prototype.parentNode = function(node) {
      return this.nodeOrShadowRoot(_super.prototype.parentNode.call(this, this.nodeOrShadowRoot(node)));
    };
    return ShadowDomRenderer;
  }(DefaultDomRenderer2));
  var DomEventsPlugin = (function(_super) {
    __extends(DomEventsPlugin, _super);
    function DomEventsPlugin(doc) {
      return _super.call(this, doc) || this;
    }
    DomEventsPlugin.prototype.supports = function(eventName) {
      return true;
    };
    DomEventsPlugin.prototype.addEventListener = function(element, eventName, handler) {
      element.addEventListener(eventName, (handler), false);
      return function() {
        return element.removeEventListener(eventName, (handler), false);
      };
    };
    return DomEventsPlugin;
  }(EventManagerPlugin));
  DomEventsPlugin.decorators = [{type: _angular_core.Injectable}];
  DomEventsPlugin.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [DOCUMENT$1]
      }]
    }];
  };
  var EVENT_NAMES = {
    'pan': true,
    'panstart': true,
    'panmove': true,
    'panend': true,
    'pancancel': true,
    'panleft': true,
    'panright': true,
    'panup': true,
    'pandown': true,
    'pinch': true,
    'pinchstart': true,
    'pinchmove': true,
    'pinchend': true,
    'pinchcancel': true,
    'pinchin': true,
    'pinchout': true,
    'press': true,
    'pressup': true,
    'rotate': true,
    'rotatestart': true,
    'rotatemove': true,
    'rotateend': true,
    'rotatecancel': true,
    'swipe': true,
    'swipeleft': true,
    'swiperight': true,
    'swipeup': true,
    'swipedown': true,
    'tap': true
  };
  var HAMMER_GESTURE_CONFIG = new _angular_core.InjectionToken('HammerGestureConfig');
  var HammerGestureConfig = (function() {
    function HammerGestureConfig() {
      this.events = [];
      this.overrides = {};
    }
    HammerGestureConfig.prototype.buildHammer = function(element) {
      var mc = new Hammer(element);
      mc.get('pinch').set({enable: true});
      mc.get('rotate').set({enable: true});
      for (var eventName in this.overrides) {
        mc.get(eventName).set(this.overrides[eventName]);
      }
      return mc;
    };
    return HammerGestureConfig;
  }());
  HammerGestureConfig.decorators = [{type: _angular_core.Injectable}];
  HammerGestureConfig.ctorParameters = function() {
    return [];
  };
  var HammerGesturesPlugin = (function(_super) {
    __extends(HammerGesturesPlugin, _super);
    function HammerGesturesPlugin(doc, _config) {
      var _this = _super.call(this, doc) || this;
      _this._config = _config;
      return _this;
    }
    HammerGesturesPlugin.prototype.supports = function(eventName) {
      if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
        return false;
      }
      if (!((window)).Hammer) {
        throw new Error("Hammer.js is not loaded, can not bind " + eventName + " event");
      }
      return true;
    };
    HammerGesturesPlugin.prototype.addEventListener = function(element, eventName, handler) {
      var _this = this;
      var zone = this.manager.getZone();
      eventName = eventName.toLowerCase();
      return zone.runOutsideAngular(function() {
        var mc = _this._config.buildHammer(element);
        var callback = function(eventObj) {
          zone.runGuarded(function() {
            handler(eventObj);
          });
        };
        mc.on(eventName, callback);
        return function() {
          return mc.off(eventName, callback);
        };
      });
    };
    HammerGesturesPlugin.prototype.isCustomEvent = function(eventName) {
      return this._config.events.indexOf(eventName) > -1;
    };
    return HammerGesturesPlugin;
  }(EventManagerPlugin));
  HammerGesturesPlugin.decorators = [{type: _angular_core.Injectable}];
  HammerGesturesPlugin.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [DOCUMENT$1]
      }]
    }, {
      type: HammerGestureConfig,
      decorators: [{
        type: _angular_core.Inject,
        args: [HAMMER_GESTURE_CONFIG]
      }]
    }];
  };
  var MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];
  var MODIFIER_KEY_GETTERS = {
    'alt': function(event) {
      return event.altKey;
    },
    'control': function(event) {
      return event.ctrlKey;
    },
    'meta': function(event) {
      return event.metaKey;
    },
    'shift': function(event) {
      return event.shiftKey;
    }
  };
  var KeyEventsPlugin = (function(_super) {
    __extends(KeyEventsPlugin, _super);
    function KeyEventsPlugin(doc) {
      return _super.call(this, doc) || this;
    }
    KeyEventsPlugin.prototype.supports = function(eventName) {
      return KeyEventsPlugin.parseEventName(eventName) != null;
    };
    KeyEventsPlugin.prototype.addEventListener = function(element, eventName, handler) {
      var parsedEvent = ((KeyEventsPlugin.parseEventName(eventName)));
      var outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());
      return this.manager.getZone().runOutsideAngular(function() {
        return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);
      });
    };
    KeyEventsPlugin.parseEventName = function(eventName) {
      var parts = eventName.toLowerCase().split('.');
      var domEventName = parts.shift();
      if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {
        return null;
      }
      var key = KeyEventsPlugin._normalizeKey(((parts.pop())));
      var fullKey = '';
      MODIFIER_KEYS.forEach(function(modifierName) {
        var index = parts.indexOf(modifierName);
        if (index > -1) {
          parts.splice(index, 1);
          fullKey += modifierName + '.';
        }
      });
      fullKey += key;
      if (parts.length != 0 || key.length === 0) {
        return null;
      }
      var result = {};
      result['domEventName'] = domEventName;
      result['fullKey'] = fullKey;
      return result;
    };
    KeyEventsPlugin.getEventFullKey = function(event) {
      var fullKey = '';
      var key = getDOM().getEventKey(event);
      key = key.toLowerCase();
      if (key === ' ') {
        key = 'space';
      } else if (key === '.') {
        key = 'dot';
      }
      MODIFIER_KEYS.forEach(function(modifierName) {
        if (modifierName != key) {
          var modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
          if (modifierGetter(event)) {
            fullKey += modifierName + '.';
          }
        }
      });
      fullKey += key;
      return fullKey;
    };
    KeyEventsPlugin.eventCallback = function(fullKey, handler, zone) {
      return function(event) {
        if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
          zone.runGuarded(function() {
            return handler(event);
          });
        }
      };
    };
    KeyEventsPlugin._normalizeKey = function(keyName) {
      switch (keyName) {
        case 'esc':
          return 'escape';
        default:
          return keyName;
      }
    };
    return KeyEventsPlugin;
  }(EventManagerPlugin));
  KeyEventsPlugin.decorators = [{type: _angular_core.Injectable}];
  KeyEventsPlugin.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [DOCUMENT$1]
      }]
    }];
  };
  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
  function sanitizeUrl(url) {
    url = String(url);
    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
      return url;
    if (_angular_core.isDevMode()) {
      getDOM().log("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)");
    }
    return 'unsafe:' + url;
  }
  function sanitizeSrcset(srcset) {
    srcset = String(srcset);
    return srcset.split(',').map(function(srcset) {
      return sanitizeUrl(srcset.trim());
    }).join(', ');
  }
  var inertElement = null;
  var DOM = null;
  function getInertElement() {
    if (inertElement)
      return inertElement;
    DOM = getDOM();
    var templateEl = DOM.createElement('template');
    if ('content' in templateEl)
      return templateEl;
    var doc = DOM.createHtmlDocument();
    inertElement = DOM.querySelector(doc, 'body');
    if (inertElement == null) {
      var html = DOM.createElement('html', doc);
      inertElement = DOM.createElement('body', doc);
      DOM.appendChild(html, inertElement);
      DOM.appendChild(doc, html);
    }
    return inertElement;
  }
  function tagSet(tags) {
    var res = {};
    for (var _i = 0,
        _a = tags.split(','); _i < _a.length; _i++) {
      var t = _a[_i];
      res[t] = true;
    }
    return res;
  }
  function merge() {
    var sets = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sets[_i] = arguments[_i];
    }
    var res = {};
    for (var _a = 0,
        sets_1 = sets; _a < sets_1.length; _a++) {
      var s = sets_1[_a];
      for (var v in s) {
        if (s.hasOwnProperty(v))
          res[v] = true;
      }
    }
    return res;
  }
  var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
  var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
  var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
  var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
  var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' + 'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' + 'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
  var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' + 'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' + 'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
  var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
  var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
  var SRCSET_ATTRS = tagSet('srcset');
  var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' + 'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' + 'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' + 'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' + 'valign,value,vspace,width');
  var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
  var SanitizingHtmlSerializer = (function() {
    function SanitizingHtmlSerializer() {
      this.sanitizedSomething = false;
      this.buf = [];
    }
    SanitizingHtmlSerializer.prototype.sanitizeChildren = function(el) {
      var current = ((el.firstChild));
      while (current) {
        if (DOM.isElementNode(current)) {
          this.startElement((current));
        } else if (DOM.isTextNode(current)) {
          this.chars(((DOM.nodeValue(current))));
        } else {
          this.sanitizedSomething = true;
        }
        if (DOM.firstChild(current)) {
          current = ((DOM.firstChild(current)));
          continue;
        }
        while (current) {
          if (DOM.isElementNode(current)) {
            this.endElement((current));
          }
          var next = checkClobberedElement(current, ((DOM.nextSibling(current))));
          if (next) {
            current = next;
            break;
          }
          current = checkClobberedElement(current, ((DOM.parentElement(current))));
        }
      }
      return this.buf.join('');
    };
    SanitizingHtmlSerializer.prototype.startElement = function(element) {
      var _this = this;
      var tagName = DOM.nodeName(element).toLowerCase();
      if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
        this.sanitizedSomething = true;
        return;
      }
      this.buf.push('<');
      this.buf.push(tagName);
      DOM.attributeMap(element).forEach(function(value, attrName) {
        var lower = attrName.toLowerCase();
        if (!VALID_ATTRS.hasOwnProperty(lower)) {
          _this.sanitizedSomething = true;
          return;
        }
        if (URI_ATTRS[lower])
          value = sanitizeUrl(value);
        if (SRCSET_ATTRS[lower])
          value = sanitizeSrcset(value);
        _this.buf.push(' ');
        _this.buf.push(attrName);
        _this.buf.push('="');
        _this.buf.push(encodeEntities(value));
        _this.buf.push('"');
      });
      this.buf.push('>');
    };
    SanitizingHtmlSerializer.prototype.endElement = function(current) {
      var tagName = DOM.nodeName(current).toLowerCase();
      if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
        this.buf.push('</');
        this.buf.push(tagName);
        this.buf.push('>');
      }
    };
    SanitizingHtmlSerializer.prototype.chars = function(chars) {
      this.buf.push(encodeEntities(chars));
    };
    return SanitizingHtmlSerializer;
  }());
  function checkClobberedElement(node, nextNode) {
    if (nextNode && DOM.contains(node, nextNode)) {
      throw new Error("Failed to sanitize html because the element is clobbered: " + DOM.getOuterHTML(node));
    }
    return nextNode;
  }
  var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
  function encodeEntities(value) {
    return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(match) {
      var hi = match.charCodeAt(0);
      var low = match.charCodeAt(1);
      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
    }).replace(NON_ALPHANUMERIC_REGEXP, function(match) {
      return '&#' + match.charCodeAt(0) + ';';
    }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }
  function stripCustomNsAttrs(el) {
    DOM.attributeMap(el).forEach(function(_, attrName) {
      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
        DOM.removeAttribute(el, attrName);
      }
    });
    for (var _i = 0,
        _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {
      var n = _a[_i];
      if (DOM.isElementNode(n))
        stripCustomNsAttrs((n));
    }
  }
  function sanitizeHtml(defaultDoc, unsafeHtmlInput) {
    try {
      var containerEl = getInertElement();
      var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
      var mXSSAttempts = 5;
      var parsedHtml = unsafeHtml;
      do {
        if (mXSSAttempts === 0) {
          throw new Error('Failed to sanitize html because the input is unstable');
        }
        mXSSAttempts--;
        unsafeHtml = parsedHtml;
        DOM.setInnerHTML(containerEl, unsafeHtml);
        if (defaultDoc.documentMode) {
          stripCustomNsAttrs(containerEl);
        }
        parsedHtml = DOM.getInnerHTML(containerEl);
      } while (unsafeHtml !== parsedHtml);
      var sanitizer = new SanitizingHtmlSerializer();
      var safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);
      var parent = DOM.getTemplateContent(containerEl) || containerEl;
      for (var _i = 0,
          _a = DOM.childNodesAsList(parent); _i < _a.length; _i++) {
        var child = _a[_i];
        DOM.removeChild(parent, child);
      }
      if (_angular_core.isDevMode() && sanitizer.sanitizedSomething) {
        DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');
      }
      return safeHtml;
    } catch (e) {
      inertElement = null;
      throw e;
    }
  }
  var VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
  var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
  var COLOR_FNS = '(?:rgb|hsl)a?';
  var GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';
  var CSS3_FNS = '(?:calc|attr)';
  var FN_ARGS = '\\([-0-9.%, #a-zA-Z]+\\)';
  var SAFE_STYLE_VALUE = new RegExp("^(" + VALUES + "|" + ("(?:" + TRANSFORMATION_FNS + "|" + COLOR_FNS + "|" + GRADIENTS + "|" + CSS3_FNS + ")") + (FN_ARGS + ")$"), 'g');
  var URL_RE = /^url\(([^)]+)\)$/;
  function hasBalancedQuotes(value) {
    var outsideSingle = true;
    var outsideDouble = true;
    for (var i = 0; i < value.length; i++) {
      var c = value.charAt(i);
      if (c === '\'' && outsideDouble) {
        outsideSingle = !outsideSingle;
      } else if (c === '"' && outsideSingle) {
        outsideDouble = !outsideDouble;
      }
    }
    return outsideSingle && outsideDouble;
  }
  function sanitizeStyle(value) {
    value = String(value).trim();
    if (!value)
      return '';
    var urlMatch = value.match(URL_RE);
    if ((urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1]) || value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
      return value;
    }
    if (_angular_core.isDevMode()) {
      getDOM().log("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss).");
    }
    return 'unsafe';
  }
  var DomSanitizer = (function() {
    function DomSanitizer() {}
    DomSanitizer.prototype.sanitize = function(context, value) {};
    DomSanitizer.prototype.bypassSecurityTrustHtml = function(value) {};
    DomSanitizer.prototype.bypassSecurityTrustStyle = function(value) {};
    DomSanitizer.prototype.bypassSecurityTrustScript = function(value) {};
    DomSanitizer.prototype.bypassSecurityTrustUrl = function(value) {};
    DomSanitizer.prototype.bypassSecurityTrustResourceUrl = function(value) {};
    return DomSanitizer;
  }());
  var DomSanitizerImpl = (function(_super) {
    __extends(DomSanitizerImpl, _super);
    function DomSanitizerImpl(_doc) {
      var _this = _super.call(this) || this;
      _this._doc = _doc;
      return _this;
    }
    DomSanitizerImpl.prototype.sanitize = function(ctx, value) {
      if (value == null)
        return null;
      switch (ctx) {
        case _angular_core.SecurityContext.NONE:
          return (value);
        case _angular_core.SecurityContext.HTML:
          if (value instanceof SafeHtmlImpl)
            return value.changingThisBreaksApplicationSecurity;
          this.checkNotSafeValue(value, 'HTML');
          return sanitizeHtml(this._doc, String(value));
        case _angular_core.SecurityContext.STYLE:
          if (value instanceof SafeStyleImpl)
            return value.changingThisBreaksApplicationSecurity;
          this.checkNotSafeValue(value, 'Style');
          return sanitizeStyle((value));
        case _angular_core.SecurityContext.SCRIPT:
          if (value instanceof SafeScriptImpl)
            return value.changingThisBreaksApplicationSecurity;
          this.checkNotSafeValue(value, 'Script');
          throw new Error('unsafe value used in a script context');
        case _angular_core.SecurityContext.URL:
          if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {
            return value.changingThisBreaksApplicationSecurity;
          }
          this.checkNotSafeValue(value, 'URL');
          return sanitizeUrl(String(value));
        case _angular_core.SecurityContext.RESOURCE_URL:
          if (value instanceof SafeResourceUrlImpl) {
            return value.changingThisBreaksApplicationSecurity;
          }
          this.checkNotSafeValue(value, 'ResourceURL');
          throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
        default:
          throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");
      }
    };
    DomSanitizerImpl.prototype.checkNotSafeValue = function(value, expectedType) {
      if (value instanceof SafeValueImpl) {
        throw new Error("Required a safe " + expectedType + ", got a " + value.getTypeName() + " " + "(see http://g.co/ng/security#xss)");
      }
    };
    DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function(value) {
      return new SafeHtmlImpl(value);
    };
    DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function(value) {
      return new SafeStyleImpl(value);
    };
    DomSanitizerImpl.prototype.bypassSecurityTrustScript = function(value) {
      return new SafeScriptImpl(value);
    };
    DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function(value) {
      return new SafeUrlImpl(value);
    };
    DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function(value) {
      return new SafeResourceUrlImpl(value);
    };
    return DomSanitizerImpl;
  }(DomSanitizer));
  DomSanitizerImpl.decorators = [{type: _angular_core.Injectable}];
  DomSanitizerImpl.ctorParameters = function() {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core.Inject,
        args: [DOCUMENT$1]
      }]
    }];
  };
  var SafeValueImpl = (function() {
    function SafeValueImpl(changingThisBreaksApplicationSecurity) {
      this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
    }
    SafeValueImpl.prototype.getTypeName = function() {};
    SafeValueImpl.prototype.toString = function() {
      return "SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity + " (see http://g.co/ng/security#xss)";
    };
    return SafeValueImpl;
  }());
  var SafeHtmlImpl = (function(_super) {
    __extends(SafeHtmlImpl, _super);
    function SafeHtmlImpl() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SafeHtmlImpl.prototype.getTypeName = function() {
      return 'HTML';
    };
    return SafeHtmlImpl;
  }(SafeValueImpl));
  var SafeStyleImpl = (function(_super) {
    __extends(SafeStyleImpl, _super);
    function SafeStyleImpl() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SafeStyleImpl.prototype.getTypeName = function() {
      return 'Style';
    };
    return SafeStyleImpl;
  }(SafeValueImpl));
  var SafeScriptImpl = (function(_super) {
    __extends(SafeScriptImpl, _super);
    function SafeScriptImpl() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SafeScriptImpl.prototype.getTypeName = function() {
      return 'Script';
    };
    return SafeScriptImpl;
  }(SafeValueImpl));
  var SafeUrlImpl = (function(_super) {
    __extends(SafeUrlImpl, _super);
    function SafeUrlImpl() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SafeUrlImpl.prototype.getTypeName = function() {
      return 'URL';
    };
    return SafeUrlImpl;
  }(SafeValueImpl));
  var SafeResourceUrlImpl = (function(_super) {
    __extends(SafeResourceUrlImpl, _super);
    function SafeResourceUrlImpl() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SafeResourceUrlImpl.prototype.getTypeName = function() {
      return 'ResourceURL';
    };
    return SafeResourceUrlImpl;
  }(SafeValueImpl));
  var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
    provide: _angular_core.PLATFORM_ID,
    useValue: _angular_common.ɵPLATFORM_BROWSER_ID
  }, {
    provide: _angular_core.PLATFORM_INITIALIZER,
    useValue: initDomAdapter,
    multi: true
  }, {
    provide: _angular_common.PlatformLocation,
    useClass: BrowserPlatformLocation
  }, {
    provide: DOCUMENT$1,
    useFactory: _document,
    deps: []
  }];
  var BROWSER_SANITIZATION_PROVIDERS = [{
    provide: _angular_core.Sanitizer,
    useExisting: DomSanitizer
  }, {
    provide: DomSanitizer,
    useClass: DomSanitizerImpl
  }];
  var platformBrowser = _angular_core.createPlatformFactory(_angular_core.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
  function initDomAdapter() {
    BrowserDomAdapter.makeCurrent();
    BrowserGetTestability.init();
  }
  function errorHandler() {
    return new _angular_core.ErrorHandler();
  }
  function _document() {
    return document;
  }
  var BrowserModule = (function() {
    function BrowserModule(parentModule) {
      if (parentModule) {
        throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");
      }
    }
    BrowserModule.withServerTransition = function(params) {
      return {
        ngModule: BrowserModule,
        providers: [{
          provide: _angular_core.APP_ID,
          useValue: params.appId
        }, {
          provide: TRANSITION_ID,
          useExisting: _angular_core.APP_ID
        }, SERVER_TRANSITION_PROVIDERS]
      };
    };
    return BrowserModule;
  }());
  BrowserModule.decorators = [{
    type: _angular_core.NgModule,
    args: [{
      providers: [BROWSER_SANITIZATION_PROVIDERS, {
        provide: _angular_core.ErrorHandler,
        useFactory: errorHandler,
        deps: []
      }, {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: DomEventsPlugin,
        multi: true
      }, {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: KeyEventsPlugin,
        multi: true
      }, {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: HammerGesturesPlugin,
        multi: true
      }, {
        provide: HAMMER_GESTURE_CONFIG,
        useClass: HammerGestureConfig
      }, DomRendererFactory2, {
        provide: _angular_core.RendererFactory2,
        useExisting: DomRendererFactory2
      }, {
        provide: SharedStylesHost,
        useExisting: DomSharedStylesHost
      }, DomSharedStylesHost, _angular_core.Testability, EventManager, ELEMENT_PROBE_PROVIDERS, Meta, Title],
      exports: [_angular_common.CommonModule, _angular_core.ApplicationModule]
    }]
  }];
  BrowserModule.ctorParameters = function() {
    return [{
      type: BrowserModule,
      decorators: [{type: _angular_core.Optional}, {type: _angular_core.SkipSelf}]
    }];
  };
  var win = typeof window !== 'undefined' && window || {};
  var ChangeDetectionPerfRecord = (function() {
    function ChangeDetectionPerfRecord(msPerTick, numTicks) {
      this.msPerTick = msPerTick;
      this.numTicks = numTicks;
    }
    return ChangeDetectionPerfRecord;
  }());
  var AngularProfiler = (function() {
    function AngularProfiler(ref) {
      this.appRef = ref.injector.get(_angular_core.ApplicationRef);
    }
    AngularProfiler.prototype.timeChangeDetection = function(config) {
      var record = config && config['record'];
      var profileName = 'Change Detection';
      var isProfilerAvailable = win.console.profile != null;
      if (record && isProfilerAvailable) {
        win.console.profile(profileName);
      }
      var start = getDOM().performanceNow();
      var numTicks = 0;
      while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {
        this.appRef.tick();
        numTicks++;
      }
      var end = getDOM().performanceNow();
      if (record && isProfilerAvailable) {
        ((win.console.profileEnd))(profileName);
      }
      var msPerTick = (end - start) / numTicks;
      win.console.log("ran " + numTicks + " change detection cycles");
      win.console.log(msPerTick.toFixed(2) + " ms per check");
      return new ChangeDetectionPerfRecord(msPerTick, numTicks);
    };
    return AngularProfiler;
  }());
  var PROFILER_GLOBAL_NAME = 'profiler';
  function enableDebugTools(ref) {
    exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));
    return ref;
  }
  function disableDebugTools() {
    exportNgVar(PROFILER_GLOBAL_NAME, null);
  }
  var By = (function() {
    function By() {}
    By.all = function() {
      return function(debugElement) {
        return true;
      };
    };
    By.css = function(selector) {
      return function(debugElement) {
        return debugElement.nativeElement != null ? getDOM().elementMatches(debugElement.nativeElement, selector) : false;
      };
    };
    By.directive = function(type) {
      return function(debugElement) {
        return ((debugElement.providerTokens)).indexOf(type) !== -1;
      };
    };
    return By;
  }());
  var VERSION = new _angular_core.Version('4.3.4');
  exports.BrowserModule = BrowserModule;
  exports.platformBrowser = platformBrowser;
  exports.Meta = Meta;
  exports.Title = Title;
  exports.disableDebugTools = disableDebugTools;
  exports.enableDebugTools = enableDebugTools;
  exports.By = By;
  exports.NgProbeToken = NgProbeToken$1;
  exports.DOCUMENT = DOCUMENT$1;
  exports.EVENT_MANAGER_PLUGINS = EVENT_MANAGER_PLUGINS;
  exports.EventManager = EventManager;
  exports.HAMMER_GESTURE_CONFIG = HAMMER_GESTURE_CONFIG;
  exports.HammerGestureConfig = HammerGestureConfig;
  exports.DomSanitizer = DomSanitizer;
  exports.VERSION = VERSION;
  exports.ɵBROWSER_SANITIZATION_PROVIDERS = BROWSER_SANITIZATION_PROVIDERS;
  exports.ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS = INTERNAL_BROWSER_PLATFORM_PROVIDERS;
  exports.ɵinitDomAdapter = initDomAdapter;
  exports.ɵBrowserDomAdapter = BrowserDomAdapter;
  exports.ɵBrowserPlatformLocation = BrowserPlatformLocation;
  exports.ɵTRANSITION_ID = TRANSITION_ID;
  exports.ɵBrowserGetTestability = BrowserGetTestability;
  exports.ɵELEMENT_PROBE_PROVIDERS = ELEMENT_PROBE_PROVIDERS;
  exports.ɵDomAdapter = DomAdapter;
  exports.ɵgetDOM = getDOM;
  exports.ɵsetRootDomAdapter = setRootDomAdapter;
  exports.ɵDomRendererFactory2 = DomRendererFactory2;
  exports.ɵNAMESPACE_URIS = NAMESPACE_URIS;
  exports.ɵflattenStyles = flattenStyles;
  exports.ɵshimContentAttribute = shimContentAttribute;
  exports.ɵshimHostAttribute = shimHostAttribute;
  exports.ɵDomEventsPlugin = DomEventsPlugin;
  exports.ɵHammerGesturesPlugin = HammerGesturesPlugin;
  exports.ɵKeyEventsPlugin = KeyEventsPlugin;
  exports.ɵDomSharedStylesHost = DomSharedStylesHost;
  exports.ɵSharedStylesHost = SharedStylesHost;
  exports.ɵb = _document;
  exports.ɵa = errorHandler;
  exports.ɵh = GenericBrowserDomAdapter;
  exports.ɵg = SERVER_TRANSITION_PROVIDERS;
  exports.ɵf = appInitializerFactory;
  exports.ɵc = _createNgProbe;
  exports.ɵd = EventManagerPlugin;
  exports.ɵe = DomSanitizerImpl;
  Object.defineProperty(exports, '__esModule', {value: true});
})));

})();
(function() {
var define = System.amdDefine;
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/compiler'), require('@angular/core'), require('@angular/common'), require('@angular/platform-browser')) : typeof define === 'function' && define.amd ? define("node_modules/@angular/platform-browser-dynamic/bundles/platform-browser-dynamic.umd.js", ["exports", "node_modules/@angular/compiler/bundles/compiler.umd.js", "node_modules/@angular/core/bundles/core.umd.js", "node_modules/@angular/common/bundles/common.umd.js", "node_modules/@angular/platform-browser/bundles/platform-browser.umd.js"], factory) : (factory((global.ng = global.ng || {}, global.ng.platformBrowserDynamic = global.ng.platformBrowserDynamic || {}), global.ng.compiler, global.ng.core, global.ng.common, global.ng.platformBrowser));
}(this, (function(exports, _angular_compiler, _angular_core, _angular_common, _angular_platformBrowser) {
  'use strict';
  var extendStatics = Object.setPrototypeOf || ({__proto__: []} instanceof Array && function(d, b) {
    d.__proto__ = b;
  }) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
  };
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var ResourceLoaderImpl = (function(_super) {
    __extends(ResourceLoaderImpl, _super);
    function ResourceLoaderImpl() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ResourceLoaderImpl.prototype.get = function(url) {
      var resolve;
      var reject;
      var promise = new Promise(function(res, rej) {
        resolve = res;
        reject = rej;
      });
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.responseType = 'text';
      xhr.onload = function() {
        var response = xhr.response || xhr.responseText;
        var status = xhr.status === 1223 ? 204 : xhr.status;
        if (status === 0) {
          status = response ? 200 : 0;
        }
        if (200 <= status && status <= 300) {
          resolve(response);
        } else {
          reject("Failed to load " + url);
        }
      };
      xhr.onerror = function() {
        reject("Failed to load " + url);
      };
      xhr.send();
      return promise;
    };
    return ResourceLoaderImpl;
  }(_angular_compiler.ResourceLoader));
  ResourceLoaderImpl.decorators = [{type: _angular_core.Injectable}];
  ResourceLoaderImpl.ctorParameters = function() {
    return [];
  };
  var INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [_angular_platformBrowser.ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS, {
    provide: _angular_core.COMPILER_OPTIONS,
    useValue: {providers: [{
        provide: _angular_compiler.ResourceLoader,
        useClass: ResourceLoaderImpl
      }]},
    multi: true
  }, {
    provide: _angular_core.PLATFORM_ID,
    useValue: _angular_common.ɵPLATFORM_BROWSER_ID
  }];
  var CachedResourceLoader = (function(_super) {
    __extends(CachedResourceLoader, _super);
    function CachedResourceLoader() {
      var _this = _super.call(this) || this;
      _this._cache = _angular_core.ɵglobal.$templateCache;
      if (_this._cache == null) {
        throw new Error('CachedResourceLoader: Template cache was not found in $templateCache.');
      }
      return _this;
    }
    CachedResourceLoader.prototype.get = function(url) {
      if (this._cache.hasOwnProperty(url)) {
        return Promise.resolve(this._cache[url]);
      } else {
        return Promise.reject('CachedResourceLoader: Did not find cached template for ' + url);
      }
    };
    return CachedResourceLoader;
  }(_angular_compiler.ResourceLoader));
  var VERSION = new _angular_core.Version('4.3.4');
  var RESOURCE_CACHE_PROVIDER = [{
    provide: _angular_compiler.ResourceLoader,
    useClass: CachedResourceLoader
  }];
  var platformBrowserDynamic = _angular_core.createPlatformFactory(_angular_compiler.platformCoreDynamic, 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);
  exports.RESOURCE_CACHE_PROVIDER = RESOURCE_CACHE_PROVIDER;
  exports.platformBrowserDynamic = platformBrowserDynamic;
  exports.VERSION = VERSION;
  exports.ɵINTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS;
  exports.ɵResourceLoaderImpl = ResourceLoaderImpl;
  Object.defineProperty(exports, '__esModule', {value: true});
})));

})();
(function() {
var define = System.amdDefine;
!function(t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define("node_modules/redux/dist/redux.min.js", ["exports"], e) : e(t.Redux = t.Redux || {});
}(this, function(t) {
  "use strict";
  function e(t) {
    var e = h.call(t, g),
        n = t[g];
    try {
      t[g] = void 0;
      var r = !0;
    } catch (t) {}
    var o = v.call(t);
    return r && (e ? t[g] = n : delete t[g]), o;
  }
  function n(t) {
    return j.call(t);
  }
  function r(t) {
    return null == t ? void 0 === t ? m : w : O && O in Object(t) ? e(t) : n(t);
  }
  function o(t) {
    return null != t && "object" == typeof t;
  }
  function i(t) {
    if (!o(t) || r(t) != E)
      return !1;
    var e = x(t);
    if (null === e)
      return !0;
    var n = N.call(e, "constructor") && e.constructor;
    return "function" == typeof n && n instanceof n && S.call(n) == A;
  }
  function u(t, e, n) {
    function r() {
      p === l && (p = l.slice());
    }
    function o() {
      return s;
    }
    function c(t) {
      if ("function" != typeof t)
        throw Error("Expected listener to be a function.");
      var e = !0;
      return r(), p.push(t), function() {
        if (e) {
          e = !1, r();
          var n = p.indexOf(t);
          p.splice(n, 1);
        }
      };
    }
    function a(t) {
      if (!i(t))
        throw Error("Actions must be plain objects. Use custom middleware for async actions.");
      if (void 0 === t.type)
        throw Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
      if (y)
        throw Error("Reducers may not dispatch actions.");
      try {
        y = !0, s = d(s, t);
      } finally {
        y = !1;
      }
      for (var e = l = p,
          n = 0; e.length > n; n++)
        (0, e[n])();
      return t;
    }
    var f;
    if ("function" == typeof e && void 0 === n && (n = e, e = void 0), void 0 !== n) {
      if ("function" != typeof n)
        throw Error("Expected the enhancer to be a function.");
      return n(u)(t, e);
    }
    if ("function" != typeof t)
      throw Error("Expected the reducer to be a function.");
    var d = t,
        s = e,
        l = [],
        p = l,
        y = !1;
    return a({type: P.INIT}), f = {
      dispatch: a,
      subscribe: c,
      getState: o,
      replaceReducer: function(t) {
        if ("function" != typeof t)
          throw Error("Expected the nextReducer to be a function.");
        d = t, a({type: P.INIT});
      }
    }, f[R] = function() {
      var t,
          e = c;
      return t = {subscribe: function(t) {
          function n() {
            t.next && t.next(o());
          }
          if ("object" != typeof t)
            throw new TypeError("Expected the observer to be an object.");
          return n(), {unsubscribe: e(n)};
        }}, t[R] = function() {
        return this;
      }, t;
    }, f;
  }
  function c(t, e) {
    var n = e && e.type;
    return "Given action " + (n && '"' + n + '"' || "an action") + ', reducer "' + t + '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.';
  }
  function a(t) {
    Object.keys(t).forEach(function(e) {
      var n = t[e];
      if (void 0 === n(void 0, {type: P.INIT}))
        throw Error('Reducer "' + e + "\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.");
      if (void 0 === n(void 0, {type: "@@redux/PROBE_UNKNOWN_ACTION_" + Math.random().toString(36).substring(7).split("").join(".")}))
        throw Error('Reducer "' + e + "\" returned undefined when probed with a random type. Don't try to handle " + P.INIT + ' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.');
    });
  }
  function f(t, e) {
    return function() {
      return e(t.apply(void 0, arguments));
    };
  }
  function d() {
    for (var t = arguments.length,
        e = Array(t),
        n = 0; t > n; n++)
      e[n] = arguments[n];
    return 0 === e.length ? function(t) {
      return t;
    } : 1 === e.length ? e[0] : e.reduce(function(t, e) {
      return function() {
        return t(e.apply(void 0, arguments));
      };
    });
  }
  var s,
      l = "object" == typeof global && global && global.Object === Object && global,
      p = "object" == typeof self && self && self.Object === Object && self,
      y = (l || p || Function("return this")()).Symbol,
      b = Object.prototype,
      h = b.hasOwnProperty,
      v = b.toString,
      g = y ? y.toStringTag : void 0,
      j = Object.prototype.toString,
      w = "[object Null]",
      m = "[object Undefined]",
      O = y ? y.toStringTag : void 0,
      x = function(t, e) {
        return function(n) {
          return t(e(n));
        };
      }(Object.getPrototypeOf, Object),
      E = "[object Object]",
      I = Function.prototype,
      T = Object.prototype,
      S = I.toString,
      N = T.hasOwnProperty,
      A = S.call(Object),
      R = function(t) {
        var e,
            n = t.Symbol;
        return "function" == typeof n ? n.observable ? e = n.observable : (e = n("observable"), n.observable = e) : e = "@@observable", e;
      }(s = "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof module ? module : Function("return this")()),
      P = {INIT: "@@redux/INIT"},
      k = Object.assign || function(t) {
        for (var e = 1; arguments.length > e; e++) {
          var n = arguments[e];
          for (var r in n)
            Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
        }
        return t;
      };
  t.createStore = u, t.combineReducers = function(t) {
    for (var e = Object.keys(t),
        n = {},
        r = 0; e.length > r; r++) {
      var o = e[r];
      "function" == typeof t[o] && (n[o] = t[o]);
    }
    var i = Object.keys(n),
        u = void 0;
    try {
      a(n);
    } catch (t) {
      u = t;
    }
    return function() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          e = arguments[1];
      if (u)
        throw u;
      for (var r = !1,
          o = {},
          a = 0; i.length > a; a++) {
        var f = i[a],
            d = n[f],
            s = t[f],
            l = d(s, e);
        if (void 0 === l) {
          var p = c(f, e);
          throw Error(p);
        }
        o[f] = l, r = r || l !== s;
      }
      return r ? o : t;
    };
  }, t.bindActionCreators = function(t, e) {
    if ("function" == typeof t)
      return f(t, e);
    if ("object" != typeof t || null === t)
      throw Error("bindActionCreators expected an object or a function, instead received " + (null === t ? "null" : typeof t) + '. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
    for (var n = Object.keys(t),
        r = {},
        o = 0; n.length > o; o++) {
      var i = n[o],
          u = t[i];
      "function" == typeof u && (r[i] = f(u, e));
    }
    return r;
  }, t.applyMiddleware = function() {
    for (var t = arguments.length,
        e = Array(t),
        n = 0; t > n; n++)
      e[n] = arguments[n];
    return function(t) {
      return function(n, r, o) {
        var i = t(n, r, o),
            u = i.dispatch,
            c = [],
            a = {
              getState: i.getState,
              dispatch: function(t) {
                return u(t);
              }
            };
        return c = e.map(function(t) {
          return t(a);
        }), u = d.apply(void 0, c)(i.dispatch), k({}, i, {dispatch: u});
      };
    };
  }, t.compose = d, Object.defineProperty(t, "__esModule", {value: !0});
});

})();
System.register('state.js', ['node_modules/redux/dist/redux.min.js'], function (_export, _context) {
    "use strict";

    var Redux, changeUser, onActiveUserChange;
    return {
        setters: [function (_node_modulesReduxDistReduxMinJs) {
            Redux = _node_modulesReduxDistReduxMinJs.default;
        }],
        execute: function () {

            window.shell = {
                store: Redux.createStore(function (state, action) {
                    return action.payload;
                })
            };

            changeUser = function changeUser() {
                var user = document.getElementById('currentUser').value;
                window.shell.store.dispatch({ type: 'ChangeUser', payload: user });
            };

            changeUser();

            onActiveUserChange = function onActiveUserChange() {
                changeUser();
            };

            document.getElementById('currentUser').addEventListener('keyup', onActiveUserChange);
        }
    };
});
System.register('shell.js', ['node_modules/zone.js/dist/zone.js', 'node_modules/reflect-metadata/Reflect.js', 'node_modules/single-spa/lib/single-spa.js', 'node_modules/@angular/core/bundles/core.umd.js', 'node_modules/@angular/platform-browser/bundles/platform-browser.umd.js', 'node_modules/@angular/platform-browser-dynamic/bundles/platform-browser-dynamic.umd.js', 'state.js'], function (_export, _context) {
  "use strict";

  var declareChildApplication, start, angular, platform, platformDynamic, loadApp, isAppActive, getAppsFromServer;
  return {
    setters: [function (_node_modulesZoneJsDistZoneJs) {}, function (_node_modulesReflectMetadataReflectJs) {}, function (_node_modulesSingleSpaLibSingleSpaJs) {
      declareChildApplication = _node_modulesSingleSpaLibSingleSpaJs.declareChildApplication;
      start = _node_modulesSingleSpaLibSingleSpaJs.start;
    }, function (_node_modulesAngularCoreBundlesCoreUmdJs) {
      angular = _node_modulesAngularCoreBundlesCoreUmdJs.default;
    }, function (_node_modulesAngularPlatformBrowserBundlesPlatformBrowserUmdJs) {
      platform = _node_modulesAngularPlatformBrowserBundlesPlatformBrowserUmdJs.default;
    }, function (_node_modulesAngularPlatformBrowserDynamicBundlesPlatformBrowserDynamicUmdJs) {
      platformDynamic = _node_modulesAngularPlatformBrowserDynamicBundlesPlatformBrowserDynamicUmdJs.default;
    }, function (_stateJs) {}],
    execute: function () {
      loadApp = function loadApp(name) {
        return function () {
          return SystemJS.import('./childApps/' + name + '/bundle.js');
        };
      };

      isAppActive = function isAppActive(name) {
        return function () {
          return window.location.hash.startsWith('#/' + name);
        };
      };

      getAppsFromServer = function getAppsFromServer() {
        return fetch('https://api.myjson.com/bins/st4md').then(function (response) {
          return response.json();
        }).then(function (json) {
          return json.apps;
        });
      };

      getAppsFromServer().then(function (apps) {
        apps.forEach(function (app) {
          declareChildApplication(app.name, function () {
            return SystemJS.import(app.url);
          }, isAppActive(app.name));
        });
      });

      // declareChildApplication("pvwa", loadApp('pvwa'), isAppActive('pvwa'));
      // declareChildApplication("pta", loadApp('pta'), isAppActive('pta'));
      // declareChildApplication("msp", loadApp('msp'), isAppActive('msp'));
      // declareChildApplication("vanilla", loadApp('vanilla'), isAppActive('vanilla')) ;

      start();
    }
  };
});
//# sourceMappingURL=shell.bundle.js.map